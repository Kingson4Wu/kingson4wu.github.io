<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拉巴力的纸皮箱</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-07T14:41:07.803Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kingson Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软技能_代码之外的生存指南_notes</title>
    <link href="http://yoursite.com/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/"/>
    <id>http://yoursite.com/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/</id>
    <published>2023-03-02T03:24:44.000Z</published>
    <updated>2023-05-07T14:41:07.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="献言"><a href="#献言" class="headerlink" title="献言"></a>献言</h2><ul><li>谨以本书献给所有自强不息、孜孜不倦地持续自我改进的开发人员。他们具备下列素质： 永远不会对“不错”感到心满意足永远寻求每一个机会来拓展自己的视野，探索未知事物对知识的渴求永远不会熄灭笃信软件开发并不仅仅意味着编写代码。知道失败不是结束，失败只是人生旅程上的小小一步有过挣扎，有过失败，但仍然会爬起来继续战斗拥有强烈意愿和决心，在人生的道路上不畏艰难以及最重要的，愿意一路上帮助他人。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>不能只编写代码，还要有精彩的人生。</li></ul><h2 id="第1章-为何这本书与你先前读过的任何书籍都迥然不同"><a href="#第1章-为何这本书与你先前读过的任何书籍都迥然不同" class="headerlink" title="第1章 为何这本书与你先前读过的任何书籍都迥然不同"></a>第1章 为何这本书与你先前读过的任何书籍都迥然不同</h2><ul><li>我所说的“优秀的软件开发人员”，是那些能够把控自己的职业生涯、达成目标、享受生活的人。</li><li>如果你想真正成为一个更好的软件开发人员（或者其他真正优秀的人才），你需要把重点放在整个“人”上，而不只是你生活中的一两个领域。</li><li>想为这些内容分类和分组，最简易的方法是将它们看成是事业、思想、身体和精神四个方面。</li></ul><h1 id="第一篇-职业"><a href="#第一篇-职业" class="headerlink" title="第一篇 职业"></a>第一篇 职业</h1><ul><li><p>职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。</p></li><li><p>当你为了谋生一头扎进写代码的世界时，其实你和中世纪小镇上开铁匠铺的铁匠没什么差别。</p></li><li><p>当你和别人打交道的时候，你应该知道的最重要的一个概念就是：以自己为核心，每个人都希望自己很重要。这是人类最深邃、最致命的欲望之一，也是社会和生活中取得伟大成就的主要动机。</p></li></ul><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul><li><p>与主流观念相反，大多数面试官决定雇用某个人其实是基于各种各样的非技术因素。</p></li><li><p>简而言之，通过面试的最快捷的方式是让面试官对你怀有好感。达成该目标有很多方法，其中大多数可以在面试之前完成。</p></li><li><p>“破解”面试的要诀就是在面试开始之前就思考应对面试的策略。</p></li><li><p>与雇用技术高超但需要生拉硬拽才能干活的人相比，我宁愿雇用这样的开发人员：知道的东西可以少一点，但是明确知道要做什么，以及怎样去做。从某种程度上，在你可控的范围之内，面试的时候你要集中精力证明自己就是无需督促也能自动自发做好事情的员工。</p></li><li><p>你还必须要证明：在技术上你确实胜任工作。同时，如果你能说服面试官相信你非常能干，不会被困难阻挡，那么他们不仅会喜欢你，而且更有可能会录用你。</p></li></ul><h3 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h3><ul><li><p>专业化的规则是：专业化程度越深，潜在的机会就越少，但获得这些机会的可能性越大。</p></li><li><p>做一个技术全面、多才多艺的软件开发人员非常棒。能够使用多项技术和多种编程语言，有助于你的职业发展，能让你比那些仅了解一项技术或一种编程语言的软件开发人员更有价值。然而，这种“万金油”式的人才在市场上并不吃香。</p></li><li><p>从薪资和福利的角度评价一个潜在的工作机会是很容易的，但是从长期发展和工作环境的角度去评价可能对你更为重要。</p></li></ul><h3 id="大中小公司"><a href="#大中小公司" class="headerlink" title="大中小公司"></a>大中小公司</h3><ul><li><p>在为一家大公司工作时，你会注意到的最大的事情也许就是那里大量的规范和流程。</p></li><li><p>在大公司工作时，你要遵守这里已有的做事方式。鲁莽和“变节者”在这种企业文化里不受欢迎。</p></li><li><p>在大公司里倒是很容易就隐藏在芸芸众生之中。在我曾供职的几家大公司里里，有一些开发人员基本上终日无所事事，除非赶上一轮全公司范围内的大裁员，否则根本不会有人注意到他们。不过，这种自主权也可以被善加利用。你能够去琢磨自认为重要或有趣的项目，无需背负产品压力。</p></li><li><p>如果公司的业务重心并非软件，那自然也不会给软件开发人员足够的尊重和发展空间。这些公司的软件开发实践极有可能非常松散。</p></li><li><p>另一方面，那些以软件开发为生的公司则会更重视自己雇用的软件开发人员的价值。他们的工作环境不一定会更好，但会大不一样。</p></li><li><p>在推行敏捷软件开发方法的时候，这两类公司之间的差异非常明显。软件为非核心业务的公司在采用敏捷过程中困难重重，这是由于敏捷过程通常是由开发团队驱动的。敏捷过程需要自上而下地采纳推行，但是仅仅因为一些开发人员认为敏捷是个好主意，就让公司改变自己的做事风格，异常困难。</p></li></ul><h3 id="突颖而出"><a href="#突颖而出" class="headerlink" title="突颖而出"></a>突颖而出</h3><ul><li><p>在任何公司里能让你脱颖而出的最重要法宝就是承担更多的责任。</p></li><li><p>没有人愿意涉足的领域是搜寻机会最好的地方。</p></li><li><p>如何能让自己承担更多责任<br> 有一个不受重视的项目，你能去负责它吗？<br> 你能帮助团队里的新人快速成长吗？<br> 你能负责文档制作流程，并保证及时更新这些文档吗？<br> 哪项工作是没有人愿意去做，你愿意承担起来，并将其简化或者自动化的？</p></li><li><p>如何令自己引人注目<br>每天都记录自己的活动日志——把这个日志以周报的形式发送你的经理。<br>提供演讲或培训——选择一个对你的团队有用的话题。<br>发表意见——只要在会议上就这么做，或者只要你能得到的机会就这么做。<br>保证“曝光度”——定期与老板会面，确保你经常被注意到。</p></li><li><p>在任何公司中，最有用的就是那种看似没有克服不了的障碍的人。</p></li><li><p>有时候只要意识到自己的工作毫无前途，就需要寻找更好的机会。也许你的工作环境很艰苦，残害身心，也许裙带关系盛行，你只能原地踏步。无论什么原因，你可能都需要换工作了。</p></li></ul><h3 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h3><ul><li><p>成为专业人士是一种心态。如果我们总是与恐惧、自毁、拖延和自我怀疑作斗争，那么问题就是：我们正在像外行那样思考问题。外行毫不起眼，外行人废话连篇，外行屈从于逆境。专业人士可不这么想。不管怎样，他引人注目，他恪尽职守，他始终如一。</p></li><li><p>成为专业人士的全部在于：引人注目，恪尽职守，以及不屈服于挫折。</p></li><li><p>专业人士会严肃对待自己的责任和事业，愿意作出艰难的选择去做自己认为是正确的事情——往往还要自己承担代价。</p></li><li><p>作为一名专业人士需要养成的另一个强大的习惯是时间管理技能。</p></li><li><p>有时候，专业人士必须对工作的优先级做出艰难的抉择。</p></li><li><p>专业人士会评估需要完成的工作，判定优先级后再开始工作。</p></li><li><p>专业人士是通过持续不断的自我完善达到自己所追求的高品质的。</p></li></ul><h3 id="为自己工作"><a href="#为自己工作" class="headerlink" title="为自己工作"></a>为自己工作</h3><ul><li><p>如果想辞职为自己打工，需要一个切实可行的计划。你必须要想方设法积攒够足够多的收入来支撑自己，直到你的新生活步入正轨。</p></li><li><p>如果你想让自己的产品也同样成功（虽然也许在规模上达不到），首先打造一个成功的博客，使用播客、演讲、视频和其他媒体来发展自己的受众。接下来，一旦你有了受众，你就能够向这些受众销售自己的产品。你之所以购买这本书可能就是因为你已经是我博客的粉丝，或者因为关注我的其他工作而无意中发现这本书，或者你之前听过我的播客。这就是发展自己的受众的威力。</p></li><li><p>你必须明白并意识到，自己的首次创业可能会失败，很可能第二次、第三次也是如此。直到经过足够多的失败，你才可能真正成功。如果你倾尽所有投入创业，如果你为一次创业成功赌上自己的整个未来，你可能会把自己置于绝境——没有资源，甚至没有意志再去尝试一次。所以别这么做。从小处着手，作为副业开发你的第一个产品。</p></li><li><p>我们不能过分相信自己可以不受外界干扰或者能够智慧地管理时间。我们需要提前做好计划，否则会屡屡经受不住诱惑。</p></li></ul><h3 id="对技术保持开放"><a href="#对技术保持开放" class="headerlink" title="对技术保持开放"></a>对技术保持开放</h3><ul><li><p>如果你能让自己不成为某种技术的信徒，你会在职业生涯之路上走得更远。</p></li><li><p>没有理由去强烈坚持自己选择的技术就是最好的，而轻视甚至无视其他技术。如果固执己见，最终受损失的是你自己。</p></li><li><p>另一方面，如果你愿意技术保持开放的心态，而不是固守在自己已经了解的技术，声称它是最好的，你会发现有更多的机会为你敞开大门。</p></li></ul><h1 id="第二篇-自我营销"><a href="#第二篇-自我营销" class="headerlink" title="第二篇 自我营销"></a>第二篇 自我营销</h1><ul><li><p>营销就是一场争夺人们注意力的竞赛。</p></li><li><p>营销追求的是“实现价值在先，要求回报在后”。</p></li><li><p>自我营销的正确方式就是为他人提供价值。</p></li><li><p>只要营销得法，即便是“菜鸟”或者“业余爱好者”的身份都是你的优势所在——很多人都喜欢向只比自己稍微优秀一点点的人学习，因为这些人才是可望而又可及的。</p></li><li><p>自我营销的基本机制是，要想让人们追随你、倾听你，你就要带给他们价值：你能为他们的问题提供答案，甚至是给他们带去欢乐。如果你在持续自我提升的同时并没有给他人带来价值，那么你终究不会走得太远，因为每个人都会离你而去。</p></li><li><p>要打造一个品牌，你需要四个要素——品牌所要传递的信息、品牌的视觉符号、品牌的一致性和品牌的曝光率。</p></li></ul><h3 id="打造自己的博客"><a href="#打造自己的博客" class="headerlink" title="打造自己的博客"></a>打造自己的博客</h3><ul><li><p>即使你对上面提及的博客能带给你的所有好处都打了折扣，有一个好处是你无法轻易抹杀的——提高你的沟通技巧。组织自己的思想，并将其转化为文字，是一项颇具难度却也极具价值的技能。</p></li><li><p>定期写作能帮助你打磨此技能，有了很好的沟通能力会让你在生活的诸多领域受益。此外，如果你能约束自己定期更新博客，你也就在持续刷新自己的技能，保证自己处于自己所在专业领域的前沿。</p></li><li><p>作为软件开发人员，学习如何写博客实际上都能帮你写出更好的代码，因为你能更轻松地传达自己的意图。博客还能帮你更好地传达自己的想法，令想法更有说服力。</p></li></ul><h3 id="为他人增加价值"><a href="#为他人增加价值" class="headerlink" title="为他人增加价值"></a>为他人增加价值</h3><ul><li><p>不要努力成为一个成功的人，而要努力成为一个有价值的人。——阿尔伯特·爱因斯坦</p></li><li><p>当你营销自己的时候，如果你所做的一切都只是为了自己的利益而不给别人带来真正的价值，那么即使你所做的都正确无误，那也无济于事。</p></li><li><p>人们最关心的还是自己。没人想听到你的成功故事，也不想知道为什么他们要帮你获得成功，但是他们肯定想听到你会怎样帮他们获得成功。所以，要想让自我营销的所有努力奏效，基本的方法就是帮助他人获得成功。</p></li><li><p>免费内容比付费内容更容易被分享。你撰写博客、制作视频或者播客，然后将这些内容免费提供，与收费内容相比，人们更可能会分享和传播这些免费的内容。分享免费内容就跟在Twitter上发链接或发邮件一样简单。与付费内容相比，免费内容能让你触及更多的目标受众。</p></li><li><p>虽然免费做这些事情看起来是在浪费时间，但是你要把它视为对未来的一项投资。通过为人们创造价值并且免费提供这种方式自我营销，你就赢得了为他人提供价值的声誉，也为自己的未来创造了机会。这种声誉的价值是无法衡量的。它能帮你赢得更好、更高薪水的工作，获得更多的客户，或者成功地发布一款产品。</p></li><li><p>你很容易落入这样的陷阱：一直谈论自己并试图证明自己价值连城。然而，你会发现，能解决他人的问题，真正能够帮到他人，你更容易获得成功。</p></li><li><p>帮助他人实际上就是在帮助自己获得成功。</p></li></ul><h3 id="克服恐惧"><a href="#克服恐惧" class="headerlink" title="克服恐惧"></a>克服恐惧</h3><ul><li><p>如果你真的想在自我营销方面获得成功，你就一定要学着克服我们大多数人都会有的一种恐惧——看起来像个傻瓜。</p></li><li><p>如果你想成功，你必须要学会收起自己脆弱的自尊心，勇敢走出去，别害怕让自己出丑。</p></li><li><p>在我的职业生涯中，我一共错失了9000多次投篮，输掉了近300场比赛。我本来有26次绝杀的机会却投球不进。我失败了一次又一次。这就是我能够成功的原因。——迈克尔·乔丹</p></li></ul><h1 id="第三篇-学习"><a href="#第三篇-学习" class="headerlink" title="第三篇 学习"></a>第三篇 学习</h1><ul><li><p>教育就是当一个人把在学校所学全部忘光之后剩下的东西。——阿尔伯特·爱因斯坦</p></li><li><p>软件开发人员可以学到的最重要的一项技能就是自我教育能力。</p></li><li><p>无论如何，学会学习是自我教育的核心技能。</p></li><li><p>最好的方法就是付诸于实践，如果你也能承担将自己所学的内容教给别人的任务，那么你会理解得更深刻。所以，你在自我教育方面的努力，应该聚焦在如何让自己切实参与，并且尽早付诸实践。</p></li><li><p>我觉得学习知识的最好方式就是立即将其用于实践，即使你还不知道自己在做什么。</p></li></ul><h3 id="让学习玩起来"><a href="#让学习玩起来" class="headerlink" title="让学习玩起来"></a>让学习玩起来</h3><ul><li><p>如果关于某个主题你能够获得足够的知识能够操作，你就可以发挥自己心灵深处强大的创造力和好奇心。当我们能够在一件事情上尽情发挥的时候，我们的内心就更倾向于吸收更多的信息，思考更有意义的问题。这似乎有些奇怪，但事实的确如此。</p></li><li><p>本方法的关键指导原则是通过玩儿、探索以及将自己所学教给他人来学习。这一简便易行的方法更符合我们的天性——在某种程度上，抛弃了“填鸭式教学”的自主学习才是最简单和最纯粹的学习方式。</p></li></ul><h3 id="如何快速学习"><a href="#如何快速学习" class="headerlink" title="如何快速学习"></a>如何快速学习</h3><ul><li><p>我发现，为了能够掌握一门技术，我需要了解以下三个要点。<br>1．如何开始——要想开始使用自己所学的，我需要掌握哪些基本知识？<br>2．学科范围——我现在学的东西有多宏大？我应该怎么做？在开始阶段，我不需要了解每个细节，但是如果我能对该学科的轮廓有大致的了解，那么将来我就能发现更多细节。<br>3．基础知识——不止在开始阶段，要想使用一项特定的技术，我需要了解基本的用户案例和最常见的问题，也需要知道自己学的哪20%就能满足80%的日常应用。</p></li><li><p>熟知了这三个关键点后，我可以高效地学习一门技术，无需通晓全部细节。我发现，如果我了解三项主题——如何开始，我能做什么，以及相关基础知识，那么我就能随着学习深入学会所需的其他知识。</p></li><li><p>如果我想提前掌握所有知识，那只是在浪费时间，因为真正重要的内容会湮没在那些细枝末节中。</p></li><li><p>这种新方法能让我关注重点。当我确实需要了解更多细节时，我可以利用参考资料来弥补这些不足。</p></li><li><p>“十步学习法”的基本思想就是：要对自己要学的内容有个基本的了解——了解自己不知道什么就足矣。然后，利用这些信息勾勒出学习的范围，即需要学哪些内容，以及学成之后又会获得什么。依靠这些知识，你可以找出各种资源（不局限于书）来帮助自己学习。最后，你可以创建自己的学习计划，列出要去学习哪些相关课程，筛选学习材料，只保留能帮助自己达成目标的优质内容。</p></li></ul><h3 id="“十步学习法”体系"><a href="#“十步学习法”体系" class="headerlink" title="“十步学习法”体系"></a>“十步学习法”体系</h3><p><img src="/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95.jpg"></p><ul><li><p>一旦完成这些工作，你对自己要学什么和怎样学都了然于胸，你就可以把控自己的学习计划中的每个关键点，通过“学习—实践—掌握—教授”（Learning, Doing, Learning and Teaching，LDLT）的过程，获得对该学科的深刻理解，同时你也向着自己的目标前进。</p></li><li><p>“十步学习法”的第一部分是研究，它是一次性完成的。但是从第7步到第10步则是重复的过程，贯穿于你的学习计划的各个模块。这个方法非常奏效，因为它迫使你提前明确自己的学习目标，也持续不断的激励你通过实践（而不仅仅是读书或听讲座）向着目标前进。</p></li><li><p>通过“聚焦学习范围，让你关注重点内容”来学习的一种快速学习方法，它迫使你通过“自我探索”和“主动教学”的方式将真正重要的内容印刻在自己的大脑中。</p></li><li><p>在学习过程中，大家很容易犯的一个错误就是试图解决太大的问题而把自己搞得不堪重负。</p></li><li><p>你无需提前了解全部内容，你要做的首要的一件事情就是亲自操作和亲身体验。</p></li><li><p>采用这种方法，你通过探索和实践进行学习。</p></li><li><p>把那些暂时还没有答案的问题记录下来，你在下一步中会有机会找出这些问题的答案。</p></li><li><p>不要害怕回头再去操作，付出更多，因为这不仅能让你找到问题的答案，也能让你学到新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。</p></li><li><p>不过请记住，你依然没有必要把收集到的所有资料全部仔细看一遍。你只需要阅读或观看与当前所学相关的部分。我们很少能有足够的时间把一本书从头读到尾。</p></li><li><p>这些资料只是帮你自学，基本上你可以以解决在动手操作中发现的问题为主要目的。</p></li><li><p>做导师的好处<br>帮助他人时的成就感。<br>深入学习和领悟知识的途径。<br>你的徒弟有朝一日会帮到你。<br>自身的成长。<br>帮助别人成长的过程也就是自己成长的过程。</p></li><li><p>学习知识的一大方法，或许是唯一可以做到深入学习的方法，就是传道授业。</p></li><li><p>知识短板会阻碍你进步。准确识别它们的最佳方式之一就是看看自己在哪些工作上花费了大量的时间，或者一直进行重复性劳动。通常，你会发现，自己的知识短板使工作速度放缓，额外需要大量的时间完成任务。</p></li><li><p>另一种识别知识短板的方法就是，时刻都要试图了解自己不理解或不清楚的事物。你可以维护一份清单，列出自己需要去研究或者自己不清楚的所有事物，追踪有哪些主题总是不断出现在这个清单上。你会惊讶地发现这份清单的增长速度有多快。你只要对自己坦诚：如果遇到不理解的知识，不需要马上就学会，但是一定要把它添加到清单中，这样你至少可以找出自己的知识短板。</p></li><li><p>假如你在准备面试，需要明确自己要学什么，这一方法最管用。尽量找出尽可能多的你在面试中可能会被问到的问题。</p></li><li><p>检查知识短板</p></li></ul><p><img src="/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/%E7%9F%A5%E8%AF%86%E7%9F%AD%E6%9D%BF.jpg"></p><h1 id="第四篇-生产力"><a href="#第四篇-生产力" class="headerlink" title="第四篇 生产力"></a>第四篇 生产力</h1><ul><li>产量多只表明生产效率高，只有完成正确的工作才会成为高效的人。</li></ul><h3 id="一切始于专注"><a href="#一切始于专注" class="headerlink" title="一切始于专注"></a>一切始于专注</h3><ul><li><p>想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松保持。</p></li><li><p>要进入专注模式，必须要克服将自己的思绪集中于单一任务时的那种痛感。除非你完全享受完成这项任务，否则这种痛感一开始会很强烈。但是，这正是关键所在。你必须要意识到，这种痛苦和不适只是暂时的，不会持续很久。</p></li></ul><h3 id="工作计划"><a href="#工作计划" class="headerlink" title="工作计划"></a>工作计划</h3><ul><li><p>我的计划都是从“季度”开始的。我把我的一年分成4个季度，每个季度3个月。在做季度计划时，我会尽力列出我想在本季度完成的每一个大项目，我还会制订一些较小的目标。我会思考我在每一周或每一天分别完成哪些工作。</p></li><li><p>每个月的第一天我会打印出当月的月历，并且规划出每天要完成的工作。</p></li><li><p>每个月我都会将该月要完成的所有任务列入计划。</p></li><li><p>每周一的早晨，我会做我的周计划。</p></li></ul><h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><ul><li><p>它的基本思路是：你规划出打算一天之内完成的工作，然后设置一个时长25分钟的定时器，去完成计划中的第一项任务；在这25分钟之内，你只专注于这一项任务，心无旁骛。一旦有干扰，可以用各种方法屏蔽掉干扰，但是通常你要努力保证自己完全不被打扰。总之，你不希望自己的专注的工作状态被打断。</p></li><li><p>在25分钟结束的时候，设置一个5分钟的定时器，休息一下。这就是所谓的一个“番茄钟”。每4个番茄钟后，你都需要休息一会儿，通常为15分钟。从技术上讲，如果提前完成任务，你应该将剩余时间设置为“过度学习”时间。也就是说，你需要继续对已完成的工作做出小幅改进，或者重新阅读材料以便于你能够再学一些新东西。我往往会忽略这部分，立即跳转到下一个任务。</p></li><li><p>这就是“番茄工作法”的基本流程。它就是这么简单。弗朗西斯科最初使用了一个番茄形状的厨房定时器给自己设置番茄钟</p></li><li><p>第一次使用番茄工作法的时候，我并没有严格做到它规定的要求。我只是每天用它来设置若干个“25分钟”的番茄钟。我并没有留意自己每天完成了几个番茄钟，也没有估算某项任务要用掉几个番茄钟；因此我并没有从中受益。</p></li><li><p>有一个大问题一直困扰着我：我总为自己没有做更多的事情而感到内疚。这与我一天完成多少工作无关，就好像我永远不能放松似的。我总觉得自己应该在做事，以至于坐下来玩游戏（我最喜欢的消遣之一）时我都无法享受其中，因为我觉得自己在浪费时间，我本应该做更多的工作。也许你也有同感。</p></li><li><p>这个问题的根源在于，你无法准确地评估每天到底自己完成了多少任务，也没有为自己每天到底要完成多少任务设定明确的目标。</p></li><li><p>制订任务列表全凭主观臆断，每天能够专注完成的工作量才是最重要的。</p></li><li><p>这正是番茄工作法的真谛之所在。当你在一天中为自己设置了x个番茄钟的工作目标（这一目标你完全可控）并且达成的时候，你就可以知道自己一天到底可以完成多少工作，这会让自己感觉良好，更重要的是，还能让自己放松身心。</p></li><li><p>对番茄工作法的正确理解令我的工作生活大为改观，它不仅能帮我能做更多事情，而且能让我可以尽情享受业余时间。一旦我完成了当天的目标（以番茄钟来度量的），我就可以自由自在地做自己想做的事情。</p></li><li><p>如果我觉得自己状态不错，我可能还会多做一些工作。但是，如果我想坐下来玩游戏，甚至看电影消磨时间，或者其他不费脑子的活动，我也不会感到内疚，因为我知道我已经努力工作一整天了。</p></li><li><p>如果你使用番茄工作法度过充实的一天，你完成的工作的要比平常完成的多很多。好消息是，你的生产效率更高；坏消息则是，你需要花一段时间才能适应它（我没骗你）。</p></li><li><p>我一周的目标是50～55个番茄钟。如果我可以达成目标，我就知道自己做得很好，也能希望每周都能持续改进目标。</p></li><li><p>如果你也打算采用番茄工作法，要先确保你对自己的能力有符合实际的预期。你每周工作40小时并不意味着你能完成80个番茄钟。（如果你能实现这一壮举，我会大吃一惊的。而且，坦白讲，我会担心你的心理健康。）</p></li><li><p>每人每天能够专注地、富有成效地工作的时间是有上限的。你的时间只有这么多，要怎么利用你自己说了算。</p></li></ul><h3 id="定额工作法"><a href="#定额工作法" class="headerlink" title="定额工作法"></a>定额工作法</h3><ul><li><p>我用“定额工作法”确保自己每天、每周都朝着自己最重要的目标取得明确的、可度量的进展。</p></li><li><p>我开始意识到，要想确保自己在追求目标的道路上获得持续的进展，唯一的方法就是确立一个明确的目标，规定自己要在预先确定的时间段内需要取得多大的进展。</p></li><li><p>实行定额制后，我发现自己的工作成果比以往多了很多。最大的好处在于，长期坚持这么做，我就能随着时间的推移度量并标记自己的进度。我可以确切知道自己在给定的一段时间内能够完成的工作量。</p></li><li><p>承诺是“定额工作法”的核心。除了想方设法完成自己的工作，不给自己留下任何其他的选择。在你心中，失败不是一个可以被接受的选项。因为如果你让自己失信一次，就会有第二次，很快定额在你眼中就会变得一文不值。</p></li><li><p>如果你的承诺力度不够，“定额工作法”顷刻就会分崩离析，所以你必须选择可实现、可持续的定额。不要对自己承诺自己明知不可能达到的目标，否则你就把自己逼入注定失败的绝境。开始的时候承诺可以小一点，在能够达成之后再逐步做大胆的承诺。</p></li><li><p>定额工作法的规则<br>挑选一项重复性任务。<br>明确有效时限，在此期间该任务被重复执行。<br>明确在给定的有效时限内该任务应该完成的次数的定额。<br>给自己承诺：一定要达成定额。<br>调整。调高或者调低定额，但是不能在有效时间段之内调整。</p></li><li><p>定额工作法成功的秘密可以追溯到“龟兔赛跑”的故事。以缓慢但稳定的节奏工作，要优于快速但缺乏持久和坚持的工作方式。</p></li><li><p>定额工作法还可以帮你克服意志力薄弱的问题，通过预先设定好的必须要遵循的过程，消除需要做出决策的部分。因为已经预先承诺在规定时间段内完成同一任务很多次，所以就不需要再判断要不要做某事——你知道必须要做。每一天，任何需要做决策的时刻，你都不得不被迫动用自己仅存的有限的意志力。以定额的形式将决策转变为命令，你无需再做决策，也就避免了意志力耗尽的问题。关于这一主题，可参考Kelly Mc Gonigal写的《自控力》</p></li><li><p>采取行动<br>列出自己生活中需要重复做的所有任务。特别要专注于那些目前你还无法持续完成但一旦完成就会从中受益的事情。<br>选择至少一项任务，承诺在规定时间段内要完成的额度。认真对待这一承诺，试着坚持至少5个时间段。想象一下，如果自己能坚持几个月或几年，会发生什么。</p></li></ul><h3 id="对自己负责"><a href="#对自己负责" class="headerlink" title="对自己负责"></a>对自己负责</h3><ul><li><p>让人们完成工作主要有两大动机——内部动机（来自内心的动机）和外部动机（来自外部奖励或惩罚的动机）。</p></li><li><p>内部动机要比外部动机有效得多。在内部动机的激励下工作时，我们能完成更多的工作，也更倾向于把工作做得更好。所以，秘诀是让你的主要动机来自内心而非外部。</p></li><li><p>培养出在没有人监督自己的时候也能高效工作的自我责任感非常重要。</p></li><li><p>要培养“对自己负责”的精神，首先要让自己的生活井然有序。</p></li><li><p>你可能会发现，只对自己负责的时候很容易违反自己制订的规则。在这种情况下，需要借助一点儿外力。你仍然可以制订自己的规则，因此动机还是来自内部——因为你还是规则的制订者，只是你可以让别人帮你强制执行这些规则。</p></li><li><p>请别人来监督自己履行责任，完成自己的承诺，并没有坏处。找到责任监督伙伴——理想情况下，最好是跟你有类似目标的人，这样会很有帮助。你可以告诉他你给自己制订的规则，或者你想达成的目标，通过定期互相汇报进度（不论成败），可以互相帮助对方强化责任感。</p></li><li><p>通常，想到要告诉自己的责任监督伙伴自己没能完成设定的目标，就足以阻止自己不够自律的行为。</p></li><li><p>采取行动<br>抉择一下：你想如何度过自己的一生。花点儿时间创建一些自己的规则，确保自己朝着正确的方向前进。<br>创建自己的责任制度，帮助自己严格执行规则。</p></li></ul><h3 id="是否多任务并行"><a href="#是否多任务并行" class="headerlink" title="是否多任务并行"></a>是否多任务并行</h3><ul><li><p>有的任务适合多任务并行，有的则不适合。如果你真想最大限度地提升自己的工作效率，就必须知道什么时候需要多任务并行，什么时候不需要，以及如何高效地进行多任务并行。</p></li><li><p>对于很多活动，我们可能会自认为是在进行多任务并行，但实际上我们做的不过是在不断地进行任务切换。这样的任务切换看起来确实是工作效率下降的罪魁祸首。任务切换越多，浪费的时间也就越多，因为你的大脑并不能专注于一项任务。</p></li><li><p>如果你认为自己出于专注状态时工作效率最高，且需要花些时间才能到达这种状态，你就能明白，在各种任务间快速切换并不会提高效率。</p></li><li><p>真正的多任务并行使我极大地提升了自己的生产力。如果你可以将两项任务组合起来，并且真正做到同时处理它们两个，你才能完成更多。诀窍在于搞清楚哪些任务可以被真正组合起来而不会降低单独执行每项工作的生产效率。</p></li><li><p>我发现，最有可能的就是，将一项不费脑筋的任务和一项一定程度上需要精神专注才能完成的任务组合起来。现在，我正一边听着耳机里的音乐一边打字写这一章。当然，听音乐本身并不是一项富有成效的工作，不过事实证明，在写作的时候听音乐能让我比单纯写作更富有成效。音乐似乎能让我写作更流畅，还能帮我减少其他会分散注意力的外界干扰。</p></li><li><p>再来一个更有效率的例子？我通常会尝试把体育运动与培训活动组合在一起。在健身房跑步或举重的时候，我经常会听有声读物或者播客。我发现，一边做健身活动一边听一些培训材料没有任何负面影响。通过一边健身一边听有声读物，我已经读完了很多书。</p></li><li><p>采取行动<br>停止任何并非真正的多任务并行的多任务并行。每天力争在一个时间段内只做一件事。番茄工作法对此有很大帮助。<br>一次性批量处理小任务，而不是每天或每周里做许多次。<br>找出能够真正实现多任务并行的领域。任何不需要耗费脑力的活动都可以跟其他活动结合起来。只要进行任何需要耗费脑力的活动，就将其与体育运动结合起来。</p></li></ul><h3 id="职业倦怠"><a href="#职业倦怠" class="headerlink" title="职业倦怠"></a>职业倦怠</h3><ul><li><p>提高生产力的最大障碍之一就是身体和心理上的倦怠。</p></li><li><p>项目刚开始的时候，我们总是热情高涨、精力旺盛，但是一段时间之后，即便我们再有激情，一想到它们也会让我们反胃。</p></li><li><p>如果能咬紧牙关坚持到底，如果能穿越那堵墙战胜自己，最终你会发现，简单地无视它的存在，你的倦怠感已经不治而愈。经历痛苦就是克服倦怠的秘诀。你以后还会撞到更多的墙，但每穿越它一次，你将会体验到全新的动力、充沛的活力。另外，你的竞争者的数量会越来越少。</p></li><li><p>本质上，你需要为自己创建一套确保自己继续前行的规则。<br>你需要突破这堵墙就以写这本书为例。刚开始动笔的时候我兴奋极了，想不出来有什么能比坐下来整天写“自己的书”更有趣的事情了。但是，没过多久这种新鲜感就消失殆尽。但是，你能读到这本书就证明我已然坚持到了最后。我是如何在动力和兴趣消失殆尽的时候坚持到底的呢？我为自己设定了一个时间表，并且坚决执行。无论刮风下雨，无论自己感觉如何，我都坚持每天写完一章。有些日子还会多写一点儿，但是总是保证至少一章。你可以采用类似的方法来帮自己突破阻挡了你的那堵围墙。想学会弹夏威夷四弦琴？每天留出一定的时间练习。在上第一堂课之前就制订好这样的计划——那时你的兴趣和动机都处于最高点。当你不可避免地撞到这样一堵墙的时候，这个计划能帮助你穿过它。</p></li><li><p>采取行动<br>想一想以前都有哪些项目是你付出努力却没有最终完成而半途而废了。是什么原因让你放弃的？你现在对这件事儿有什么感受？<br>下次开始新项目的时候，下定决心：你一定会完成，或者完全掌握。设定规则和约束条件，强迫自己穿过那堵不可避免的墙。<br>如果你正面临职业生涯或者个人生活中的一堵墙，试着去穿越它。想想在墙的另一侧会有怎样的收获等着你。想象自己的动机和兴趣终将获得回报。</p></li></ul><h3 id="时间杀手"><a href="#时间杀手" class="headerlink" title="时间杀手"></a>时间杀手</h3><ul><li><p>一些常见的时间杀手<br>看电视。<br>社交媒体。<br>新闻网站。<br>不必要的会议。<br>烹饪。<br>玩电子游戏（尤其是网络游戏）。<br>工间喝咖啡休息。</p></li><li><p>地雷：烹饪、工间喝咖啡休息或者其他你喜欢做的事情是在浪费时间吗？也是也不是。答案取决于你为什么做这些事情。为了享受快乐有意识地做这些事情，就不是浪费时间，只要你是因为喜欢才特意做这些事情，而不是为了逃避自己应该完成的实际工作。我曾经把玩电子游戏视为浪费时间，但是我喜欢玩电子游戏。这是否意味着我要完全放弃玩电子游戏呢？不是的。但是，当我有任务需要完成的时候，我就不能玩电子游戏。我不能用玩电子游戏来逃避自己本该完成的工作。同样的原则也适用于烹饪。也许你喜欢烹饪，为自己制作健康美食。如果是这样，那就太棒了。但是，如果你不特别喜欢烹饪，却要耗费大量时间来准备简单的一餐，那你就需要找出其他的健康饮食的方法来减少用于烹饪的时间。我的目的不是让你抛弃生活中的喜好，只是确保你没有把时间浪费在一些没必要做或者不那么喜欢做的事情上，或者吞噬掉你所有业余时间的事情上。</p></li><li><p>采取行动<br>下一周，你精心地跟踪一下自己的时间花费情况。获取精确的数字，了解每天的每小时你都是怎样花掉的。看看数据，找出你最大的2～3个时间杀手。<br>如果你有看电视的习惯，尝试离开电视一周，即尝试度过一个“无电视周”，看看如果不看电视你都会做些什么。<br>弄清楚哪些时间是可以“买回来”的，如雇人为你修剪庭院、做保洁等。（如果切断有线电视，你甚至可以用这笔省下来的钱来支付上述费用。）</p></li></ul><h3 id="形成惯例的重要性"><a href="#形成惯例的重要性" class="headerlink" title="形成惯例的重要性"></a>形成惯例的重要性</h3><ul><li><p>生产力的真正秘诀在于：长期坚持做一些小事。</p></li><li><p>他们没有意识到，横亘在自己与梦想之间的无非就是“惯例”。惯例塑造你的生活，让你变得更有生产效率，惯例是让你实现目标最强大的方式之一。你每天的行为日积月累下来，可以让你生活的每个方面都得到提升。</p></li><li><p>每天都安排时间处理这些任务，以便你可以确保它们被完成。当我在办公室工作的时候，每天我会抽出30分钟时间学习自己工作中会用到的技术，我习惯将其称为“研究时间”。</p></li><li><p>每天的生活越有条理，就越能把控自己的生活。</p></li><li><p>想想看，如果你一直对外界作出反应，如果你总是在事情出现的时候被动地处理事情而不是主动地规划，那么周围的环境会左右你的生活，而不是你自己。</p></li><li><p>例行安排示例</p></li></ul><p><img src="/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/%E4%BE%8B%E8%A1%8C%E5%AE%89%E6%8E%92%E7%A4%BA%E4%BE%8B.jpg"></p><ul><li><p>地雷：注意不要过于沉迷于惯例你应该有自己遵循的惯例，但是也要有一定的灵活性。你可能会打乱一天的日程安排。不要忘记会有像车坏了这种不可预测的事件发生，车坏了可能会打乱你的例行安排。你需要学会从容应对这些事情。</p></li><li><p>采取行动<br>你目前有哪些惯例？跟踪一下你的日常活动，看看你已经在遵循的惯例有哪些。<br>选择一个大目标，以每个工作日为单位制订例行安排。计算一下，如果你每天都朝着这个目标前进，一年下来你会取得多大的成就。</p></li></ul><h3 id="培养习惯"><a href="#培养习惯" class="headerlink" title="培养习惯"></a>培养习惯</h3><ul><li><p>成就我们的恰恰就是那些不断重复做的事情。因此，优秀不是一种行为，而是一种习惯。——亚里士多德</p></li><li><p>我们每个人都有习惯，有好有坏。好习惯能够推动我们前进，帮助我们成长；坏习惯则阻止我们前进，阻碍我们成长。培养和养成良好的习惯可以让你不需要刻意努力就保持很高的生产效率。如同惯例可以帮我们缓慢而坚定地每次只砌好一块砖，最终建起一面巨大的墙一样，习惯也可以通过日积月累的努力，让我们前进或者后退。二者最大的区别在于，惯例是我们可以控制的，而习惯却不受控于我们。</p></li><li><p>习惯主要由三个要素构成：暗示，惯例和奖励。</p></li><li><p>我们的大脑非常善于养成习惯。我们会根据周围的事物自发地养成习惯。一件事情做的越多，越可能形成习惯。习惯的力量往往基于奖励的价值。我们都喜欢做能够带来更好回报的事情。然而，奇怪的是，可变化的奖励要比已知的标准奖励更让人着迷。这就是在赌场能看到那么多人的原因。不知道自己是否能得到奖励或者不知道奖励有多大，会形成一种很坏的习惯，即公认的“上瘾”。</p></li></ul><h3 id="分解任务"><a href="#分解任务" class="headerlink" title="分解任务"></a>分解任务</h3><ul><li><p>造成拖延的首要原因之一，同时也是造成生产力低下的祸根，就是总是在感慨一个问题：好忙啊，问题好大啊……实际上，你并没有真正试着去解决问题。当我们从任务的全貌来审视任务的时候，它们看起来比真实情况都要大，并且更吓人。</p></li><li><p>克服拖延的提高生产力的窍门：分解任务。通过将大任务分解为小任务，你会发现自己更有动力去完成它们，也更加稳妥地向着目标前进。</p></li><li><p>这些大任务或大项目给我们带来了心理上的伤害，也削弱了我们的生产力——因为我们无法看清楚未来的前景。从宏观上审视一项大型任务的全貌时，它看起来几乎是不可能完成的</p></li><li><p>大型任务给人带来沉重的心理负担。面对大问题时，我们倾向于花更多的时间思考问题本身，而不是采取行动去解决问题。人类倾向于选择阻力最小的路径。</p></li><li><p>但是拖延还不是我们不喜欢大型任务的唯一原因。任务越大，越难明确定义。</p></li><li><p>大型任务往往也很难估算完成时间。</p></li><li><p>大型任务是一种智力挑战，与小任务相比，大任务更可能导致拖延，通常描述也更少，更容易出错，也更难估算完成时间。</p></li><li><p>当把任务分解成小块的时候，这些任务就变得更易于完成，对完成任务所需的时间的估算也更精确，你也更有可能正确地完成它们。即使有些小任务没有正确完成，你也有很多机会改正，而不至过多地影响大项目。我发现，把大任务分解成小任务真是一个好主意。</p></li><li><p>在管控代码的复杂程度问题上，我们也会做一些工作。这就是我们不会将所有的代码都写入一个方法中的原因。我们会将自己的代码分解为方法、函数、变量、类以及其他结构，从而简化代码。</p></li><li><p>不管编程问题有多难，它总是可以被分解为更小的单元。如果你想要写出一个难度很大的算法，在一头扎进去写代码之前，先把这个问题分解为能够依次独立解决的小模块会更有帮助。无论应用程序多么庞大、多么复杂，它都可以被分解成一行行的代码。单独一行代码的复杂度绝对不会超过任何一位程序员的理解能力和编码水平，所以，如果你愿意将问题分解得足够小，只凭借写出单行代码的能力你就能写好任何应用程序。</p></li></ul><h3 id="努力工作的价值"><a href="#努力工作的价值" class="headerlink" title="努力工作的价值"></a>努力工作的价值</h3><ul><li><p>现实的情况是，一切有价值的东西无一不是努力工作的结果。生活中，特别是在软件开发的职业生涯中，如果你想看到成果，你就必须要学会坐下来，做好自己并不想做的工作——并且要坚持不懈。</p></li><li><p>如果真想富有成效，你就不得不学会工作的时候既聪明又努力。光有聪明是不够的。一定量的机智是必须具备的，然而要想获得真正的成功，面对挫折的时候一定量的毅力也是必要的。</p></li><li><p>努力工作总是枯燥的如果我必须猜测一下，为什么我们逃避艰苦的工作，我会说这是因为它们太枯燥了。在我刚开始写博客的时候，我很兴奋。我对这个表达自己的机会充满热情。然而，随着时间的推移，它变成了一项苦差事。如果我没有学会坚持，设法应对这项单调乏味的苦差事，我就不可能看到自己的行动的好处。</p></li><li><p>你必须认识到，你要想实现目标，要想发挥出自己的全部潜力，唯一的途径就是自愿咬紧牙关、硬着头皮、开始工作</p></li><li><p>你曾经投身到哪些艰苦的工作中？有哪些任务你会因为不喜欢而拖延？找出其中一项任务，毫不犹豫地马上去做。养成雷厉风行的习惯，并且立即在需要做的工作中付诸行动。</p></li></ul><h3 id="任何行动都比不采取行动好"><a href="#任何行动都比不采取行动好" class="headerlink" title="任何行动都比不采取行动好"></a>任何行动都比不采取行动好</h3><ul><li><p>任何行动往往都比没有行动好，特别是当你一直停滞在不愉快的情势下很长时间的时候。如果这是一个错误，至少你学到了一些东西。这样一来，它就不再是一个错误。如果你仍然选择停滞不前，那么你就学不到任何东西。</p></li><li><p>很少有人会后悔自己基于所掌握的最好的知识采取的行动，但是很多人会后悔自己没有采取行动。他们错失机会，只因为过分害羞、谨慎或者犹豫，让他们裹足不前，无所作为。</p></li><li><p>很多时候，你需要试错好多次之后才能找出正确的行动方向。在任何行动上耽误的时间越长，完成整个试错过程找出正确方向的用时也就越长。</p></li><li><p>大多数我们急于做出的选择往往都是微不足道的。我们经常试图耗费300%的努力寻找95分的解决方案，而不是满足于找到90分的解决方案。我们的生活就是这样的，我们写代码的时候也是这样的，我们甚至在决策该买什么样的电视机时也是这样的。</p></li><li><p>即使是一些看似重要的选择——改变生活的那种，用随机掷骰子的方式都比优柔寡断、无所作为要好。很多大学生认为，选择专业和选择职业都是非常重要的决定。尽管这一决定可能很重要，但也不会比其他选择更重要，有多少大学生毕业的时候只有华而不实的学位或者是泛泛而谈的专业正是因为他们没有做到当断则断呢？举棋不定、优柔寡断让他们丧失了采取行动的机会。</p></li><li><p>跑起来的汽车更容易转向</p></li><li><p>通常，要找出一个方向是错的，唯一的方法就是向着那个方向前进。如果错误的代价很小，有所作为总好过无所事事。</p></li><li><p>现在要怎么做那么，如何将上述原理现在就应用于你的生活呢？今天你要怎么采取行动？仔细查看表48-1所示的简单的检查表，看看它是否能帮你下定决心采取行动。</p></li><li><p>表48-1 采取行动时的检查表</p></li></ul><p><img src="/2023/03/02/20230302-%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-notes/%E9%87%87%E5%8F%96%E8%A1%8C%E5%8A%A8%E7%9A%84%E6%A3%80%E6%9F%A5%E8%A1%A8.jpg"></p><h1 id="第五篇-理财"><a href="#第五篇-理财" class="headerlink" title="第五篇 理财"></a>第五篇 理财</h1><ul><li><p>金钱只是一种工具。它会带你去往任何你想去的地方，但不会取代你成为司机。<br> ——爱思·然德（Ayn Rand）</p></li><li><p>即使你对此心存疑问，我也鼓励你认真思考一下：改变财务状况会如何显著地改变你的生活，改变你在职业生涯中所做的决定。</p></li><li><p>所谓资产，是指实用价值高于维护成本的东西。也就意味着，一样东西如果有资格被定义为“资产”，必须能够带来比自身成本更高的价值。</p></li><li><p>但是，负债的含义则恰恰相反。所谓负债，是指成本高于带来的价值的东西。也就是说，要保有“负债”，你不得不往外掏钱，但是你永远也拿不回来与自己掏出的钱一样多的钱。</p></li><li><p>关于资产，一个清晰的例子就是你持有的每个季度派发一次红利的股票。持有股票并不会花你分文，但是只要一直持有，每3个月它就会给你带来一次收入。股票自身的价格会上涨也可能会下跌，但是按照我的定义，只要它能带来红利，它就是资产。</p></li><li><p>某些东西你买来后能够给你带来产出，或者产生的价值会高于你最初的投资，而别的东西则会消耗你的收入，或者不值你为它花的钱。</p></li><li><p>如果想在财务上获得成功，就必须学会如何投资，别无选择。</p></li></ul><h3 id="薪酬谈判"><a href="#薪酬谈判" class="headerlink" title="薪酬谈判"></a>薪酬谈判</h3><ul><li><p>我强烈建议软件开发人员打造个人品牌，并积极地营销自己。</p></li><li><p>为了做到这一点，基本策略就是尽可能让自己的名字出现在各种的媒体上。写博客、做播客、写书或文章、在大会或用户组中发表演讲、制作视频教程、为开源项目贡献代码等，尽一切可能让自己的名字出现在各种场合。</p></li><li><p>获得工作的方式至关重要</p></li><li><p>第一种，你看到一份招聘启事，然后发送自己的简历去申请该职位，最好再附上一封优美的求职信。事实上，许多求职者想当然地认为这是获得工作的唯一方式。其实，这是获得工作最糟糕的一种方式。如果以这种方式获得一份工作，很难在薪酬谈判时占据有利地位，因为和雇主比起来，你处于明显的弱势。你是竭尽所能渴望求得那份工作的人。</p></li><li><p>需求最大的人在任何谈判中通常都会处于劣势。</p></li><li><p>获得工作的另一种方法是通过他人推荐。</p></li><li><p>你认识一家公司里的某个人，他们亲自推荐你应聘某个职位，最终你获得了这份工作。这种方式绝对要比自己申请职位好很多。</p></li><li><p>你的最佳状态就是：一家公司知道你，然后无需任何面试就直接为你提供一个职位。在这种情况下，你尽可以根据自己的声望为自己标价。所以，任何时候，只要有雇主直接找你，你在谈判时就拥有有利地位。</p></li><li><p>先出价者输</p></li><li><p>你必须要了解的一条重要法则就是：先出价的人会处于明显的劣势。</p></li><li><p>然而也有例外，唯一的例外会出现在雇主刻意压低价钱的时候。这种情况是非常罕见的，但是，如果你有充分的理由怀疑这种情况会发生，你可能会想先出价来设定个保底数。为什么？因为如果雇主给你的出价极低，你很难让他把价格抬高很多。当然，在这种情况下，无论你做什么，都不大可能成功。</p></li><li><p>被要求先出价该怎么办千万不要先出价。直接说“不”。</p></li></ul><h3 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h3><ul><li><p>期权背后的基本思想就是允许某人为在未来的某个日期买入或卖出股票的权利付费</p></li><li><p>期权从根本上说就是赋予你在未来某个日期之前以固定价格购买一定数量股票的选择权。</p></li><li><p>但你也可以购买另一种让自己在未来某个日期之前以固定价格出售一定数量股票的选择权。这种期权能让你在股价下跌的时候也赚钱，与附录B中讨论的卖空股票类似。</p></li><li><p>允许在未来一段时间内以固定价格购买股票的期权被称为“看涨期权”，允许在未来一段时间内以固定价格出售股票的期权被称为“看跌期权”。</p></li></ul><h3 id="房地产"><a href="#房地产" class="headerlink" title="房地产"></a>房地产</h3><ul><li><p>在所有个人可以做的投资中，我认为房地产投资是目前为止最好的。再没有其他投资方式像房地产一样能够保障长期收益，能够允许如此高的资本负债。</p></li><li><p>尽管房地产价格可能会大幅波动，但是我建议投资的是可租赁房产。这种房产的稳定的收入就是——租金。</p></li><li><p>你选中的这处房产属于我们所说的“以租养贷”，意思是说所有费用，包括抵押贷款、税费和保险，都由它产生的租金收入来提供保障。在这种情况下，我们假设租金能够支付全部费用，不会有多余的现金流，或现金流很少。</p></li><li><p>聪明的房地产投资（不是投机）始于认识到房地产投资是一项长期投资。如果你相信自己可以通过倒卖房产或者低价购买抵押房产而快速致富，那你终究会自食恶果。</p></li><li><p>好的物业管理公司将会管理与物业出租有关的一切事务，包括寻找租户、确定租约、筛选租户、维修保养以及收取房租等。但是找到一家好的物业管理公司是很困难的。你要货比三家，找最诚信的物业管理公司。我因为能力不足、维修费用造假和玩忽职守等问题，至少解雇了三家物业管理公司。</p></li></ul><h3 id="退休计划"><a href="#退休计划" class="headerlink" title="退休计划"></a>退休计划</h3><ul><li><p>事实是，在热带海滩上度过退休生活并非理所当然，也不只是60岁以上人群的专利。</p></li><li><p>事实上，如果你希望乐享退休生活，你必须开始为此做一些计划，并且从现在就开始计划。</p></li><li><p>一旦算出自己退休以后每个月的生活开销是多少，当你的“被动收入”达到每月所需的生活开销的时候，你就可以正式退休了。</p></li><li><p>所谓被动收入，就是不用工作就能获得的收入。你必须确保被动收入会随着通货膨胀而增加——这也是说房地产是一个很好的投资选择的主要原因。</p></li></ul><h3 id="债务危害"><a href="#债务危害" class="headerlink" title="债务危害"></a>债务危害</h3><ul><li><p>真正获得财务成功的唯一方法就是用钱生钱。</p></li><li><p>采取行动<br>列出你的所有债务的清单，把它们区分为两类：好的债务和不好的债务。<br>把不好的债务按照利率从高到低排序，计算一下多久你可以清偿所有的债务。</p></li></ul><h3 id="额外馈赠"><a href="#额外馈赠" class="headerlink" title="额外馈赠"></a>额外馈赠</h3><ul><li><p>相反，我把退休定义为“自由”，具体而言，即财务自由——一种不会囿于财务状况被迫用自己别无选择的方式将自己的时间花费在不合心意的事情上的能力。</p></li><li><p>我从不追求永远不再工作，但是我一直追求在我不想工作的时候就不工作。这就是我目前的状态。我有足够丰厚的“被动收入”去对抗通货膨胀，如果我愿意，我也可以躺在沙滩上来一杯鸡尾酒；但是，我依然可以投身自己感兴趣的项目——那只是因为我想投身于该项目，而不是因财务原因必须投身于该项目。</p></li><li><p>我的观点是，运气是必要的。我不会假装自己从来没得到幸运女神的眷顾，但在一定程度上，是你给自己创造运气。如果你脚踏实地、努力工作，总是尝试提升自己和周围的人，那你获得好运气的可能性会大大增加。等式的最后一部分是努力工作。Pluralsight的很多作者也有着和我一样的机遇。我不是说他们不努力，只是我更积极、更努力，我是Pluralsight课程库中课程最多的作者。为了让自己梦想成真，我静下心来工作到很晚，周末也不例外。</p></li><li><p>仅仅获得机遇是不够的——即便这一机会千载难逢。你必须充分利用机遇，否则再好的机遇也没用。</p></li></ul><h1 id="第六篇-健身"><a href="#第六篇-健身" class="headerlink" title="第六篇 健身"></a>第六篇 健身</h1><ul><li><p>如果你不注意自己的身体健康，老实说我并不看好你能成为顶尖的程序员。</p></li><li><p>在很长一段时间内，我都认为，在软件开发人群中教育和普及体育健身方面的知识是非常迫切的需要。在我刚开始从事编程工作时，软件开发人员的典型形象就是一个书呆子，瘦骨嶙峋，戴着一副厚厚的眼镜，活脱一付笔尖保护套的模样。现在，这一形象似乎已经改变，不过是变得更糟了。如今，很多人认为，软件开发人员都是胖胖的男士，留着络腮胡子，穿着一件脏兮兮的白色T恤还吃着比萨。</p></li><li><p>显然这两种刻板形象都是错的——有很多软件开发人员，不管是男性还是女性，都不是这种形象，但是第二种形象比第一种形象更让我害怕，因为我觉得有些开发人员已经开始认为自己应该就是那样的。本篇的目的是让你了解健身的基础知识，鼓励你打破成见，并且让你认识到，身为软件开发人员并不意味着男的不能健康，不能英俊潇洒，女的不能光彩照人。你同样可以保持好身材，可以拥有健康，但一切都始于正确的教育和坚定的信念——相信这些都是可能的。</p></li></ul><h3 id="破解自身健康密码"><a href="#破解自身健康密码" class="headerlink" title="破解自身健康密码"></a>破解自身健康密码</h3><ul><li><p>健身不仅是保持健康体魄的关键要素之一，也是灵活的、具有创造性的脑力活动的基础。——约翰·肯尼迪</p></li><li><p>健身能让你成为更好的软件开发人员。这就是原因。</p></li><li><p>自信心</p></li><li><p>从我的个人经验出发，我可以告诉你，我锻炼得越多就越健康，我在工作中的表现也越好。我注意到，当我体能最好的时候，我的注意力最集中，效率也最高。</p></li><li><p>当你总觉得疲倦、无心工作的时候，或者你觉得自己状态不佳的时候，你可能会发现，改变饮食和加强锻炼可以让你的身心同时获得新活力。</p></li><li><p>恐惧我不想马上打出恐惧牌，但我认为它仍然是如此重要，值得一提。如果你体重超标、处于亚健康状态，那你罹患各种可预防性疾病的风险就很高。</p></li><li><p>不要让自己醒悟得太晚，从现在起就认真对待。不要等到出了健康问题才开始关心自己的健康。</p></li></ul><h3 id="设定健身标准"><a href="#设定健身标准" class="headerlink" title="设定健身标准"></a>设定健身标准</h3><ul><li><p>没有目标，你永远也达不成目标，健身也不例外。正如你需要知道自己写的代码是用来做什么的一样，你也需要知道在忍饥挨饿、挥汗如雨之后，你要得到怎样的结果，否则你就是在浪费时间。</p></li><li><p>挑选一个具体的目标</p><ul><li>减肥</li><li>增肌</li></ul></li><li><p>这些应用还可以帮你找到举重或者跑步的同伴，甚至能让你开始新的节食计划，或者向朋友发起挑战。与他人交流，分享自己的经验，不论好坏，都能让你的健身之旅更乐趣无穷，并能让你持久保持动力。我发现，当我有一个举重同伴的时候我总是更勤快地跑去健身房。</p></li><li><p>计划了就一定要执行如果你能让自己持久保持动力，这确实很棒。但是，有时候不论有没有动力，你都得咬紧牙关坚持计划。一定要提前做好决定，这能给你约束，让你致力于自己想要采取的一系列行动。</p></li><li><p>试着通过提前计划，尽可能减少生活中的各种抉择。</p></li><li><p>当你的动力消失殆尽的时候，用原则来代替激励。每当我精疲力竭不想再跑步的时候，我都会用自己高度尊崇的“善始善终”原则提醒自己。为自己的人生创建一组格言，在世事艰难的时刻信守这些格言。</p></li><li><p>人生格言<br>善始善终。<br>成功者决不放弃，而放弃者永远不会成功。<br>一分耕耘，一分收获。<br>时间短暂，如果想在生命中做某件事，现在就去做。<br>一切都会过去。<br>坚持到底就是胜利。采取行动<br>列出你要健身或改善健康状况的原因。<br>从这份清单中，明确三项最重要的激励因素，打印出来并张贴在不同的地方，确保自己每天都能看到。</p></li></ul><h3 id="如何增长肌肉"><a href="#如何增长肌肉" class="headerlink" title="如何增长肌肉"></a>如何增长肌肉</h3><h3 id="如何获得腹肌"><a href="#如何获得腹肌" class="headerlink" title="如何获得腹肌"></a>如何获得腹肌</h3><h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><h3 id="站立办公"><a href="#站立办公" class="headerlink" title="站立办公"></a>站立办公</h3><h3 id="高科技健身装备"><a href="#高科技健身装备" class="headerlink" title="高科技健身装备"></a>高科技健身装备</h3><ul><li><p>本章介绍的都是能帮助你实现健身目标的或者能让你的健身过程更充满乐趣的科技装备。我们已经进入了全新的时代，当下我们比以往任何时候都更了解自己，了解自己身体的运转规律。这种自我认知也被称为“量化自我”。在本章中，我会带领你领略各种技术，并从中选出一些最有用的装本来帮你“量化自我”。</p></li><li><p>步行计数器和计步器我觉得从步行计数器和计步器开始说起可能比较合适，因为它们是你现在能看到的最常见的科技装备。我是拥有某种计步器的超级粉丝，因为它不仅能帮你明确自己的实际运动量是多少，还能通过了解你的运动量来改变你的行为习惯，从而让你更有活力。</p></li><li><p>它不仅能记录我的体重，还能记录我的体脂率。尽管体脂率读数的精确性有待商榷，但我更关心的是读数是如何随时间变化而变化的。尽管可能我获得的数据不够精确，但我能够看到相对变化，了解自己的体脂率是在升高还是降低。</p></li><li><p>我强烈推荐我正在用的这款体重计，因为它能让你更好地了解自己的当前体重和变化趋势。有人说有了测量才能改进。即使你每天都站在体重计上，但只有看到体重随着时间的变化曲线时，你才会真正受到触动，向着正确的方向前进。</p></li><li><p>组合设备健身科技最令人兴奋的领域莫过于组合设备了，尽管目前尚不成熟，但正被逐渐推广。这些组合设备能够通过各种传感器测量多个数据点，为你提供大量关于你的身体的信息。</p></li><li><p>耳机在我锻炼的时候，最重要的技术装备就是耳机。我经常在锻炼的时候听播客或有声书，因此我需要一副可以插入手机的好耳机。</p></li><li><p>应用我们也别忘了应用。市面上有大量针对各种锻炼目的的健身应用。</p></li></ul><h1 id="第七篇-精神"><a href="#第七篇-精神" class="headerlink" title="第七篇 精神"></a>第七篇 精神</h1><ul><li><p>精神如果你不征服自己，你就会被自己征服。——拿破仑•希尔</p></li><li><p>我们不只是一个与思想相连的躯壳。我们不能只下达指示然后就期望身体能完成执行这些指令。这个世界存在着另一股很强大的力量，它能带领我们走上成功之路，把我们推向成功。你可以按照自己的意愿随意称呼这种力量，但是为了本书的目的，我称之为精神。</p></li><li><p>我的目标是用工具武装你，征服你所面对的最强大的敌人——你自己。</p></li></ul><h3 id="心灵如何影响身体"><a href="#心灵如何影响身体" class="headerlink" title="心灵如何影响身体"></a>心灵如何影响身体</h3><ul><li><p>从心灵开始如果你不相信自己能够做到，你几乎做不成任何事情。你的思想对身体的影响有多大、对你能够获得成功的影响有多大，这是令人惊叹的。“如果你相信，你就能做到”这个观点很容易被迅速忽视，但是这个观点确实有些道理。至少，这个观点的反面更有道理：如果你不相信，你肯定不会获得成功。</p></li><li><p>那些想要改变自己信念、控制自己想法的人们，通过积极的正念可以将其想要的变为现实。</p></li><li><p>信念决定思想，思想决定言语，言语决定行动，行动决定习惯，习惯决定价值，价值决定命运。——圣雄甘地</p></li><li><p>不管这个机制是如何运转的，重要的是你要理解自己的所思所想影响并塑造了你现在的生活。你甚至不用读这一章就可以证明这一点。看看周围就知道了。</p></li><li><p>如果你真的想为自己的生活定好方向并控制好它，那你就要学会如何利用心灵的力量、思想的力量。</p></li><li><p>采取行动<br>找出心灵和身体之间的联系。试着在你自己的生活中找一个例子，什么样的想法给现实带来了积极的影响，什么样的想法又给现实带来了消极的影响？<br>你最近一次取得巨大成功的时候心态是什么样的？<br>你最近一次遭遇重大挫败的时候心态是什么样的？</p></li></ul><h3 id="拥有正确的心态"><a href="#拥有正确的心态" class="headerlink" title="拥有正确的心态"></a>拥有正确的心态</h3><ul><li><p>让我问你一个问题：你将自己的想法归类为积极的还是消极的？这可不是给你自己贴上乐观主义者或悲观主义者的标签。有很多的乐观主义者，他们在表面上满怀期望和希望，但内心却怀着各种会直接破坏他们的工作成果的负面想法和情绪。实际上，积极思考的观点有科学证据可以支撑——积极思考不只是外表乐观，而且还对健康有益，能延年益寿，并且给你的生活提供其他的好处。同时——或许是更重要的——反过来想，消极的思考会产生完全相反的效果。消极思考会对你产生实质伤害，而且会妨碍你通向成功的人生.</p></li><li><p>积极思考与现实主义是不矛盾的。事实上，积极思考在应用层面上是现实主义的最终体现，因为它是一种信念，这种信念让你有力量改变现实，让你确信你不是环境的受害者。</p></li><li><p>积极思考问题的根源是这样一种信念——你比你随处的环境更伟大。这种信念让你总能先看到事物好的一面，因为无论身处何种环境，你都有能力改变自己的未来。这是人类成就的最高信念，是世界上最强大的力量。这种信念能让你利用这种力量，这股力量就静静地躺在你的心田，却又不那么虚无缥缈。</p></li><li><p>积极的心态就是来自于这些想法的积累，随着时间的推移这些想法会由内向外地彻底改变你。当你拥有一个积极态度的时候，你就不是活在与现实分离的虚幻世界里，而是生活在一个最理想的世界里，一个你能看到的最理想的未来世界，一个你一直以来都在苦苦追求并努力实现的未来世界。</p></li><li><p>从更现实的层面来讲，积极思考就是选择从好的一面（而不是从坏的一面）去思考问题。你对生活中遇到的每一种状况都可以有自己的理解。这些状况本身并不存在“好”或者“坏”。是你自己来解释这些状况，所以是你决定它是“好”的还是“坏”的。一个持有积极心态的人看到的好的一面往往比坏的一面要多，并不是因为这些状况客观上就是好的，而是因为他们认识到他们有选择的权利。</p></li><li><p>积极性的正面作用记得当我说有真实存在的科学证据证明积极思考会对你的生活产生影响吗？我不是在开玩笑。这里有一份被证实效果的清单，这些效果都是由积极思考产生的。这些结果来自实际的科学研究：<br>发展友谊；<br>婚姻美满；<br>收入更高；<br>身体更健康；<br>延年益寿。</p></li><li><p>我知道的一个事实是，我的工作态度会直接影响我的工作表现。关于这一点，我是用自己的工作效率来做的度量。我知道，当我保持一个积极的态度时我就更愿意去面对任何障碍，把挑战看成要克服的困难，而不是消极地认为是环境把我逼到了绝境。</p></li><li><p>如何养成积极思考的习惯呢？大多数情况下，使用养成其他任何习惯的方法就能养成这个习惯——通过坚定地、持续不断地、有意识地重复做一件事情，直到由潜意识来掌握大局。</p></li><li><p>劳逸结合<br>我个人可以追踪我的许多负面情绪与我忘记休息之间的关联关系。我发现当我花时间休息后更容易保持积极心态。可能这种方法没什么大不了，但是还是值得参考。</p></li><li><p>一些帮助你养成一个积极心态的好书。如果你现在就想找到相关的书，试着看看由Norman Vincent Peale写的《积极思考就是力量》（The Power of Positive Thinking）［Touchstone，2003再版］。关键是积极思考不会从天而降，也不是一夜间就能获得的，你要付出持续的努力，将思想转向积极的方向。但这是值得付出的努力。不单是因为积极思考能让你活得更长久、更健康、更成功，还因为这绝对会让你活得更有乐趣，同时你可能会影响你周围的人同样生活得越来越有乐趣。</p></li></ul><h3 id="构建一个积极的自我形象"><a href="#构建一个积极的自我形象" class="headerlink" title="构建一个积极的自我形象"></a>构建一个积极的自我形象</h3><ul><li><p>那些不能激励自己的人一定是甘于平庸的人，无论他们的其他才能有多么令人印象深刻。——Andrew Carnegie</p></li><li><p>自我形象是在甩掉别人对你的看法，摆脱所有用来自我安慰的谎言和欺骗以后，你看到的自己的样子。</p></li><li><p>对你的大脑“重新编程”如何有目的性地对你的大脑“重新编程”？如何像我当年那样改变自我形象？公式相当简单：只需要花点儿时间，再加上持之以恒地正确执行。一开始，设定一个你想成为的清晰形象。你的大脑有惊人的能力去寻找摆在它面前的任何目标。你只需要想象一下这些目标，直到这个目标足够清晰到让你的大脑能够带领你走向你需要走向的那条道路。</p></li><li><p>为你树立一个理想形象。在你的脑海中牢固地树立起一个形象——“这就是我想要成为的形象，没有什么能够阻止我”。想象一下你自己更坚定、更有自信地走进房间；想象一下你优雅地跳跃着、奔跑着，而不是将自己绊倒；想象一下你可以激励别人，可以非常时尚。不要给自己设定任何的人为限制，除非是那些你没有办法改变的身体特征（例如，不要把自己想象成个子很高，除非这么做能让你感到更自信。只是别指望这么想真的能让你长高。）一旦你在自己的脑海中设立了这样的形象，下来的任务就是开始执行“仿佛”模式。“仿佛”你已经变成了你想变成的那个人。无论是言行举止，还是穿着打扮，都像你想成为的那个人一样，甚至像你想成为的那个人一样刷牙。不要太关注现实是怎么样的，不要太在意别人如何议论你的“变化”；相反，假装你已经达到了你想要的目标，你的新行为只是这个新个性的自然延伸。你还要给自己很多正面的肯定，这会在你潜意识深处植下你的新思维模式的种子。事实证明，正面的肯定不是胡言乱语，你的大脑会真的开始相信你告诉它很多遍的东西。还记得我说过的改变信念是多么难的一件事吗？如果持续传递一致的信息给你的大脑，你就能改变自己的信念。</p></li><li><p>我建议用一句名言或者一个肖像提醒你，你理想中的那种精神状态。让每一天都充满正面的肯定，这样就能更加确认并加强你的新信念。花一些时间，在精神层面上虚构一个你想成为的那个自己。很多体育运动员就是利用这样的过程来提高自己的成绩的。在参加重大赛事之前，他们会在脑海中做一次彩排。</p></li></ul><h3 id="爱情与恋爱"><a href="#爱情与恋爱" class="headerlink" title="爱情与恋爱"></a>爱情与恋爱</h3><ul><li><p>总的来说，我们总想得到自己得不到的东西，我们总想得到别人也想得到的东西。所以，希望越大，失望越大，你就越不可能得到。</p></li><li><p>关键是你要真正表达出这个意思。你必须要对自己表现出足够的自信，你真的相信你不需要别人给你带来快乐。你必须要相信你和别人在一起是因为你能给对方的生活带来好处，当然这并不意味着你自认为你是上帝恩赐给别人的礼物……来填补空白，但这确实意味着你对自己足够尊重，你只出现在自己想去的地方，你只想和想和你在一起的人相处。</p></li><li><p>这并不意味着保证能成功，我无法保证。但是，如果你能明白大多数情侣关系其实是“你追我逃”的微妙心理游戏作用的结果，你就会更容易找到真爱。这不只适用于爱情问题，也适用于各种人与人之间的关系。做一个绝望的、缺乏自信的人，你可能会发现自己真的孤立无援。如果你发现你面试的对象就像大街上一个垂死挣扎的乞丐一样祈求你施舍给他工作岗位，你也会觉得他很惹人生厌。</p></li><li><p>太多人会犯这样的错误——挑选一个人，然后把他&#x2F;她当作理想人选放在神龛上，时刻想念着那个能让他们觉得“开心”的完美女生或者男生。假设只有这么一个完美的人，这种想法不但荒谬而且缺乏策略。如果扩大搜索范围，你的机会更好。</p></li><li><p>所以，请不要害怕失败，哪怕失败很多次；不要害怕被拒绝，没什么大不了的。最差的情况又能差到哪里？你可能就像去敲开一扇扇门的销售员，他们面对上百扇甩向他们的门，只为做成一笔交易。你要知道，你每天需要做的就是完成一笔交易。</p></li><li><p>除此之外，所有那些拒绝最终都会把你带到一个想和你在一起的人那里，这总比和不想和你在一起的人在一起要好很多。</p></li></ul><h3 id="私房成功书单"><a href="#私房成功书单" class="headerlink" title="私房成功书单"></a>私房成功书单</h3><ul><li><p>人性的弱点</p></li><li><p>让别人做你想做的事情的唯一方法就是让他们自己也想做这件事。</p></li><li><p>Napoleon Hill的《思考致富》（Think and Grow Rich）［Wilder Publications, 2007］</p></li><li><p>Robert Kiyosaki的《穷爸爸，富爸爸》（Rich Dad, Poor Dad）［Demco Media，2000］这是另外一本改变我生活的书，它改变了我对金钱和财富的看法。这本书改变了我对钱是如何运作的认识，改变了我对“拥有一份工作”以及“为别人工作意味着什么”的看法。读完这本书之后，我清楚地理解了建立资产和减少自己的开销有多么重要。</p></li></ul><h3 id="积极面对失败"><a href="#积极面对失败" class="headerlink" title="积极面对失败"></a>积极面对失败</h3><ul><li><p>跌倒七次，爬起来八次。——日本谚语</p></li><li><p>为什么我们总是害怕失败畏惧失败似乎是大多数人的本能。人都喜欢做自己擅长的事情，逃避做那些自己不能胜任的或是缺乏技能的事情。我们似乎与生俱来就畏惧失败。</p></li><li><p>如果非要我猜猜为什么大多数人如此害怕失败，我不得不说这可能是基于保护脆弱的自尊的想法。或许我们害怕失败就是因为我们太过将失败归咎于个人，我们认为在特定领域下的失败是个人价值的流逝。</p></li><li><p>我认为，对“失败”性质的误解还会助长这种对个人价值伤害的恐惧感。</p></li><li><p>即使我们知道失败并不是终点，我们似乎也能感受到这一点。我们往往太过较真，把失败看得太重。因为我们接受过把失败看作通往成功道路——很多情况下这也是唯一的一条道路——的训练，所以我们不惜任何代价地避免失败。</p></li><li><p>失败并不是被打败</p></li><li><p>失败不同于被打败。失败是暂时的，被打败是永恒的。失败是那些碰巧发生在你身上的——你不能完全控制它。被打败却是你可以选择的——是对失败的某种程度的接受。</p></li><li><p>要实现不畏惧失败，第一步就是真正意识到失败不是终点——除非你选择把它看作是终点。生活不易，你随时都会被击垮，但是否要重新站起来却完全取决于你自己。它取决于你是否决定为自己最值得拥有的东西战斗，取决于你是否要享受获得成功后的喜悦和乐趣，大多数情况下，它来自于战胜困难的成就感。</p></li><li><p>如果在第一次受挫败被打死的时候你就扔掉了控制器，会发生什么？某种程度上，从很多次失败中获得的经验反而让你最终获得了成功的体验，这是不是更令你乐在其中？如果是这样，你为什么要把失败当作是一种永恒的状态而逃避生活中的失败呢？你不能指望拿起电玩遥控器，不经历掉下陷阱或者被火球烧焦就能通关，那么你为什么要指望一生不经历失败呢？</p></li><li><p>失败是通往成功的必经之路不要畏惧失败，要拥抱失败。不只是因为失败和被打败不同，还因为失败是通往成功的必经之路。生活中所有值得拥有、值得去完成的事情都需要经历失败。问题是，我们学到的都是用负面的视角去看待失败。上学的时候，作业得了F，这被看为退步。没有人教你要把这个失败看作能让你离自己的目标越来越近的学习经验，你反而会被告知这整个都是负面的事情。现实生活不是那样的。我不是说你不应该为了考试而学习，也不是说为了获得学习经验和塑造个性而一定要努力考一个F，我想说的是，在现实生活中失败通常是必要的里程碑，它能带领我们离成功越来越近。在现实世界里，当你在某件事上失败的时候，你从中学到了经验并且有可能成长。我们的大脑就是被这样训练的。如果你曾经试过学习如何玩杂耍，或者打篮球，或者其他需要相互配合的体育活动，你会知道在成功前会失败很多次。</p></li><li><p>学会拥抱失败重申一遍，我必须要说，即使你在本书中什么都没有学到，那也要记下下面这条建议：学会拥抱失败、期待失败、接受失败，并准备直面失败。只是不畏惧失败还不够，还要主动寻觅失败。想成长就必须把自己放在保证会失败的环境中。我们常常会因为停止做那些对我们有挑战或者危险的事情而停滞不前。我们寻找生活中的温室，关上小屋的门，拉上窗户，任凭外面狂风暴雨，我们绝不冲到雨中。但是，有时候你需要被淋湿，有时候你需要把自己放到一个不舒服的环境下强迫自己成长，有时候你需要积极地走出去寻找这样的环境，要知道，你越将你的船驶向失败，将你吹向失败的另外一面（成功）的风就会越强。要如何拥抱失败？要如何说服自己跳入波涛汹涌的大海？从接受失败是生活的一部分开始。你必须明白，在生活中你要面对很多失败，很多是不可避免的，任何事情第一次做都不可能做到完美，你会犯错。你还要明白，就算失败也没关系。犯错也没关系。你可以尝试避免犯错，但是不要因为害怕伤害自尊而以付出错失良机为代价。一旦你意识到失败是好事，失败并不能定义你的价值而你对待失败的态度恰恰才能说明你的价值，你才会真正学会对失败无所畏惧。最后，我还是要建议你将自己暴露在失败的环境里。去做那些让你不舒服的事情。在本书的前面我们讨论过不要害怕看起来像个傻瓜，对待失败我也要说一样的话。事实上，这两个观点是紧密相连的。走出去，有目的地去把自己放在那些不可避免地会导致某种失败的困境中。但关键是不要放弃——让失败点亮通往成功的道路。去经历尽可能多的失败吧，畏惧失败本身才会让你失去克服困难的能力。</p></li><li><p>我要留给你最后一句关于失败的话，摘自Napoleon Hill的《思考致富》一书：“大多数伟大的人取得的最大成功与他们所经历的最大失败只有一步之遥。”</p></li><li><p>采取行动<br>对失败的恐惧是如何让你退缩的？想想生活中那些你想做但由于一时犹豫或者自尊受损而没有做的事情。<br>承诺至少做一件因为害怕失败而一直回避的事情。不要敷衍了事。很多人明知道有些事会失败还去“尝试”，这样做不会让他们真正失败，因为“没有真正尝试过”才会是失败。真的去尝试，真的去体验失败吧。</p></li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><ul><li><p>好吧，就到这里吧。我们终于来到了这本书的结尾。之所以说“我们”，是因为我希望你把读这本书当作是跟我写这本书一样的冒险旅程。当我开始动手写这本书的时候，我并不知道写一本这么长、这么厚的书这么难。我只知道我想要写一本书，分享我在自己作为软件开发人员的职业生涯中已经学到的一些重要的经验和教训——并不是关于如何编写优质代码、推动职业生涯上进的经验，而是关于如何做好更全面的人的经验，以及如何把我的人生价值发挥到最大同时又有利于他人的经验。我不是天才。我甚至都不是一位能够在反思他几十年的生活经验之后给你可以受益50年的智慧的长者，所以不要把我的这本书当作福音。这本书就是我的经验以及到目前为止让我获得成功的关键要素的分享。希望你能从中找到一些有用的东西，即便你可能不同意书中的所有观点——那也没关系。这正是这本书的要点。你不能把别人说的话都当作福音。没有人可以垄断真理。现实中，很大程度上，正是你自己发现了真理。这并不意味着你可以忽视这世界上的公认真理、只管自行其是，但这意味着你可以决定你想要过怎样的生活，你该怎样去生活。如果你能学会管理诸如成功、理财、健身以及自己的心理状态等事务的基本原则，你就可以利用这些原则来塑造你自己的现实世界。希望在读完这本书之后，你已经得出结论：那些你过去已经被告知的关于“你该如何生活”的狭窄的、笔直的道路，如你要取得好成绩、尽量不要搞砸了、上大学、找份工作然后安心工作50多年直到退休吧……并不是你可以走下去的唯一道路。当然，你也可以继续沿着过去被告知的那条道路前进，只要你愿意；不过，如果你正在读这本书，我相信你已经意识到，生活原本要比你所厌恶的朝九晚五的工作丰富多彩得多。希望这本书已经让你意识到，全世界都是你的机会，都在你的掌控之下。你可以更好地管理自己的职业生涯，可以从中获益更多，甚至可以把自己的职业生涯带向全新的方向，可以学会实际构建自己的个人品牌、营销自己——把自己的软件开发职业生涯提升到一个认为不可能达到的全新高度，让自己有机会影响更多的人。希望这本书教会了你学习和吸收信息的新方法，给了你足够的信心去超越自我——不只是为了学到东西而去学习，还要把你学到的知识与他人分享、使他人受益，不管你是沿着哪条路径前进。希望这本书能够激励你更有成效，更谨慎地管理和善用你的时间，并且能够激励你看到努力工作的价值，并付诸于实践——即使是在你觉得缺乏动力继续前行的时候。希望这本书能激励你以某种方式去健身，更好地照顾自己的身体健康，使你意识到实际上你也可以保持身材，并不因为你是软件开发人员就不能成为健壮的、运动型的人，只要你愿意，你至少可以主动控制自己的健康。最后，我希望这本书已经帮你意识到意志力是多么强大、多么重要，你的头脑可以作为一种工具，要么推动你前进，要么在你来不及做出反应、来不及应用自己所学的时候就摧毁你的前程。我希望这本书可以让你意识到你有能力成为你想成为的人，你也可以通过积极思考和坚持到底的力量重新塑造自己。</p></li><li><p>是的，这些都是任何一本书都向往的崇高目标，尤其是一本与软件开发有关的书。不过，只要我能在一些很小的地方帮到你，让你改善了自己的生活哪怕一点点，我都会认为这是一场胜利。在你放下这本书之前，我有一个小小的请求：如果你发现这本书对自己有帮助，如果你认为其他人也可能会从中受益，请把它分享给别人。我这么说不是为了提高这本书的销量——尽管我很愿意这么做，但是着手写这本书真不是为了赚钱——我花500小时可以做很多很多更有利可图的事情，写这本书只是因为我认为我们不仅应该不遗余力地做好一个软件开发人员，而且应该做好一个人：去帮助他人。感谢你抽出时间来阅读这本书，并真诚地希望你能在本书中发现一些永久的价值。John Sonmez，<a href="http://simpleprogrammer.com/">http://simpleprogrammer.com</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;献言&quot;&gt;&lt;a href=&quot;#献言&quot; class=&quot;headerlink&quot; title=&quot;献言&quot;&gt;&lt;/a&gt;献言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;谨以本书献给所有自强不息、孜孜不倦地持续自我改进的开发人员。他们具备下列素质： 永远不会对“不错”感到心满意足永远寻求每一个机会</summary>
      
    
    
    
    
    <category term="BOOK" scheme="http://yoursite.com/tags/BOOK/"/>
    
  </entry>
  
  <entry>
    <title>N年前的笔记备忘查阅</title>
    <link href="http://yoursite.com/2023/01/28/20230128-n%E5%B9%B4%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98%E6%9F%A5%E9%98%85/"/>
    <id>http://yoursite.com/2023/01/28/20230128-n%E5%B9%B4%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98%E6%9F%A5%E9%98%85/</id>
    <published>2023-01-28T04:22:40.000Z</published>
    <updated>2023-05-07T14:41:07.802Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/01/28/20230128-n%E5%B9%B4%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98%E6%9F%A5%E9%98%85/messi_ronaldo.jpg"></p><ul><li><a href="https://blog.csdn.net/kingson_wu/article/details/22665155">正则表达式和Matcher,Pattern的简单用法</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/38960559">如何在同一台电脑使用不同的账号提交到同一个github仓库</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/51175732">Spring源码阅读之数据自动绑定</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/51408032">Hessian跨语言调用实例</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/51953889">关于Java权限控制SecurityManager的理解</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/70217230">关于系统间数据一致性（跨进程事务）的解决方案</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/72512825">wireshark抓包简单查看HTTP keep-alive原理</a></li><li><a href="https://blog.csdn.net/kingson_wu/article/details/80102077">继续深入理解HTTP keepalive</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/01/28/20230128-n%E5%B9%B4%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98%E6%9F%A5%E9%98%85/messi_ronaldo.jpg&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>借《黑客与画家》记录一下想法</title>
    <link href="http://yoursite.com/2023/01/14/20230114-%E5%80%9F%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2023/01/14/20230114-%E5%80%9F%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%83%B3%E6%B3%95/</id>
    <published>2023-01-14T06:55:20.000Z</published>
    <updated>2023-05-07T14:41:07.802Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/01/14/20230114-%E5%80%9F%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%83%B3%E6%B3%95/messi2.jpg"></p><p>借本书记录自己的想法(从前混乱的头脑，没能及时总结)，阅读这本书有种相逢恨晚的感觉，有相似或者认同的想法.</p><blockquote><blockquote><p>“黑客精神”是这本书的核心理念所在。“黑客”本身具有各种各样的描述和象征意义。在不同场景下，人们对“黑客”的定义也不一样。在保罗的观念里，以及在YC和奇绩创坛的实践观察中，我们发现，黑客精神的真谛是动手去创造性地解决问题。“解决问题”必须跟人的需求有关，需要持久地满足越来越多人的需求。“动手”需要有勇气，很务实，以行动为导向，除此以外，黑客还必须是一个积极向上的人。“创造性”则意味着不受束缚、敢于探索。此外，黑客精神还意味着独立思考，坚持说真话。“动手去创造性地解决问题”代表了创造者一系列的核心行为和思想状态。这句话虽然听上去很简单，但它具有深刻含义，且完全反映了创造者的核心要素。</p></blockquote></blockquote><blockquote><blockquote><p>在本书中，“黑客”就是指最优秀的程序员，而不是入侵计算机系统的人。</p></blockquote></blockquote><blockquote><blockquote><p>作者想让公众了解，黑客并不神秘，更不是技术怪人。《黑客与画家》这个书名就是在提示应该把黑客与画家当作同一种人看待。和画家一样，黑客只是怀有一门特殊手艺、有创造天赋的普通人。这个书名还有另一层含义，即编程是一种艺术创作，黑客就是艺术家，开发软件与画家作画、雕塑家雕刻、建筑师设计房屋并没有本质不同。</p></blockquote></blockquote><ul><li>写通用的基础sdk就是一种艺术创作，封装，易用，优雅，安全，高效</li></ul><h2 id="第一部分-黑客如何成长及看待世界"><a href="#第一部分-黑客如何成长及看待世界" class="headerlink" title="第一部分 黑客如何成长及看待世界"></a>第一部分 黑客如何成长及看待世界</h2><h3 id="1为什么书呆子不受欢迎"><a href="#1为什么书呆子不受欢迎" class="headerlink" title="1为什么书呆子不受欢迎"></a>1为什么书呆子不受欢迎</h3><blockquote><blockquote><p>为什么黑客那么在乎言论自由？我认为，部分原因在于，革新对于软件行业实在是太重要了，而革新和异端实际上是同一件事。优秀的黑客养成了一种质疑一切的习惯。</p></blockquote></blockquote><ul><li>我很喜欢质疑, 有些理论上成立的东西, 如果直觉不认可, 我喜欢亲自去验证它。</li></ul><blockquote><blockquote><p>我认为，这就是问题的根源。“书呆子”的目标具有两重性。他们毫无疑问想让自己受欢迎，但是他们更愿意让自己聪明。</p></blockquote></blockquote><ul><li>很多事情并是只有0或1, 不是你不想要, 只是事情总有优先级</li><li>来自微信读书评论: 想和去做是两码事，没人不希望自己受欢迎，但聪明人有更重要的事要做。不在乎名利不见的有多聪明。</li><li>来自微信读书评论: 没有人喜欢孤独，怎么样才会受欢迎很多人都知道，只不过不想去做罢了。</li></ul><blockquote><blockquote><p>举例来说，大多数人似乎认为，绘画能力与生俱来，画家就像高个子一样，是天生的。事实上，大多数“会画”的人，本身就很喜欢画画，将许多时间投入其中，这就是他们擅长画画的原因。同样，受欢迎也不是天生的，而是需要你自己争取来的。</p></blockquote></blockquote><ul><li>之前投入的大量时间, 才让现在似乎得心应手。</li></ul><blockquote><blockquote><p>一般来说，成年人就不会去欺负书呆子。为什么小孩子会这样做呢？一个原因是，青少年在心理上还没有摆脱儿童状态，许多人会残忍地对待他人。他们折磨书呆子的原因就像拔掉一条蜘蛛腿一样，觉得很好玩。在一个人产生良知之前，折磨就是一种娱乐。</p></blockquote></blockquote><ul><li>确实,很多人小时候都这样,特别是男孩子,后天正确的引导很重要。</li></ul><blockquote><blockquote><p>没有什么比一个共同的敌人更能使得人们团结起来了。</p></blockquote></blockquote><ul><li>这提醒我有时要看清问题的本质以及别人的真正目的,避免被误导,毕竟希望自己是个聪明的人。</li></ul><blockquote><blockquote><p>如果我没记错的话，最受欢迎的孩子并不欺负书呆子，他们不需要靠踩在书呆子身上来垫高自己。大部分的欺负来自处于下一等级的学生，那些焦虑的中间层。</p></blockquote></blockquote><ul><li>确实, 人类社交属性的同时, 也会产生对比和嫉妒, 时刻提醒自己不做这种无意义的事</li></ul><blockquote><blockquote><p>没错，成年人不知道孩子们内部发生的事。认识到这一点很重要。在抽象意义上，成年人知道孩子的行为有时是极端残酷的，这正如我们在抽象意义上知道贫穷国家的人们生活极端艰难。但是，像所有人一样，成年人不喜欢揪住这种令人不快的事实不放。你不去埋头探寻，就不会发现具体的证据，就会永远以为这件事是抽象的。</p></blockquote></blockquote><ul><li>很多成年人都忘记自己小孩子时所经历的感觉, 表现出很不理解小孩子的行为, 并粗暴的归结为叛逆, 其实他们根本不想去了解和回忆, 觉得这浪费他们的精力, 毕竟他们还有很多“正经事”</li></ul><blockquote><blockquote><p>总体上看，我就读的学校与上面说的监狱差不多。校方最重视的事情，就是让学生待在自己应该待的位置。与此同时，让学生有东西吃，避免公然的暴力行为，接下来才是尝试教给学生一些东西。除此以外，校方并不愿意在学生身上多费心思。就像监狱的狱卒，老师们很大程度上对学生是放任自流的。结果，学生就像犯人一样，发展出了野蛮的内部文化。</p></blockquote></blockquote><ul><li>将心比心, 很多人都这样, 无可厚非, 毕竟大部分人工作仅仅为了维持生活的收入, 多一事不如少一事, 当然还是有很多伟大负责任的老师</li></ul><blockquote><blockquote><p>当你所做的事情能产生真实的效果，那就不仅仅是好玩而已了，发现正确的答案就开始变得重要了，这正是书呆子的优势所在。你马上就能联想到比尔·盖茨。他不善于社交是出了名的，但是他发现了正确的答案，至少从收入上看是如此。</p></blockquote></blockquote><ul><li>当你有影响力的时候, 别人才会高看你, 很现实但很真实</li></ul><blockquote><blockquote><p>至于学校，不过是这个虚假环境中关住“牲口”的围栏。表面上，学校的使命是教育儿童。事实上，学校的真正目的是把儿童都关在同一个地方，以便大人白天可以腾出手来把事情做完。我对这一点没有意见，在一个高度工业化的社会，对孩子不加管束，让他们四处乱跑，无疑是一场灾难。</p></blockquote></blockquote><ul><li>工作的束缚, 时常在想这是什么阴谋和圈套, 我们真的需要每天工作这么长的时间? 或者我们真的需要这样被限制性的工作? 太多的疑问了.</li></ul><blockquote><blockquote><p>这种看法无所不在，甚至孩子们自己都相信了，但是相信这种话可能一点帮助也没有。你告诉一个人，他的脚天生就是坏的，并不能阻止他去怀疑他可能穿错了鞋子。</p></blockquote></blockquote><ul><li>时刻记住, 逻辑的严谨: 充分必要条件, 控制变量法</li></ul><blockquote><blockquote><p>还有别的问题存在，甚至可能是更糟糕的问题。那就是我们没有得到真正的工作，没能发挥我们的才能。人类喜欢工作，在世界上大多数地方，你的工作就是你的身份证明。但是，我们那时做的所有事情根本就是无意义的，至少那时看来是这样。</p></blockquote></blockquote><blockquote><blockquote><p>而且，没有办法回避那些事情。成年人已经达成共识，认定通往大学的途径就是这样的。逃离这种空虚生活的唯一方法，就是向它屈服。</p></blockquote></blockquote><ul><li>读大学前学的很多知识, 很大概率是你下大半辈子没用的, 学习它仅仅是因为通向大学的筛选机制</li></ul><blockquote><blockquote><p>我们有一个专门的短语描述这种情况，即对于在没有任何严肃标准的前提下产生排名的情况，我们会说情况“倒退至人缘比赛”（degenerate into a popularity contest）。</p></blockquote></blockquote><ul><li>微信投票、升级加薪、绩效等</li></ul><blockquote><blockquote><p>没有外在的对手，孩子们就互相把对方当作对手</p></blockquote></blockquote><blockquote><blockquote><p>如果存在针对真正能力的外部测试，待在等级关系的底层也不会那么痛苦。球队的新人并不会怨恨老队员的球技，他希望有一天自己也能球技高超，所以很高兴有机会向老队员求教。老队员可能也会因此产生一种传帮带的光荣感（noblesse oblige）。最重要的是，老队员的地位是通过他们本身出色的能力获得的，而不是通过排挤他人获得的。</p></blockquote></blockquote><ul><li>共同的敌人? 共同的目标?</li></ul><blockquote><blockquote><p>我误解最深的一个词是“老成”（tact）。成年人使用这个词，含义似乎就是“闭上嘴巴，不要说话”。我以为它与“缄默”（tacit）和“不苟言笑”（taciturn）有着相同的词根，字面意思就是“安静”。我对自己发誓，我绝不要变成“老成”的人，没有人能够让我闭上嘴巴。可是事实上，这个词的词根与“触觉”（tactile）相同，它真正的意思是“熟练”。“老成”的反义词是“笨拙”（clumsy）。进入大学以后，我才搞明白了这个词。</p></blockquote></blockquote><ul><li>叛逆、愤青? 很多人根本不知道怎么解释, 抑或是自己被洗脑了, 懦弱, 只会站在道德制高点给你贴标签. 而我可能注定“叛逆”到死</li><li>来自微信读书评论: 许多人的所谓成熟，不过是被习俗磨去了棱角，变得世故而实际了。那不是成熟，而是精神的早衰和个性的夭亡。真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。  ——尼采</li></ul><blockquote><blockquote><p>校园生活的真正问题是空虚。除非成年人意识到这一点，否则无法解决这个问题。可能意识到这个问题的成年人，是那些读书时就是书呆子的人。</p></blockquote></blockquote><ul><li>作为一个“坏孩子”, 有时我很理解别人所认为的“坏孩子”的感受</li></ul><h3 id="2黑客与画家"><a href="#2黑客与画家" class="headerlink" title="2黑客与画家"></a>2黑客与画家</h3><blockquote><blockquote><p>黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师和作家一样，黑客和画家都试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）</p></blockquote></blockquote><ul><li>有时候, 写代码, 特别是对一些通用逻辑进行抽象的时候, 确实有种愉悦感, 甚至完成之后还会反复的欣赏自认为是优雅的设计</li></ul><blockquote><blockquote><p>我一直不喜欢“计算机科学”这个词，主要原因是根本不存在这种东西。</p></blockquote></blockquote><blockquote><blockquote><p>计算机科学就像一个大杂烩，由于某些历史意外，很多不相干的领域被强行拼装在一起。这个学科的一端是纯粹的数学家，他们自称“计算机科学家”，只是为了得到国防部研究局（DARPA）的项目资助。中间部分是计算机博物学家，研究各种专业性的题目，比如网络数据的路由算法。另一端则是黑客，只想写出有趣的软件，对于他们来说，计算机只是一种表达的媒介，就像建筑师手里的混凝土，或者画家手里的颜料。所以，在“计算机科学”的名下，数学家、物理学家和建筑师都不得不待在同一个系里。</p></blockquote></blockquote><ul><li>很多技术的实现就是那样, 但有些人总能包装成高大上的东西, 特别是在大公司. 我并不是批判这种行为, 相反我实际上有点羡慕这种能力.</li></ul><blockquote><blockquote><p>黑客搞懂“计算理论”（theory of computation）的必要性，与画家搞懂颜料化学成分的必要性差不多大。一般来说，在理论上，你需要知道如何计算“时间复杂度”和“空间复杂度”（time and space complexity）；如果你要写一个解析器，可能还需要知道状态机（state machine）的概念；除此以外，并不需要知道特别多的理论。这些可比画家必须记住的颜料成分少很多。我发现，黑客新想法的最佳来源，并非那些名字里有“计算机”三个字的理论领域，而是其他创作领域。与其到“计算理论”领域寻找创意，你还不如在绘画中寻找创意。</p></blockquote></blockquote><ul><li>就像现在IT行业盛行的八股文一样, 简直走火入魔. 我并不认为理论和原理并不重要, 但是跟清楚“颜料成分是多少”一样, 你很厉害, 但实际上大部分情况下对工作用处不大. 世界上的知识太多了, 这些细节没有人的全部掌握. 而知识的广度, 快速学习和搜索知识的能力, 对于程序员来说才是更重要的. 当然我能理解, 考核人员的无能以及巨大的岗位竞争, 产生了如今的现状.</li></ul><blockquote><blockquote><p>如果黑客认识到自己与其他创作者——比如作家和画家——是一类人，这种诱惑对他就不起作用。作家和画家没有“对数学家的妒忌”，他们认为自己在从事与数学完全不相关的事情。我认为，黑客也是如此。如果大学和实验室不允许黑客做他们想做的事情，那么适合黑客的地方可能就是企业。不幸的是，大多数企业也不允许黑客做他们想做的事情。大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。</p></blockquote></blockquote><ul><li>确实, 想任性的做自己的事, 可能是创业吧, 但是需求是什么?</li></ul><blockquote><blockquote><p>直到最近我才发现这一点。雅虎收购Viaweb的时候，他们问我想做什么。我对商业活动从来都没有太大兴趣，就回答说我想继续做黑客。等我来到雅虎以后，发现在他们看来，“黑客”的工作就是用软件实现某个功能，而不是设计软件。在那里，程序员被当作技工，职责就是将产品经理的“构想”（如果这个词是这么用的话）翻译成代码。这似乎是大公司的普遍情况。大公司这样安排的原因是降低结果的标准差。因为实际上只有很少一部分黑客懂得如何正确设计软件，公司的管理层很难正确识别到底应该把设计软件的任务交给谁，所以，大部分公司不把设计软件的职责交给一个优秀的黑客，而是交给一个委员会，黑客的作用仅仅是实现那个委员会的设计。</p></blockquote></blockquote><ol><li>很奇怪的现象, 很多大公司很喜欢全部员工一起开总结大会, 然后说员工需要提出自己的产品想法之类的. 实际上, 平常的工作中, 产品说了算, 甚至都不会听程序员的意见, 直接扔出一句“这是老板的需求”, 所以我一直认为开这种大会, 其实就是形式主义. 甚至开会的内容和现实对比, 可笑至极, 讽刺至极. </li><li>这样的产品, 把自己当成传话筒, 工具人, 直接躺平混日子了. 他们的目标只是满足老板的需求, 而不是用户的需求. 他们的目标只是保住工作混工资. 可是仔细想想, 很多人包括我自己, 又到达哪种境界呢? 可能大家其实半斤八两吧. </li><li>公司的目的是降低风险. 有时交给委员会, 实际上也是对普通员工的一种“保护”</li></ol><blockquote><blockquote><p>所有创作者都面临这个问题。价格是由供给和需求共同决定的。好玩的软件的需求量，比不上解决客户麻烦问题的软件的需求量；在小剧场里演出的酬劳，比不上穿着卡通大猩猩服装、在展览会上为厂商站台的酬劳；写小说的回报比不上写广告文案的回报；开发编程语言的收入，比不上把某些公司老掉牙的数据库连上服务器的收入。黑客如何才能做自己喜欢的事情？我认为这个问题的解决方法是一个几乎所有创作者都知道的方法：找一份养家糊口的“白天工作”（day job）。这个词是从音乐家身上来的，他们晚上表演音乐，所以白天可以找一份其他工作。更一般地说，“白天工作”的意思是，你有一份为了赚钱的工作，还有一份为了爱好的工作。</p></blockquote></blockquote><ul><li>对于“晚上”工作, 其实我并没有找到明确的目标, 又或者自身太过于“急躁”了</li></ul><blockquote><blockquote><p>因为黑客更像创作者，而不是科学家，所以要了解黑客，不应该在科学家身上寻找启示，而是应该观察其他类型的创作者。那么，从画家身上，我们还能借鉴到什么对黑客的启示呢？有一件事情是可以借鉴的（至少可以确认），那就是应该如何学习编程。画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。大多数黑客不是通过大学课程学会编程的，而是从实践中学习，有的13岁时就自己动手写程序了。即使上了大学，黑客学习编程依然主要通过自己写程序。</p></blockquote></blockquote><ul><li>确实, 需要先模仿, 再创新. 很多东西确实有共同的特点</li></ul><blockquote><blockquote><p>绘画还有一个值得借鉴的地方：一幅画是逐步完成的。通常一开始是一张草图，然后再逐步填入细节。但是，它又不单纯是一个填入细节的过程。有时，原先的构想看来是错的，你就必须动手修改。无数古代油画放在X光下检视，就能看出修改痕迹，四肢的位置被移动过，或者脸部的表情经过了调整。绘画的这个创作过程就值得学习。我认为黑客也应该这样工作。你不能盼望先有一个完美的规格设计，然后再动手编程，这样想是不现实的。如果你预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最终会有一个更好的结果。</p></blockquote></blockquote><ol><li>软件的设计, 比如一些通用框架, 或者服务架构, 当然是最好一开始就想清楚, 并设计好(并不代表后续不能改动), 这样有助于后续细节的实现, 也有一个基本的大局观, 同时也可以提前发现存在的问题, 避免后续的无用功, 还有提前确认好项目风险等等. </li><li>这个问题其实我是潜意识知道的，但还是因为懒，感觉太累不想思考，选择做一下具体的细节先，但有时也算是一种适当的放松吧</li></ol><blockquote><blockquote><p>黑客就像画家，工作起来是有心理周期的。有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作16个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。为了做出优秀的工作，你必须把这种心理周期考虑在内。只有这样，你才能根据不同的事情找出不同的应对方法。你有一辆手动变速的汽车，你把它开上山，有时不得不松开离合器，防止汽车熄火。同样，暂时放手有时也能防止热情熄火。对于画家和黑客这样的创作者，有些工作需要投入巨大的热情，另一些工作则是不需要很操心的日常琐事。在你厌倦的时候再去做那些比较容易的工作，这是一个不错的主意。对于编程，这实际上意味着你可以把bug留到以后解决。消灭bug对我来说属于轻松的工作，只有在这个时候，编程才变得直接和机械，接近社会大众想象中的样子。消灭bug的过程就像解一道数学题，已知许许多多的约束条件，你只要根据条件对方程求解就可以了。你的程序应该能产生x 结果，却产生了y 结果。哪里出错了？你知道自己最后肯定能解决这个问题，所以做起来就很轻松，就好像刷墙一样，接近于休闲了。</p></blockquote></blockquote><ol><li>深有同感, 松弛有度, 这样才能更愉快和保持热情的工作</li><li>一味的逼迫自己把同一件事做好, 有时却会适得其反, 因为厌倦和抗拒, 虽然工作完成了,但是实际上完成质量和效率是存在疑问的. 或许你先做另一件事,在回来做这件事,整体的效率和质量是更高的.</li><li>以前看过一种说法, 有时觉得累了并不是需要休息, 而是你的大脑需要换其他的事情</li></ol><blockquote><blockquote><p>我认为，这也是多人共同开发一个软件的正确模式。需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。最终，它就会变得像一个公用杂物间，没人管理，又脏又乱，到处堆满了冗余代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。</p></blockquote></blockquote><ul><li>提前分工明确能避免无用功, 同时能尽量确保交付时间</li></ul><blockquote><blockquote><p>普通黑客与优秀黑客的所有区别之中，会不会“换位思考”可能是最重要的单个因素。有些黑客很聪明，但是完全以自我为中心，根本不会设身处地为用户考虑。这样的人很难设计出优秀软件，因为他们不从用户的角度看待问题。</p></blockquote></blockquote><ul><li>换位思考实在是太重要了, 很多事情都能以此为切入点, 找到解决方案或者事情的本质</li></ul><blockquote><blockquote><p>判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。我们大概都认识这样一些人，他们在其他方面非常聪明，但是把问题解释清楚的能力却低下得惊人。如果聚会上外行人问他们“什么是编程语言”，他们会这样回答：“哦，高级语言就是编译器的输入代码，用来产生目标码。”高级语言？编译器？目标码？……如果对方不知道什么是编程语言，那么他显然也不会知道这些概念。</p></blockquote></blockquote><ul><li>学会类比, 使用通俗的语言, 言简意赅</li></ul><blockquote><blockquote><p>把代码写得便于阅读，并不是让你塞进去很多注释。我想引申一下阿尔贝森和萨斯曼的那句话：“程序必须写得供人们阅读，偶尔供计算机执行。”一种好的编程语言应该比英语更容易解释软件。只有在那些不太成熟、容易出现问题的地方，你才应该加上注释，提醒读者注意，就好像公路上只有在急转弯处才会出现警示标志一样。</p></blockquote></blockquote><ol><li>以前学了很多设计模式, 经常把自己搞乱, 也看了很多别人的代码, 搞了很多设计模式, 看起来好像高大上, 实际上阅读起来非常痛苦. 后来我相通了, 只有简单的代码才是最好最容易理解的, 复杂重复的地方就抽取封装, 至此, 我基本上没听说有人说我代码很难阅读, 至少在我没听过.</li><li>当然, 遇到使用了设计模式, 实现优雅可读性强的代码, 也要借鉴学习.</li></ol><h3 id="3不能说的话"><a href="#3不能说的话" class="headerlink" title="3不能说的话"></a>3不能说的话</h3><blockquote><blockquote><p>让我先问你一个问题：大庭广众之下，你有没有什么观点不愿说出口？如果回答“没有”，那么你也许应该停下来想一想了。你的每一个观点都能毫不犹豫地说出口，你自己深深赞同这些观点，并且你也确信肯定会获得别人的赞同，这是否太过于巧合了？一种可能是，也许事情并没有这么巧合，你的观点就是从别人那里听来的，别人告诉你什么，你就相信了什么，你把别人灌输的观点当作了自己的观点。</p></blockquote></blockquote><blockquote><blockquote><p>另一种可能是，你的思想观点确实是独立思考得到的，碰巧与社会主流的思想观点一模一样。这种情况的可能性似乎不大，因为这意味着，如果别人犯错了，你也必须碰巧犯一个同样的错误。</p></blockquote></blockquote><blockquote><blockquote><p>有时候，别人会对你说：“要根据社会需要，改造自己的思想。”这种说法隐含的意思似乎是，如果你不认同社会，那么肯定是你自己的问题。你同意这种说法吗？事实上，它不仅不对，而且会让历史倒退。如果你真的相信了它，凡是不认同社会之处，你连想都不敢想，马上就放弃自己的观点，那才会真正出问题。</p></blockquote></blockquote><blockquote><blockquote><p>过去和现在之间的变化有时代表了一种进步。在物理学领域，如果我们与前人看法不一样，那是因为我们是对的，他们是错的。但是，物理学是一门硬科学4，换成其他学科，我们很快就无法确定谁对谁错了。如果你遇到的是社会问题，请问过去的看法与现在的看法哪一个更正确？很多时候你无法回答，因为过去与现在之间的变化往往不是因为对错，而是因为社会观念变了。比如，法定结婚年龄的变化。</p></blockquote></blockquote><blockquote><blockquote><p>4 在学术上，“硬科学”指的是那些严格精确、以事实为依据的学科，典型代表是自然科学，比如物理学。相对应的概念则是“软科学”，指的是不那么严格精确、难以用事实检验的学科，典型代表是社会科学。——译者注</p></blockquote></blockquote><blockquote><blockquote><p>我们可能自以为是地相信，当代人比古人更聪明、更高尚。但是，了解的历史越多，就越明白事实并非如此。古人与我们是一样的人，他们既不更勇敢，也不是更野蛮，而是像我们一样通情达理的普通人。不管他们产生怎样的想法，都是正常人产生的想法。所以，我们就有了找出“不能说的话”的第三种方法：将当代观念与不同时期的古代观念diff5一下。diff得到的结果，有一些用当代标准衡量是很令人震惊的。古人认为可以说的话，我们认为是不可以说的。但是，你有把握断言你比古人更正确吗？</p></blockquote></blockquote><blockquote><blockquote><p>但是，流行的道德观念不是这样，它们往往不是偶然产生的，而是被刻意创造出来的。如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。那些团体神经越紧张，它们所产生的禁止力量就越大。</p></blockquote></blockquote><blockquote><blockquote><p>为了在全社会制造出一个禁忌，负责实施的团体必定既不是特别强大也不是特别弱小。如果一个团体强大到无比自信，它根本不会在乎别人的抨击。美国人或者英国人对外国媒体的诋毁就毫不在意。但是，如果一个团体太弱小，就会无力推行禁忌。</p></blockquote></blockquote><ul><li><p>来自微信读书评论: 强权就是公理。因为强权可以制造任何的其他客观条件，不管是社会舆论还是特定事件营销。并不觉得他们不在意，而且他们掌握更多的话语权，其他的话语流星般转瞬即逝。</p></li><li><p>来自微信读书评论:  思考：<br>人也是如此。<br>当你手里有千万资产，你会在乎别人说你穷吗？不会，你甚至都不想证明。<br>同样，当你真的有能力，你会在乎别人说你无能吗？不会。</p></li></ul><blockquote><blockquote><p>有一种行为怪癖叫作“嗜粪症”，它的患者人数以及影响力眼下似乎就不太足够，无法把自己的观点推广给其他人。我猜想，道德禁忌的最主要制造者是那些在权力斗争中略占上风的一方。你会发现，这一方有实力推行禁忌，同时又软弱到需要禁忌来保护自己的利益。</p></blockquote></blockquote><blockquote><blockquote><p>其次，我这样做是因为我不喜欢犯错。如果像其他时代一样，那些我们自以为正确的事情将来会被证明是荒谬可笑的，我希望自己能够知道是哪些事情，这样我就不会上当。</p></blockquote></blockquote><blockquote><blockquote><p>为什么？可能仅仅是因为科学家比其他领域的学者更聪明。如果有必要的话，大多数物理学家有能力拿到法国文学的博士学位，但是反过来就不行，很少存在法国文学的教授有能力拿到物理学的博士学位。13或者，另一种原因是，在科学中，命题的真伪更显而易见，所以这使得科学家能够更勇敢地质疑传统观点。（这句话也可以这样说，因为科学命题的真伪更显而易见，所以你想在科学界谋职，就不得不训练自己的智力，去发现并解决那些真正的问题，而不能仅仅当一个政治家，通过搞人事关系和派系斗争立足。）</p></blockquote></blockquote><blockquote><blockquote><p>13 这句话本身就是一种明显的“不能说的话”。它犯了大学中的一个大忌：评判各种学科的难易。大学校园中有一条默认的公理——各种领域的研究所要求的智力水平都是相同的。毫无疑问，这条公理确实能够减少冲突，让一切平稳运作。但是，如果这条公理为真，那将是多么巧合的事情啊，所有学科的难易程度居然一模一样！而且，承认这条公理比不承认它会使得一切都方便得多！你只要想到这些，怎能不质疑它呢！尤其是当你想到，一旦接受了这条公理所产生的必然推论，就更无法不质疑它了。比如，它意味着不会出现单个学科的停滞或爆发式发展，所有学科的发展形态必须是完全同步的，因为这条公理告诉我们，各个学科面对的问题难度是一样的！（要弥补这个推论，你真的会伤透脑筋。）此外，如果大学开设了烹饪系或运动管理系，你会怎么想？如果你接受上面的公理，那么大学到底还要开设什么系？你真的认为微分几何和烹饪学的难度相同吗？</p></blockquote></blockquote><blockquote><blockquote><p>不管是哪一个原因，看来都存在一个很清晰的关系：智力越高的人，越愿意去思考那些惊世骇俗的思想观点。这不仅仅因为聪明人本身很积极地寻找传统观念的漏洞，还因为传统观念对他们的束缚力很小，很容易摆脱。从他们的衣着上你就可以看出这一点：不受传统观念束缚的人，往往也不会穿流行的衣服。做一个异端是有回报的，不仅在科学领域，在任何有竞争的地方，只要你能看到别人看不到或不敢看的东西，你就有很大的优势。</p></blockquote></blockquote><blockquote><blockquote><p>一旦发现了“不能说的话”，下一步怎么办？我的建议就是别说，至少也要挑选合适的场合再说，只打那些值得打的仗。</p></blockquote></blockquote><blockquote><blockquote><p>如果你以此作为人生目的，一定要为黄颜色平反昭雪，现在的局面可能正中你下怀。但是，如果你的兴趣主要是别的事情，变成他人眼里的“黄色分子”对你则是极大的干扰。与笨蛋辩论，你也会变成笨蛋。</p></blockquote></blockquote><ul><li>来自微信读书评论: 真理越辩越明？不会的，争辩让你妄想说服对方，争辩让你学会讨好观众，这些有时会让你失去自由。</li></ul><blockquote><blockquote><p>这时你要明白，自由思考比畅所欲言更重要。如果你感到一定要跟那些人辩个明白，绝不咽下这口气，一定要把话说清楚，结果很可能是从此你再也无法自由理性地思考了。</p></blockquote></blockquote><ul><li><p>社会本来就需要各种各样的人, 有时候不说话的人的利益, 就是说话的人牺牲的人带来的. </p></li><li><p>来自微信读书评论: 可如果所有人都遵守这个准则，那么又何来变化和进步呢？每个大的进步和改革背后，都是一群不愿闭嘴的人推动而成吧</p></li><li><p>来自微信读书评论: 谭嗣同愿意以身犯险，最终奔赴黄泉，但推行“戊戌变法”，叫醒国人他功不可没！你说的没毛病，就看你怎么选择了</p></li></ul><blockquote><blockquote><p>我认为这样做不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。我就鼓励自己在心里默默思考那些最无法无天的想法。你的思想是一个“地下组织”，绝不要把那里发生的事情一股脑说给外人听。“格斗俱乐部”的第一条规则，就是不要提到格斗俱乐部。15</p></blockquote></blockquote><blockquote><blockquote><p>我承认，“守口如瓶”看上去是一种“怯懦”的行为。可是问题在于，“不能说的话”太多了，如果口无遮拦，你就没时间做正事了。为了与他人论战，你不得不变成一个语言学家</p></blockquote></blockquote><blockquote><p>“守口如瓶”的真正缺点在于，你从此无法享受讨论带来的好处了。讨论一个观点会产生更多的观点，不讨论就什么观点也没有。所以，如果可能的话，你最好找一些信得过的知己，只与他们畅所欲言、无所不谈。这样不仅可以获得新观点，还可以用来选择朋友。能够一起谈论“异端邪说”并且不会因此气急败坏的人，就是你最应该认识的朋友。</p></blockquote><blockquote><blockquote><p>你的策略，简单地说，就是不赞同这个时代的任何一种歇斯底里的行为，但是又不明确告诉别人到底不赞同哪一种。</p></blockquote></blockquote><blockquote><blockquote><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。</p></blockquote></blockquote><blockquote><blockquote><p>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑：什么话是我不能说的？为什么？</p></blockquote></blockquote><ul><li>来自微信读书评论: 离经叛道不是一件好事，尤其在我国。<br>作者让人们保持质疑，虽然只想不说，也很难说是不是好事。<br>这跟郑板桥提倡的难得糊涂恰好相反，我支持郑，因为对大部分个体，发现真相却不能做什么，只会陷入深切痛苦。<br>这时作者唤醒的就不是“嘲笑鸟”，而是沉睡的恶魔。</li></ul><h2 id="第二部分-黑客如何工作及影响世界"><a href="#第二部分-黑客如何工作及影响世界" class="headerlink" title="第二部分 黑客如何工作及影响世界"></a>第二部分 黑客如何工作及影响世界</h2><h3 id="4良好的坏习惯"><a href="#4良好的坏习惯" class="headerlink" title="4良好的坏习惯"></a>4良好的坏习惯</h3><blockquote><blockquote><p>对于适当的不服从管教保持宽容，这不会有太大的坏处，反而很有利于造就美国的国家优势，它使得美国不仅能吸引聪明人，还能吸引那些很自负的人。黑客永远是自负的。</p></blockquote></blockquote><blockquote><blockquote><p>这种事情早有先例：人们惊慌失措时采取的措施到头来产生了适得其反的效果。</p></blockquote></blockquote><ul><li>来自微信读书评论: 紧急情况下猛打方向，结果汽车撞上护栏，最终翻车；碰到劫匪声嘶力竭地大叫，导致劫匪因惊慌临时动了杀心；碰到地震火情冲向还闭着的门，导致踩踏，打不开门，最终自食恶果。极度惊慌，是人类的最强大武器——头脑失效的时刻，也就演变成坐以待毙的时刻。</li></ul><blockquote><blockquote><p>那些占据高位、本能地想要约束黑客、强迫黑客服从的人，请谨慎施为，因为你们真有可能成为千古罪人。</p></blockquote></blockquote><h3 id="5另一条路"><a href="#5另一条路" class="headerlink" title="5另一条路"></a>5另一条路</h3><blockquote><blockquote><p>早一点发现bug就不容易形成复合式bug，也就是互相影响的两个bug。举例来说，一个bug是楼梯很滑，另一个bug是扶手松了，那么只有当这两个bug互相作用时，才会导致你从楼梯上摔下来。在软件中，复合式bug是最难发现的bug，往往也会导致最大的损失。</p></blockquote></blockquote><ul><li>来自微信读书评论: 复合式bug有一个子类型：两个bug是互相弥补的，好比“负负得正”，软件反而能正常运行。这种bug可能才是最难发现的bug。当你修正了其中的一个bug，另一个bug才会暴露出来。这时对你来说，你会觉得刚才修正错了，因为那是你最后修改的地方，你就怀疑自己在那里做错了，但是你其实是对的。</li></ul><blockquote><blockquote><p>向一个项目增加人手，往往会拖慢项目进程。随着参与人数的增加，人与人之间需要的沟通成本呈现指数级增长。人数越来越多，开会讨论各个部分如何协同工作所需的时间越来越长，无法预见的互相影响越来越大，产生的bug也越来越多。</p></blockquote></blockquote><ul><li>来自微信读书评论: 《人月神话》是一本软件项目管理名著。所谓“人月”就是一个人在一个月内所能完成的工作量。假如某个项目预估需要12个人月，那么派4个人处理这个项目，理论上需要3个月，派6个人则只需要2个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短工期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。</li></ul><blockquote><blockquote><p>人数越来越少，软件开发的效率将呈指数式上升。</p></blockquote></blockquote><blockquote><blockquote><p>不要只因为对方的头衔是市场专家、设计师或产品经理，就盲目听从他们的话。如果他们的观点真的很好，那就听从他们，关键是你要自己判断，不要盲从。只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不打算自己动手设计和开发，那就不要创业。</p></blockquote></blockquote><ul><li>实际在大公司, 通常只能按照产品说的做</li><li>心中放置一种观点: 虽然我按照你说的做了, 但实际上我并不认同, 仅仅是因为工作需要</li></ul><h3 id="6如何创造财富"><a href="#6如何创造财富" class="headerlink" title="6如何创造财富"></a>6如何创造财富</h3><blockquote><blockquote><p>承受较大的压力通常会为你带来额外的报酬，但是你还是无法逃避基本的守恒定律。</p></blockquote></blockquote><blockquote><blockquote><p>现在先不考虑比尔·盖茨，因为名人不适合用来举例子，媒体只报道那些最有钱的人，而他们往往属于特例。比尔·盖茨很聪明，有决断力，工作也很勤奋，但是单单这样还不足以让你成为他，你还需要非同一般的好运气。</p></blockquote></blockquote><blockquote><blockquote><p>任何公司的成功历程中，运气都是一个很大的随机因素。</p></blockquote></blockquote><blockquote><blockquote><p>致富的方法有许多种，本文只谈论其中的一种，也就是通过创造有价值的东西在市场上得到回报，从而致富。</p></blockquote></blockquote><blockquote><blockquote><p>通过创造有价值的东西而致富，这种方法的优势不仅仅在于它是合法的（许多其他方法如今都是不合法的），还在于它更简单，你只需要做出别人需要的东西就可以了。</p></blockquote></blockquote><blockquote><blockquote><p>3 近代历史上，政府有时都搞不清楚金钱和财富的区别。亚当·斯密在《国富论》中提到，许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是，黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。</p></blockquote></blockquote><blockquote><blockquote><p>财富是最基本的东西。我们需要的东西就是财富，食品、服装、住房、汽车、生活用品以及外出旅行等都是财富。即使你没有钱，你也能拥有财富。</p></blockquote></blockquote><ul><li>来自微信读书评论: 如此说来，以后还是尽量避免说自己穷，如果真的要说的话直接说自己现在没有钱好了。</li></ul><blockquote><blockquote><p>你真正需要的是财富。财富才是你的目标，金钱不是。</p></blockquote></blockquote><blockquote><blockquote><p>虽然在某些特定的情况下（比如某个家庭当月的收入），你能用来与他人交换的金钱数量是固定不变的，但是大多数情况下，世界上可供交换的财富不是一个恒定不变的量。人类历史上的财富一直在不停地增长和毁灭（总体上看是净增长）。</p></blockquote></blockquote><blockquote><blockquote><p>假设你拥有一辆老爷车，你可以不去管它，在家中悠闲度日，也可以自己动手把它修葺一新。这样做的话，你就创造了财富。世界上因为多了一辆修葺一新的车，财富就变得更多了一点，对你而言尤其是如此。这可不是隐喻的用法，如果你把车卖了，你得到的卖车款就比以前更多。</p></blockquote></blockquote><blockquote><blockquote><p>通过修理一辆老爷车，你使得自己更富有。与此同时，你也并没有使得任何人更贫穷。所以，这里明显不是一个面积不变的大饼。事实上，当这样观察的时候，你会很好奇，为什么有人会觉得大饼的面积无法增大。</p></blockquote></blockquote><ul><li>来自微信读书评论: 财富是创造出来的。如果我们养成健康的体魄，坚持锻炼，节制饮食，这也是我们所创造出的健康财富呀！</li></ul><blockquote><blockquote><p> 如果在修理旧车的过程中，你对环境造成了一些微小的破坏，那么你可能使得每个人都变得更贫穷了一点。但是即使把环境的成本考虑在内，这依然不是一个零和游戏，依然存在财富的净增长。我们可以举出这样的例子，一台坏机器里有一个零件松了，你把零件拧紧，机器可以重新运作，那么你就没对环境造成任何破坏，并且创造了财富。</p></blockquote></blockquote><blockquote><blockquote><p>最可能明白财富能被创造出来的人就是那些善于制作东西的人，也就是手工艺人。他们做出来的东西直接放在商店里卖。但是，随着工业化时代的来临，手工艺人越来越少。目前还存在的最大的手工艺人群体就是程序员。</p></blockquote></blockquote><blockquote><blockquote><p>要致富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩应该是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。</p></blockquote></blockquote><ul><li>来自微信读书评论: 可放大性：使用人数的指数型上涨，如果你所创造的财富有缺陷，会被无限放大；可测量性：每个员工所做的工作都有其明确的反馈。</li></ul><blockquote><blockquote><p>任何一个通过自身努力而致富的个人，在他身上应该都能同时发现可测量性和可放大性。我能想到的例子就有CEO、电影明星、基金经理和专业运动员。</p></blockquote></blockquote><blockquote><blockquote><p>有一个办法可以发现是否存在可放大性，那就是看失败的可能性。因为收入和风险是对称的，所以如果有巨大的获利可能，就必然存在巨大的失败可能。</p></blockquote></blockquote><blockquote><blockquote><p>黑客都是极度厌恶风险的人</p></blockquote></blockquote><blockquote><blockquote><p>我们宁愿以百分之百的把握去赚100万美元，也不愿以20%的把握去赚1 000万美元，尽管后者理论上的期望值比前者高出一倍。</p></blockquote></blockquote><blockquote><blockquote><p>保险的做法就是在早期卖掉自己的创业公司，放弃未来发展壮大</p></blockquote></blockquote><blockquote><blockquote><p>缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。</p></blockquote></blockquote><blockquote><blockquote><p>每一个这样做的人差不多应用了同样的诀窍：可测量性和可放大性</p></blockquote></blockquote><blockquote><blockquote><p>一旦自己的财产有了保证，那些想致富的人就会愿意去创造财富</p></blockquote></blockquote><blockquote><blockquote><p>要鼓励大家去创业，只要懂得藏富于民，国家就会变得强大。让“书呆子”保住他们的血汗钱，你就会无敌于天下。</p></blockquote></blockquote><h3 id="7关注贫富分化"><a href="#7关注贫富分化" class="headerlink" title="7关注贫富分化"></a>7关注贫富分化</h3><blockquote><blockquote><p>一旦通过创造财富而使致富成为可能，社会从整体上就会快速地变得更富有。</p></blockquote></blockquote><blockquote><blockquote><p>首先，技术肯定加剧了有技术者与无技术者之间的生产效率差异，毕竟这就是技术进步的目的。一个勤劳的农民使用拖拉机比使用马可以多耕6倍的田，但是前提条件是他必须掌握如何使用新技术。</p></blockquote></blockquote><blockquote><blockquote><p>但是，苹果公司推出了强大而且便宜的个人计算机，使得一切成为可能，这本身就是在创造财富。程序员马上接了上去，使用苹果公司的产品，再去创造更多的财富。</p></blockquote></blockquote><blockquote><blockquote><p>技术应该会引起收入差距的扩大，但是似乎能缩小其他差距。100年前，富人过着与普通人截然不同的生活。他们住在大房子里，有许多仆人服侍，穿着华丽但是不舒适的服装，乘着马车旅行（因此还有马厩和马夫）。</p></blockquote></blockquote><blockquote><blockquote><p>现在，由于技术的发展，富人的生活与普通人的差距缩小了。</p></blockquote></blockquote><blockquote><blockquote><p>汽车就是一个很好的例子。如果富人不购买普通汽车，而是购买全手工制作、售价高达几十万美元一辆的豪华车，对他反而不利。因为对于汽车公司来说，生产那些销量很大的普通汽车要比生产那些销量很小的豪华车更有利可图，所以汽车公司会在普通车辆上投入更多的精力和资金，进行设计和制造。如果你购买专为你一个人定制的汽车，质量反而不可靠，某个部件肯定会出问题。这样做的唯一意义就是告诉别人你有能力这样做。</p></blockquote></blockquote><blockquote><blockquote><p>无法被技术变得更便宜的唯一东西，就是品牌。这正是为什么我们现在越来越多地听到品牌这个词。富人与穷人之间生活的鸿沟正在缩小，品牌是这种差距的遗留物。</p></blockquote></blockquote><blockquote><blockquote><p>无论在物质上，还是在社会地位上，技术好像都缩小了富人与穷人之间的差距，而不是让这种差距扩大了。</p></blockquote></blockquote><blockquote><blockquote><p>如果参观雅虎、英特尔或思科公司，你会看到每个人都穿着差不多的衣服，有着同样的办公室（或者小隔间）、同样的家具，彼此直呼对方的名字，不加任何头衔或敬语。表面看大家没什么差距，但如果看到每个人银行户头上的余额差别之大，你一定会感到震惊不已。</p></blockquote></blockquote><blockquote><blockquote><p>技术的发展加大了贫富差距，这是不是一个社会问题？</p></blockquote></blockquote><blockquote><blockquote><p>好像没有那么严重。技术在加大收入差距的同时，缩小了大部分其他差距。</p></blockquote></blockquote><blockquote><blockquote><p>我想提出一种相反的观点：现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了；（b）那些创造大部分财富的人停止工作了；（c）创造财富的人没有获得报酬。</p></blockquote></blockquote><blockquote><blockquote><p>如果得不到报酬，人们是否愿意创造财富？唯一的可能就是，工作必须能提供乐趣。会有人愿意免费写一个操作系统，但是他们不愿意免费为你安装、提供电话支持、进行客户培训等。即使是最先进的高科技公司，也有至少90%的工作没有乐趣、令人生厌。</p></blockquote></blockquote><blockquote><blockquote><p>一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程中做出的事情。</p></blockquote></blockquote><blockquote><blockquote><p>我在这里谈的不是财富从富人流向穷人的那种涓滴效应（trickle-down effect），也不是说如果你让亨利·福特致富，他就会在下一场宴会雇用你当服务员，而是说如果你让他致富，他就会造出一台拖拉机，使你不再需要使用马匹耕田了。</p></blockquote></blockquote><h3 id="9设计者的品味"><a href="#9设计者的品味" class="headerlink" title="9设计者的品味"></a>9设计者的品味</h3><blockquote><blockquote><p>但是，如果你是一个设计师，并且你不承认有一种人们共同认可的东西叫作“美”，那么你就没有办法做好工作。</p></blockquote></blockquote><blockquote><blockquote><p>如果品味只是一种个人偏好，那么每个人都是完美无缺的：你喜欢自己看上的东西，那就足够了。</p></blockquote></blockquote><blockquote><blockquote><p>就像别的工作一样，只要你不断地从事设计工作，你就会做得越来越好。你的品味会出现变化，你会像别人一样有所提高。如果这样的话，那么你以前的品味就不只是与现在不同，而是不如现在的好。因此，所谓“品味没有好坏之分”的公理也就顿时见鬼去了</p></blockquote></blockquote><blockquote><blockquote><p>众多不同学科对“美”的认识有着惊人的相似度。优秀设计的原则是许多学科的共同原则，一再出现。</p></blockquote></blockquote><ul><li>来自微信读书评论: <ul><li><p>比如：艺术上的美感包括什么类型？鲜明、丰富、和谐、简约等多种类型。把这种美感映射到代码上，体现是：模块功能清晰、齐全、借口调用方便、设计简洁等等。映射到科研上，体现是：工作思路巧妙、分析严密、逻辑通畅、简明扼要等。</p></li><li><p>懂审美买美的，爱慕虚荣的买贵的，懂技术的买性价比高的，爱明星买明星代言的。这些属性会有重合，重合越多这个产品的消费群体就越广。</p></li><li><p>作者总结的共同原则有：<br>  好设计是简单的设计。<br>  好设计是永不过时的设计。<br>  好设计是解决主要问题的设计。<br>  好设计是启发性的设计。<br>  好设计通常是有点趣味性的设计。<br>  好设计是艰苦的设计。<br>  好设计是看似容易的设计。<br>  好设计是对称的设计。<br>  好设计是模仿大自然的设计。<br>  好设计是一种再设计。<br>  好设计是能够复制的设计。<br>  好设计常常是奇特的设计。<br>  好设计是成批出现的。<br>  好设计常常是大胆的设计。</p></li><li><p>一般拥有这种品位和能力的人，都让人觉得有点洁癖，强迫症以及所谓的完美主义倾向，这些特质不是所谓的作秀和装逼，而是内心觉得看到觉得不对的就内心极为难受，压抑不住，创造者的特质就是在细节方面让人觉得有吹毛求疵的倾向。</p></li><li><p>丘吉尔：Perhaps I can implore you not to feel the need to be too accurate.（我想恳请你不必画得太准确。）<br>  给丘吉尔画肖像画的画家：Why? Accuracy is truth.（为什么？准确才是真实。）<br>  丘吉尔：No. For accuracy, We have the camera. Painting is the higher art. And I never let accuracy get in the way of truth if I don’t want it to.（不。想准确的话，我们有相机。绘画是更高一层的艺术。我从来不会让准确遮挡真相。）<br>  ——美剧《王冠》第一季</p></li><li><p>以前历史老师总说，是历史成就了一个人，而不是一个人成就了历史，尽管当时不是那个人，也会有另一个人出现。经常是大势和环境成就了你，不一定因为你就多么与众不同。</p></li><li><p>时势造英雄，个人的能力是渺小的，无论你认为你多么强大，在历史的洪流之下，我们顺势而行。无论你认为你做出多么英明的决策也不过是在环境和条件的自然反射。</p></li><li><p>不得不说，发展就是让平均每个人可利用的资源越来越多。当总资源无法满足每个人的需求时，就会催生技术变革；当总资源很大程度可以满足每个人的需求时，生活水平就会极速提高。</p></li></ul></li></ul><h2 id="第三部分-黑客的工具和工作方法"><a href="#第三部分-黑客的工具和工作方法" class="headerlink" title="第三部分 黑客的工具和工作方法"></a>第三部分 黑客的工具和工作方法</h2><h3 id="10编程语言解析"><a href="#10编程语言解析" class="headerlink" title="10编程语言解析"></a>10编程语言解析</h3><blockquote><blockquote><p>一个操作所需的代码越多，就越难避免bug，也越难发现它们</p></blockquote></blockquote><blockquote><blockquote><p>程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了，所以几乎不值得非常麻烦地用汇编语言开发软件。只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观层面控制硬件，使得游戏速度得到最大限度的终极提高。</p></blockquote></blockquote><blockquote><blockquote><p>语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java语言是前一个阵营的代表，Perl语言则是后一个阵营的代表。（美国国防部很看中Java也就不足为奇了。）</p></blockquote></blockquote><ul><li>现在的人信息量太大了，没大多时间深入学习精通，大多数水平有限，但又要避免出错，所以go的限制，静态语言，一定程度上符合大家的利益</li><li>来自微信读书评论: rust的设计哲学恰恰相反，认为编码的都是傻x，事实上rust这种思路更符合现实</li></ul><h3 id="11一百年后的编程语言"><a href="#11一百年后的编程语言" class="headerlink" title="11一百年后的编程语言"></a>11一百年后的编程语言</h3><blockquote><blockquote><p>任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。</p></blockquote></blockquote><blockquote><blockquote><p>如果我们把一种语言的内核设想为一些基本公理的集合，那么仅仅为了提高效率就往内核添加多余的公理，却没有带来表达能力的提升，这肯定是一件很糟的事。</p></blockquote></blockquote><blockquote><blockquote><p>没错，效率是很重要，但是我认为修改语言设计并不是提高效率的正确方法。</p></blockquote></blockquote><blockquote><blockquote><p>正确做法应该是将语言的语义与语言的实现予以分离。在语义上不需要同时存在列表和字符串，单单列表就够了。而在实现上做好编译器优化，使它在必要时把字符串作为连续字节的形式处理。</p></blockquote></blockquote><ul><li>来自微信读书评论: Common Lisp的变量是动态的，数据类型是静态的。比如declare function的时候，任何数据类型都可以作为变量；而一个有string type的语言，变量名就只能是string<br>用动态语言编写的程序会更简洁，互动性更强，更多hacks，更常用prototype而不是class。但同时运行的时候也会有更多type error，所以需要好好写测试。<br>用静态语言编写的程序在设计上更直观，程序更稳定，更常用class而不是prototype。程序在编译的时候就可以捕获大多数错误。<br>另一种理解动态静态的方式是：动态的思维是离散的、公理化的、prototypical的、象征着直觉；静态的思维是抽象的、定理推导式的、classified and hierarchical的、遵循着逻辑。<br>这篇文章既然在讨论程序语言的进化，那么一定是从动态的角度出发，从设计简洁的基本公理开始，以期达成创新。（后文提到是否应该用list来表达数字正是作者对简化公理的猜想。或许新的计算机出现以后这真会成为现实呢？）<br>由此推算，可能初创公司更适合用迭代快速的动态语言，而成熟的企业更需要静态语言来确保代码的可读性和实用性。<br>我等菜鸡还是先乖乖练好静态语言再说吧。动态语言也就是作者这样的满级人类用得比较爽，毕竟他已经把写代码比作写文章了……</li></ul><blockquote><blockquote><p>对于大多数程序，速度不是最关键的因素，所以你通常不需要费心考虑这种硬件层面上的微观管理。随着计算机速度越来越快，这一点已经越发明显了。</p></blockquote></blockquote><blockquote><blockquote><p>essay（论文）这个词来自法语的动词essayer，意思是“试试看”。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。软件也是如此。我觉得一些最好的软件就像论文一样，也就是说，当作者真正开始动手写这些软件的时候，他们其实不知道最后会写出什么结果。</p></blockquote></blockquote><ul><li>来自微信读书评论: 好的软件是边探索边写边迭代出来的，作者大概指的是黑客写的小而精美的软件，而不是软件工程下的大型软件</li></ul><blockquote><blockquote><p>一般来说，如果你动手创造一种新语言，那是因为你觉得它在某些方面会优于现有的语言。Java语言之父詹姆斯·高斯林在第一份《Java白皮书》中说得很清楚，之所以要设计Java，就是想解决C++的一些弱点。所以结论就是，各种编程语言的编程能力是不相同的。</p></blockquote></blockquote><blockquote><blockquote><p>编程时提高代码运行速度的关键是使用好的性能分析器（profiler）</p></blockquote></blockquote><blockquote><blockquote><p>为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。在你的大脑中，有一个声音说“千难万险只等闲”，还有一个声音却说“早岁那知世事艰”。这里的难点在于你要意识到，实际上这两种信念并不矛盾。你的乐观主义和怀疑倾向分别针对两个不同的对象。你必须对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。</p></blockquote></blockquote><ul><li>有很多工作并不像计算机一样，不是0就是1，对待任务，我很有信心做好，但同时以往的经验告诉我，随着工作进行的深入，会有很多细节需要考虑，可能并不是简单就能完成的事，毕竟内心还是想尽可能接近完美</li></ul><blockquote><blockquote><p>做出优秀成果的人，在做的过程中常常觉得自己做得不够好。其他人看到他们的成果觉得棒极了，而创造者本人看到的都是自己作品的缺陷。这种视角的差异并非偶然，因为只有对现状不满，才会造就杰出的成果。</p></blockquote></blockquote><blockquote><blockquote><p>如果你能平衡好希望和担忧，它们就会推动项目前进，就像自行车在保持平衡中前进一样。在创新活动的第一阶段，你不知疲倦地猛攻某个难题，自信一定能够解决它。到了第二阶段，你在清晨的寒风中看到自己已经完成的部分，清楚地意识到存在各种各样的缺陷。此时，只要你对自己的怀疑没有超过你对自己的信心，就能够坦然接受这个半成品，心想不管多难我还是可以把剩下的部分做完。</p></blockquote></blockquote><blockquote><blockquote><p>让这两股相反的力量保持平衡是很难的。初出茅庐的年轻黑客都很乐观，自以为做出了伟大的产品，从不反思和改进。上了年纪的黑客又太不自信，甚至故意回避一些挑战性很强的项目。</p></blockquote></blockquote><ul><li>来自微信读书评论: 达克效应的两面：无知的人认为自己无所不知、无所不能，能力越差越自信无比；能力强的人经常怀疑自己的能力，自信不足。学会平衡两种状态</li></ul><blockquote><blockquote><p>大家都知道，让一个委员会负责设计语言是非常糟糕的主意。委员会只会做出恶劣的设计。但是我觉得，委员会最大的问题在于他们妨碍了“再设计”。在委员会的主持下，修改一种语言是非常麻烦的事，没有人愿意自讨苦吃。而且，即使大多数成员不喜欢某种做法，委员会最后的决定往往还是维持现状。</p></blockquote></blockquote><ul><li>大公司会有很多制度，有些人很不喜欢，但我恰恰认为这是保护员工的机制</li></ul><blockquote><blockquote><p>设计与研究的区别看来就在于，前者追求“好”，后者追求“新”。优秀的设计不一定很“新”，但必须是“好”的；优秀的研究不一定很“好”，但必须是“新”的。</p></blockquote></blockquote><blockquote><blockquote><p>我认为这两条道路最后会发生交叉：只有应用“新”的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是“好”的难题），才会诞生最佳研究。所以，最终来说，设计和研究都通向同一个地方，只是前进的路线不同罢了。</p></blockquote></blockquote><blockquote><blockquote><p>如果把创造一种编程语言看成设计问题，而不是科研方向，那么有何不同？最大的不同在于你会更多地考虑用户。</p></blockquote></blockquote><blockquote><blockquote><p>优秀的建筑师不会先设计，然后强迫用户接受，而是先研究最终用户的需求，然后做出用户需要的设计。</p></blockquote></blockquote><blockquote><blockquote><p>注意，我说的是“用户需要的设计”，而不是“用户要求的设计”。</p></blockquote></blockquote><ul><li>来自微信读书评论: <ul><li>乔布斯：“人们不知道他们想要什么，直到你把产品放到他们面前。” 用户不可能了解所有选择，特别是那些还未被创造的选择，直到你创造出了它们。王维嘉《暗知识》里对这种情况做了更basic的梳理：有些需求是已知的，有些需求是未知的。在你把未知的选项呈现在它们面前之前，你永远不可能通过倾听需求而得到最优解。</li><li>用户提的需求不一定都是对的，要经过思考后加以取舍。分清目标和手段，目标只有一个，手段途径却有很多</li><li>并不是来自用户的所有需求都是合理的，即便是面对合理的需求，从用户提出需求所解决的问题着手，去挖掘出他们的根本目的，再设计出完备的解决方案，会比直接照搬照套来得更有效果。</li></ul></li></ul><blockquote><blockquote><p>在软件领域，贴近用户的设计思想被归纳为“弱即是强”（Worse is Better）模式2。这个模式实际上包含了好几种不同的思想，所以至今人们还在争论它是否真的成立。但是， 其中有一点是正确的，那就是如果你正在设计某种新东西，就应该尽快拿出原型，听取用户的意见。</p></blockquote></blockquote><ul><li>来自微信读书评论: 刚做软件的时候，我也很赞同这种模式，原因是因为我认为如果你发布了一个很磕碜的产品恶心到了用户，用户一定不会在给你任何尝试的机会，所以应该一气呵成出一个完美的产品交给用户，让他们忠实。后来发现根本不可行，闭门造车，永远造不出用户喜欢的东西。但是如何避免磕碜的产品恶心到用户呢？那就是采用天使用户模式，每次迭代产品让这部分愿意参与尝试的天使用户进行尝鲜，根据他们的反馈来决定是否大量发布，既保证了快速迭代，又保证了用户体验</li></ul><blockquote><blockquote><p>2 “弱即是强”指的是一种软件传播的模式，由Common Lisp专家理查德·加布里埃尔（Richard P. Gabriel）于1991年在“Lisp: Good News, Bad News, How to Win Big”一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能（弱）反而是更好的选择（强），因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力。加布里埃尔本人经常举Unix和C语言的例子，Unix和C在设计上考虑了实际环境，放弃了一些功能，但是保证了简单性，这使得它们最终在竞争中胜出，成为主流操作系统和编程语言。——译者注</p></blockquote></blockquote><blockquote><blockquote><p>与之对照，还有另一种软件设计思想，也许可以被称为“万福玛丽亚”模式。它不要求尽快拿出原型，然后再逐步优化，它的观点是你应该等到完整的成品出来以后再一下子隆重地推向市场，就像圣母玛丽亚降临一样，哪怕整个过程漫长得像橄榄球运动员长途奔袭、达阵得分也没有关系。在互联网泡沫时期，无数创业公司因为相信了这种模式而自毁前程。我还没听说过有人采用这种模式而获得成功。</p></blockquote></blockquote><ul><li>我的另一种想法: 一个app用于试错，最后开发另外一个app替换，前一个app用来导流，制造竞争关系</li></ul><blockquote><blockquote><p>软件领域以外的人可能没听过“弱即是强”，所以意识不到这种模式在艺术领域普遍存在。以绘画为例，文艺复兴时期就有人发现了这一点。如今，绝大部分美术老师会告诉你准确画出一个东西的方法，不是沿着轮廓慢慢地一个部分一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。</p></blockquote></blockquote><blockquote><blockquote><p>先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。在开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果，这好比让你看到不远处就是唾手可得的奖励，你因此会受到激励和鼓舞。</p></blockquote></blockquote><blockquote><blockquote><p>跟你说实话吧，画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”</p></blockquote></blockquote><blockquote><blockquote><p>士气也可以解释为什么很难为低端用户设计出优秀产品，因为优秀设计的前提是你自己必须喜欢这种产品，否则你不可能对设计有兴趣，更不要说士气高昂了。</p></blockquote></blockquote><blockquote><blockquote><p>为了把产品设计好，你必须对自己说“哇，这个产品太棒了，我一定要设计好！”，而不是心想：“这种垃圾玩意，只有傻瓜才会喜欢，随便设计一下就行了。”</p></blockquote></blockquote><ul><li>现在写代码，对一些复杂的代码段，我喜欢针对做一下单元测试，这样可以快速看到效果，也可以避免后续整个流程时出现太多的bug</li><li>来自微信读书评论<ul><li>学习编程语言也是这样，不要妄想着从书本上把所有东西都学精通，然后再开始接触实际的项目，没有实际的操作，不能对自己学到的东西加以巩固和思考，书上的东西始终是作者的</li><li>先有整体概念，然后，再优化。先做一个框架，然后再丰富细节，一定要先想好，保证框架是对的，不然，重头再来的成本太高。</li><li>如何能把事情做的更好：<br>  1、目标分解成小目标。2、在众多方案中采取能看到过程效果的方案。3、奖赏机制，如quick win。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/01/14/20230114-%E5%80%9F%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%</summary>
      
    
    
    
    
    <category term="BOOK" scheme="http://yoursite.com/tags/BOOK/"/>
    
  </entry>
  
  <entry>
    <title>技术选型要注意什么?</title>
    <link href="http://yoursite.com/2022/11/18/20221118-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2022/11/18/20221118-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/</id>
    <published>2022-11-18T05:59:51.000Z</published>
    <updated>2023-05-07T14:41:07.800Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/11/18/20221118-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/messi3.png"></p><ul><li><p>充分了解才能用，基本了解，大局实现，</p></li><li><p>充分测试，压测分析profile，</p></li><li><p>非核心业务试行，</p></li><li><p>业界选择，不是说别人牛，是因为别人拿业务来验证过</p></li><li><p>待整理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/11/18/20221118-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/messi3.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的重构（翻译）经历</title>
    <link href="http://yoursite.com/2022/10/18/20221018-%E6%88%91%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2022/10/18/20221018-%E6%88%91%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%E7%BB%8F%E5%8E%86/</id>
    <published>2022-10-18T15:05:58.000Z</published>
    <updated>2023-05-07T14:41:07.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/18/20221018-%E6%88%91%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%E7%BB%8F%E5%8E%86/messi4.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>这里的重构基本指的是：把用A语言写的服务，使用B语言重写</li><li>工作的大部分内容其实就是人肉代码翻译</li><li>当然，重构通常也伴随的架构的优化和调整</li><li>最后，为了保证工作的顺利进行和服务的稳定切换，也总结了一些经验</li><li>下面将简要讲述作者的三段重构经历，分别是将三种不同的语言重构成Java（本人公司的所在的业务的主要语言就是Java，个人没特殊语言癖好），作者其实对这三种语言都不熟悉，是怎么完成重构任务的呢？</li></ol><h2 id="一、PHP重构成Java（“一比一”迁移）"><a href="#一、PHP重构成Java（“一比一”迁移）" class="headerlink" title="一、PHP重构成Java（“一比一”迁移）"></a>一、PHP重构成Java（“一比一”迁移）</h2><ul><li>负责该业务的模块</li><li>启动环境太复杂，较复杂的逻辑通过在线工具运行验证</li><li>和熟悉该业务的PHP同事合作</li><li>切换服务接口使用灰度策略和配置开关</li><li>覆盖好测试用例</li></ul><ul><li>没本地环境，必要时在线运行验证</li></ul><h2 id="二、C-重构成Java（站在“巨人的肩膀”上重新出发）"><a href="#二、C-重构成Java（站在“巨人的肩膀”上重新出发）" class="headerlink" title="二、C++重构成Java（站在“巨人的肩膀”上重新出发）"></a>二、C++重构成Java（站在“巨人的肩膀”上重新出发）</h2><ul><li>其他公司业务调整，业务并入，需复制一套业务功能基本相同的服务</li><li>通过参考原业务的代码，发现其中架构存在的问题，进行优化；参考其中的实现，避免在新实现中出现考虑不周（站在“巨人的肩膀”上）</li><li>和第一段重构经历不同的是，原服务只是作为参考，在业务功能上一摸一样，并不需要在内部实现上保持和原来完全一致，但是新服务需要融入现有的服务基础体系</li><li>有意思的优化，原来因为业务逻辑的需要使用单体服务，新服务使用新的巧妙设计，是服务可以有多实例运行</li></ul><ul><li>不需要本地环境，阅读参考即可</li></ul><h2 id="三、Lua重构成Java（对当前“一无所知”也没关系）"><a href="#三、Lua重构成Java（对当前“一无所知”也没关系）" class="headerlink" title="三、Lua重构成Java（对当前“一无所知”也没关系）"></a>三、Lua重构成Java（对当前“一无所知”也没关系）</h2><ul><li>本地把环境跑起来，通过调试验证逻辑</li><li>新业务需要，需要参考部分逻辑，同时进行重构，反哺原业务团队</li></ul><ul><li>需要本地环境，验证原本一无所知的逻辑</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>编程语言的语言其实大同小异，花半天左右基本可以快速熟悉语法，在阅读代码的时候遇到不懂的地方，即时查阅即可；</li><li>对于一些复杂的逻辑，可以通过编写代码块，执行验证输出；可以在本地环境运行，也可以利用在线工具运行；</li><li>对于历史包袱较重的，要善于利用灰度策略；</li><li>阅读代码后，跟熟悉业务的同学请教确认，和同事们讨论有时也是很有必要的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/10/18/20221018-%E6%88%91%E7%9A%84%E9%87%8D%E6%9E%84%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89%E7%BB%8F%E5%8E%86/messi4.png&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="重构" scheme="http://yoursite.com/tags/%E9%87%8D%E6%9E%84/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我的几张TCP原理学习手绘图</title>
    <link href="http://yoursite.com/2022/09/08/20220908-%E6%88%91%E7%9A%84%E5%87%A0%E5%BC%A0TCP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%89%8B%E7%BB%98%E5%9B%BE/"/>
    <id>http://yoursite.com/2022/09/08/20220908-%E6%88%91%E7%9A%84%E5%87%A0%E5%BC%A0TCP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%89%8B%E7%BB%98%E5%9B%BE/</id>
    <published>2022-09-08T06:16:54.000Z</published>
    <updated>2023-05-07T14:41:07.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络寻址原理"><a href="#网络寻址原理" class="headerlink" title="网络寻址原理"></a>网络寻址原理</h2><p><img src="/2022/09/08/20220908-%E6%88%91%E7%9A%84%E5%87%A0%E5%BC%A0TCP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%89%8B%E7%BB%98%E5%9B%BE/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80%E5%8E%9F%E7%90%86.jpg"></p><h2 id="负载均衡模式"><a href="#负载均衡模式" class="headerlink" title="负载均衡模式"></a>负载均衡模式</h2><p><img src="/2022/09/08/20220908-%E6%88%91%E7%9A%84%E5%87%A0%E5%BC%A0TCP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%89%8B%E7%BB%98%E5%9B%BE/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络寻址原理&quot;&gt;&lt;a href=&quot;#网络寻址原理&quot; class=&quot;headerlink&quot; title=&quot;网络寻址原理&quot;&gt;&lt;/a&gt;网络寻址原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2022/09/08/20220908-%E6%88%91%E7%9A%84%E5%8</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接中的各种状态</title>
    <link href="http://yoursite.com/2022/09/07/20220907-TCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2022/09/07/20220907-TCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81/</id>
    <published>2022-09-07T12:36:01.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/09/07/20220907-TCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><p><img src="/2022/09/07/20220907-TCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81/TCP%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.png"></p><h2 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h2><ul><li>CLOSED：无连接是活动的或正在进行</li><li>LISTEN：服务器在等待进入呼叫</li><li>SYN_RECV：一个连接请求已经到达，等待确认</li><li>SYN_SENT：应用已经开始，打开一个连接</li><li>ESTABLISHED：正常数据传输状态</li><li>FIN_WAIT1：应用说它已经完成</li><li>FIN_WAIT2：另一边已同意释放</li><li>ITMED_WAIT：等待所有分组死掉</li><li>CLOSING：两边同时尝试关闭</li><li>TIME_WAIT：另一边已初始化一个释放</li><li>LAST_ACK：等待所有分组死掉</li></ul><h3 id="flags-标志"><a href="#flags-标志" class="headerlink" title="flags 标志"></a>flags 标志</h3><ul><li>S(SYN)</li><li>F(FIN)</li><li>P(PUSH)</li><li>R(RST)</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机上的TCP连接状态"><a href="#查看主机上的TCP连接状态" class="headerlink" title="查看主机上的TCP连接状态"></a>查看主机上的TCP连接状态</h3><ul><li><code>netstat –an</code></li><li><code>netstat –an |grep &#39;CLOSE_WAIT&#39;</code></li><li><code>ss -t -n|grep 5000</code></li></ul><h3 id="统计当前各种状态的连接的数量的命令"><a href="#统计当前各种状态的连接的数量的命令" class="headerlink" title="统计当前各种状态的连接的数量的命令"></a>统计当前各种状态的连接的数量的命令</h3><ul><li><code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code></li></ul><h3 id="查看指定端口的连接"><a href="#查看指定端口的连接" class="headerlink" title="查看指定端口的连接"></a>查看指定端口的连接</h3><ul><li><code>netstat -an | awk &#39;NR==2 || $4~/65016/&#39;</code>（client）</li><li><code>netstat -an | awk &#39;NR==2 || $5~/8080/&#39;</code>（server）</li></ul><h3 id="Linux-netstat命令详解"><a href="#Linux-netstat命令详解" class="headerlink" title="Linux netstat命令详解"></a>Linux netstat命令详解</h3><ul><li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html</a></li></ul><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><ul><li><p>想知道我们可以通过哪几个网卡抓包，可以使用-D参数 : <code>tcpdump –D</code></p></li><li><p>将抓包结果存放在文件中(可以用Wireshark打开查看) : <code>tcpdump –w google.cap</code></p></li><li><p>其中http协议的数据包都给过滤出来: <code>tcpdump –r google.cap http</code></p></li><li><p><a href="http://www.cnblogs.com/zhuimengle/p/5737848.html">http://www.cnblogs.com/zhuimengle/p/5737848.html</a></p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://elf8848.iteye.com/blog/1739571">TCP&#x2F;IP TIME_WAIT状态原理</a></li></ul><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li><a href="https://blog.csdn.net/yunhua_lee/article/details/40513677">tcp 三次握手和四次断连深入分析：连接状态和socket API的关系</a><ul><li>close函数其实本身不会导致tcp协议栈立刻发送fin包，而只是将socket文件的引用计数减1，当socket文件的引用计数变为0的时候，操作系统会自动关闭tcp连接，此时才会发送fin包。</li><li>这也是多进程编程需要特别注意的一点，父进程中一定要将socket文件描述符close，否则运行一段时间后就可能会出现操作系统提示too many open files</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/09/07/20220907-TCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT解析</title>
    <link href="http://yoursite.com/2022/09/07/20220907-TIME-WAIT%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/07/20220907-TIME-WAIT%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-07T05:30:37.000Z</published>
    <updated>2023-05-07T14:41:07.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/09/07/20220907-TIME-WAIT%E8%A7%A3%E6%9E%90/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpeg"></p><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><ul><li>通信双方建立TCP连接后，主动关闭(FIN)连接的一方就会进入TIME_WAIT状态<ul><li>客户端主动关闭连接时，发送最后一个ack后，会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态</li></ul></li></ul><h2 id="TIME-WAIT状态存在的理由"><a href="#TIME-WAIT状态存在的理由" class="headerlink" title="TIME_WAIT状态存在的理由"></a>TIME_WAIT状态存在的理由</h2><ol><li><p>可靠地实现TCP全双工连接的终止</p><ul><li>TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。</li><li>因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。</li><li>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIMEWAIT状态停留的时间为2倍的MSL。这样可尽可能让TCP再次发送最后的ACK以防这个ACK丢失(另一端超时并重发最后的FIN)。</li><li>总结：尽量避免主动关闭方ack丢失导致被关闭方异常（理论上从应用层看，被关闭方需要对这种异常进行处理，因为万一主动关闭方断电了呢）</li></ul></li><li><p>允许老的重复分节在网络中消逝</p><ul><li>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，基本可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。</li><li>IP包的最大生存时间记录在其TTL字段中，即MSL，超过将过期丢弃</li></ul></li></ol><h2 id="MSL时间"><a href="#MSL时间" class="headerlink" title="MSL时间"></a>MSL时间</h2><ul><li>MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。<br>TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段  </li><li>TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。</li><li>为什么需要2MSL？<ul><li>第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，同时让旧的数据包基本在网络中消失；</li><li>第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失（主要目的）</li><li>问题：重传的FIN报文会重传多少次？<ul><li>重发次数由 tcp_orphan_retries 参数控制</li></ul></li><li>所以如果最后一个ack丢了，且对端又重试发FIN，那么还是无法避免FIN包没过期，所以2MSL只是尽可能，但这时旧的数据包基本消失了</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>TIME_WAIT主动关闭方的状态  </li><li>TIME_WAIT存在的原因<ol><li>防止主动关闭方最后的ACK丢失，确保远程TCP接收到连接中断的请求</li><li>允许老的重复数据包在网络中过期</li></ol></li></ul><h2 id="TIME-WAIT产生的场景"><a href="#TIME-WAIT产生的场景" class="headerlink" title="TIME_WAIT产生的场景"></a>TIME_WAIT产生的场景</h2><ul><li>进入TIME_WAIT状态的一般情况下是客户端。</li><li>大多数服务器端一般执行被动关闭，服务器不会进入TIME_WAIT状态。<br>但在服务器端关闭某个服务再重新启动时，服务器是会进入TIME_WAIT状态的。<br>可以使用SO_REUSEADDR选项来复用端口。</li></ul><pre>举例：1.客户端连接服务器的80服务，这时客户端会启用一个本地的端口访问服务器的80，访问完成后关闭此连接，立刻再次访问服务器的80，这时客户端会启用另一个本地的端口，而不是刚才使用的那个本地端口。原因就是刚才的那个连接还处于TIME_WAIT状态。2.客户端连接服务器的80服务，这时服务器关闭80端口，立即再次重启80端口的服务，这时可能不会成功启动，原因也是服务器的连接还处于TIME_WAIT状态。</pre><h2 id="作为客户端和服务器"><a href="#作为客户端和服务器" class="headerlink" title="作为客户端和服务器"></a>作为客户端和服务器</h2><ol><li>服务端提供服务时，一般监听一个端口就够了；</li><li>客户端则是使用一个本地的空闲端口（大于1024），与服务器的端口建立连接；<ul><li>如果使用短连接请求，那么客户端将会产生大量TIME_WAIT状态的端口（本地最多就能承受6万个TIME_WAIT状态的连接就无端口可用了，后续的短连接就会产生address already in use : connect的异常）</li><li>因此，作为短连接请求的压测服务器，不能在短时间连续使用；</li><li>一般来说一台机器可用Local Port 3万多个，如果是短连接的话，一个连接释放后默认需要60秒回收，30000&#x2F;60 &#x3D;500 这是大概的理论TPS值</li></ul></li><li>一个提供高并发的服务器，同时依赖第三方服务（间接看来服务端也作为第三方服务的客户端），怎么应对 ？<ul><li>一般情况都是启用keepalive选项，避免短连接服务（一般依赖方也不会多达几千个，即调用的ip和端口不一样）</li><li>启用SO_REUSEADDR选项</li></ul></li><li>大多数服务器端一般执行被动关闭，服务器不会进入TIME_WAIT状态</li></ol><h2 id="如何复用TIME-WAIT端口"><a href="#如何复用TIME-WAIT端口" class="headerlink" title="如何复用TIME_WAIT端口"></a>如何复用TIME_WAIT端口</h2><ol><li>应用层发出请求前指定，如何Java HttpClient中设置reuseaddr<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpClient.setHttpRequestRetryHandler(<span class="keyword">new</span> <span class="title class_">DefaultHttpRequestRetryHandler</span>());</span><br><span class="line">httpClient.setReuseStrategy(<span class="keyword">new</span> <span class="title class_">DefaultConnectionReuseStrategy</span>());</span><br><span class="line">httpClient.setKeepAliveStrategy(<span class="keyword">new</span> <span class="title class_">DefaultConnectionKeepAliveStrategy</span>());</span><br></pre></td></tr></table></figure></li><li>调整内核参数（net.ipv4.tcp_tw_reuse）</li></ol><h2 id="总结避免TIME-WAIT的方法"><a href="#总结避免TIME-WAIT的方法" class="headerlink" title="总结避免TIME_WAIT的方法"></a>总结避免TIME_WAIT的方法</h2><ol><li>使用长连接（基本大部分业务场景都可以）</li><li>避免主动关闭</li><li>关闭的时候使用RST的方式 （比如程序中设置socket的SO_LINGER选项）(应用层貌似不是很方便实现)</li><li>TIME_WAIT状态的TCP允许重用</li><li>增大可用端口范围，默认是 net.ipv4.ip_local_port_range &#x3D; 32768 61000 （即对同一个服务器的ip+port可创建28233个连接）（只能缓解问题，不能根本解决问题）</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.iteye.com/blog/elf8848-1739571">TCP&#x2F;IP TIME_WAIT状态原理</a></li><li><a href="https://blog.51cto.com/kerry/105233">发现大量的TIME_WAIT解决办法</a></li><li>[《TCP IP详解卷一》18.6.1]</li><li><a href="https://mp.weixin.qq.com/s/LNWv5I-klJCBCX4e84WbTQ">为什么 TCP 协议有 TIME_WAIT 状态</a></li><li><a href="https://www.cnblogs.com/joker1937/articles/12487776.html">TCP四次挥手为何需要TIME_WAIT以及为何是2MSL？</a></li><li><a href="https://zhuanlan.zhihu.com/p/398890723">TCP 才不傻：三次握手和四次挥手的异常处理</a></li><li><a href="https://www.helloworld.net/p/4875307437">tcp短连接TIME_WAIT问题解决方法大全</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/09/07/20220907-TIME-WAIT%E8%A7%A3%E6%9E%90/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TIME-WAIT&quot;&gt;&lt;a href=&quot;#T</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="TIME_WAIT" scheme="http://yoursite.com/tags/TIME-WAIT/"/>
    
  </entry>
  
  <entry>
    <title>你记得设置TCP_NODEPLAY吗？</title>
    <link href="http://yoursite.com/2022/09/07/20220907-%E4%BD%A0%E8%AE%B0%E5%BE%97%E8%AE%BE%E7%BD%AETCP-NODEPLAY%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/09/07/20220907-%E4%BD%A0%E8%AE%B0%E5%BE%97%E8%AE%BE%E7%BD%AETCP-NODEPLAY%E5%90%97%EF%BC%9F/</id>
    <published>2022-09-07T05:26:22.000Z</published>
    <updated>2023-05-07T14:41:07.793Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>有接触过TCP服务器实现的同学都会知道，需要注意TCP_NODELAY参数，为什么呢？</p></li><li><p>若没有开启TCP_NODELAY，那么在发送小包的时候，可能会出现这样的现象：<br>通过 TCP socket 分多次发送较少的数据时，比如小于 1460 或者 100 以内，对端可能会很长时间收不到数据，导致本端应用程序认为超时报错。</p></li></ul><h2 id="Nagle算法（Nagle‘s-Algorithm）"><a href="#Nagle算法（Nagle‘s-Algorithm）" class="headerlink" title="Nagle算法（Nagle‘s Algorithm）"></a>Nagle算法（Nagle‘s Algorithm）</h2><ul><li><p>TCP&#x2F;IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP&#x2F;IP希望每次都能够以MSS尺寸的数据块来发送数据）。</p></li><li><p>Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p></li><li><p>Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p></li><li><p>举个例子，一开始client端调用socket的write操作将一个int型数据(称为A块)写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入一个int型数据（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后）(ACK延迟机制的超时时间)，B块才被发送。</p></li><li><p>Nagle算法的改进在于：如果发送端欲多次发送包含少量字符的数据包（一般情况下，后面统一称长度小于MSS的数据包为小包，与此相对，称长度等于MSS的数据包为大包，为了某些对比说明，还有中包，即长度比小包长，但又不足一个MSS的包），则发送端会先将第一个小包发送出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据，或者积攒到了一定数量的数据（比如缓存的字符数据已经达到数据包报文段的最大长度）等多种情况才将其组成一个较大的数据包发送出去。<br> TCP在三次握手建立连接过程中，会在SYN报文中使用MSS（Maximum Segment Size）选项功能，协商交互双方能够接收的最大段长MSS值。</p></li></ul><h2 id="ACK延迟机制-TCP-Delayed-Acknoledgement"><a href="#ACK延迟机制-TCP-Delayed-Acknoledgement" class="headerlink" title="ACK延迟机制(TCP Delayed Acknoledgement)"></a>ACK延迟机制(TCP Delayed Acknoledgement)</h2><ul><li>TCP&#x2F;IP中不仅仅有Nagle算法(Nagle‘s Algorithm)，还有一个ACK延迟机制(TCP Delayed Ack) 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。</li><li>也就是如果一个 TCP 连接的一端启用了Nagle算法，而另一端启用了ACK延时机制，而发送的数据包又比较小，则可能会出现这样的情况：发送端在等待接收端对上一个packet的Ack才发送当前的packet，而接收端则正好延迟了此Ack的发送，那么这个正要被发送的packet就会同样被延迟。当然Delayed Ack是有个超时机制的，而默认的超时正好就是40ms。</li><li>现代的 TCP&#x2F;IP 协议栈实现，默认几乎都启用了这两个功能，那岂不每次都会触发这个延迟问题？事实不是那样的。仅当协议的交互是发送端连续发送两个packet，然后立刻read的时候才会出现问题。</li></ul><h2 id="总结：问题出现的三个条件"><a href="#总结：问题出现的三个条件" class="headerlink" title="总结：问题出现的三个条件"></a>总结：问题出现的三个条件</h2><ol><li>发送小包（仅当协议的交互是发送端连续发送两个 packet，然后立刻 read 的 时候才会出现问题。）</li><li>发送方启用了Nagle算法（发送方未接收到上一个包的ack，且待发送的是小包，则会等待）</li><li>接收方启用了ACK延时机制 且没及时准备好数据（希望响应ack可以和响应的数据一起发送，等待本端响应数据的准备）</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>开启TCP_NODELAY：禁用Nagle算法，禁止后当然就不会有它引起的一系列问题了。</li><li>优化协议：连续 write 小数据包，然后 read 其实是一个不好的网络编程模式，这样的连续 write 其实应该在应用层合并成一次 write。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="另一个问题的例子-HTTP服务"><a href="#另一个问题的例子-HTTP服务" class="headerlink" title="另一个问题的例子(HTTP服务)"></a>另一个问题的例子(HTTP服务)</h3><ul><li><p><a href="https://cloud.tencent.com/developer/article/1621142">神秘的40毫秒延迟与TCP_NODELAY</a></p></li><li><p>接口响应时间在client端开启keepalive后连续请求时由0ms变成40ms</p></li><li><p>因为设计的一些不足，我没能做到把 短小的 HTTP Body 连同 HTTP Headers 一起发送出去，而是分开成两次调用实 现的，之后进入 epoll_wait 等待下一个 Request 被发送过来（相当于阻塞模 型里直接 read）。正好是 write-write-read 的模式</p></li><li><p>那么 write-read-write-read 会不会出问题呢？维基百科上的解释是不会：</p><ul><li>“The user-level solution is to avoid write-write-read sequences on sockets. write-read-write-read is fine. write-write-write is fine. But write-write-read is a killer. So, if you can, buffer up your little writes to TCP and send them all at once. Using the standard UNIX I&#x2F;O package and flushing write before each read usually works.”</li><li>我的理解是这样的：因为第一个 write 不会被缓冲，会立刻到达接收端，如果是 write-read-write-read 模式，此时接收端应该已经得到所有需要的数据以进行 下一步处理。接收端此时处理完后发送结果，同时也就可以把上一个packet 的 Ack 可以和数据一起发送回去，不需要 delay，从而不会导致任何问题。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/majianfei1023/article/details/51558941">TCP_NODELAY和Nagle算法</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有接触过TCP服务器实现的同学都会知道，需要注意TCP_NODELAY参数，为什么呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若没有开启TCP_NODELAY，那么在发送小包的时候，可能会出现这样的现象：&lt;br&gt;通过 TCP socket 分多次发送较少的数据</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="TCP_NODELAY" scheme="http://yoursite.com/tags/TCP-NODELAY/"/>
    
  </entry>
  
  <entry>
    <title>有了TCP的keepalive，应用层还需要实现保活逻辑吗？</title>
    <link href="http://yoursite.com/2022/09/06/20220906-%E6%9C%89%E4%BA%86TCP%E7%9A%84keepalive%EF%BC%8C%E5%BA%94%E7%94%A8%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BF%9D%E6%B4%BB%E9%80%BB%E8%BE%91%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/09/06/20220906-%E6%9C%89%E4%BA%86TCP%E7%9A%84keepalive%EF%BC%8C%E5%BA%94%E7%94%A8%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BF%9D%E6%B4%BB%E9%80%BB%E8%BE%91%E5%90%97%EF%BC%9F/</id>
    <published>2022-09-06T14:02:39.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>对于实时性高的业务，基本都需要在应用层自行实现保活逻辑，应用层的心跳协议是必不可少的</li></ul><h2 id="TCP-keepalive-的-问题"><a href="#TCP-keepalive-的-问题" class="headerlink" title="TCP keepalive 的 问题"></a>TCP keepalive 的 问题</h2><ol><li>检测周期长，开启后默认是2h（系统内核参数 tcp_keepalive_time），这就意味着服务端可能维持着一个死连接；</li><li>TCP keepalive 是由操作系统负责探查，即便进程死锁，或阻塞等，操作系统也会收发 TCP keepalive 消息，无法及时感知客户端已经实际已经下线；</li></ol><h2 id="应用层实现心跳的基本做法"><a href="#应用层实现心跳的基本做法" class="headerlink" title="应用层实现心跳的基本做法"></a>应用层实现心跳的基本做法</h2><ol><li>服务端和客户端都开启tcp keepalive</li><li>客户端定时发心跳包到服务端</li><li>服务端根据自定义的规则，在一定时间内收不到心跳包的时，断开客户端的连接。</li></ol><h2 id="应用层实现心跳保活逻辑的好处"><a href="#应用层实现心跳保活逻辑的好处" class="headerlink" title="应用层实现心跳保活逻辑的好处"></a>应用层实现心跳保活逻辑的好处</h2><ol><li>可以在发送心跳包的同时顺带业务或指令数据，这样服务端获得客户端的详细状态，同时可以更好满足业务场景</li><li>可以灵活控制探查客户端的时间和策略，更快下线有异常的连接，减少服务端不必要的负担</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.zhihu.com/question/35013918">在以TCP为连接方式的服务器中，为什么在服务端设计当中需要考虑心跳？</a></li><li><a href="https://www.felix021.com/blog/read.php?2076">闲说HeartBeat心跳包和TCP协议的KeepAlive机制</a></li><li><a href="http://www.nowamagic.net/academy/detail/23350382">TCP协议的KeepAlive机制与HeartBeat心跳包</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于实时性高的业务，基本都需要在应用层自行实现保活逻辑，应用层的心跳协议是必不可少的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TC</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
    <category term="keepalive" scheme="http://yoursite.com/tags/keepalive/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP相关协议的一些总结</title>
    <link href="http://yoursite.com/2022/09/05/20220905-%E5%85%B3%E4%BA%8EHTTP%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/09/05/20220905-%E5%85%B3%E4%BA%8EHTTP%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2022-09-05T14:01:12.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="粗浅概括"><a href="#粗浅概括" class="headerlink" title="粗浅概括"></a>粗浅概括</h2><ul><li>HTTP - TCP</li><li>HTTPS - TCP + TLS </li><li>SPDY -&gt; TCP + TLS + 多路复用、头部压缩等特性 –&gt; 发展成 HTTP&#x2F;2<ul><li>SPDY是Speedy的音，是更快的意思</li></ul></li><li>HTTP&#x2F;2 - TCP + TLS(理论上可选) + 多路复用、头部压缩等特性</li><li>QUIC - UDP –&gt; 发展成 HTTP&#x2F;3</li><li>HTTP&#x2F;3 - UDP</li></ul><h2 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h2><ul><li>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>请求-响应模式（半双工）</li></ul><ul><li>安全问题</li></ul><h3 id="“队头堵塞”-（线头阻塞）（Head-of-line-blocking）（HOLB）"><a href="#“队头堵塞”-（线头阻塞）（Head-of-line-blocking）（HOLB）" class="headerlink" title="“队头堵塞” （线头阻塞）（Head-of-line blocking）（HOLB）"></a>“队头堵塞” （线头阻塞）（Head-of-line blocking）（HOLB）</h3><ul><li>HTTP 1.1 默认启用长TCP连接，但所有的请求-响应都是按序进行的(串行发送和接收)</li><li>HTTP 1.1 的管道机制：客户端可以同时发送多个请求，但服务端也需要按请求的顺序依次给出响应的；</li><li>客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求(排队等待)，这称为”队头堵塞”</li></ul><h3 id="管道机制-Pipelining"><a href="#管道机制-Pipelining" class="headerlink" title="管道机制(Pipelining)"></a>管道机制(Pipelining)</h3><ul><li>在管道机制下，服务端如何控制按顺序返回响应的？<ul><li>HTTP是应用层协议，当然由各个应用程序按照规范自行实现了</li><li>比如使用nginx，或jetty等，若服务端需要支持管道机制，都要底层逻辑自行实现，避免暴露给业务层</li><li>那么因为要按顺序响应，那么当最前的请求的处理较慢时，同样会对服务端产生阻塞。</li></ul></li><li>Pipelining需要客户端和服务端同时支持</li><li>几乎所有的浏览器都是默认关闭或者不支持Pipelining的：对性能的提高有限、大文件会阻塞优先级更高的小文件等</li><li>只有GET和HEAD要求可以进行管线化，而POST则有所限制</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li><p>HTTPS（HTTP over TLS&#x2F;SSL）,TLS&#x2F;SSL(会话层)</p></li><li><p>SSL（Secure Socket Layer）是安全套接层，TLS（Transport Layer Security）是传输层安全协议，建立在SSL3.0协议规范，是 SSL3.0 的后续版本。</p></li><li><p>TLS可以用在TCP上，也可以用在无连接的UDP报文上。协议规定了身份认证、算法协商、密钥交换等的实现。</p></li><li><p>SSL是TLS的前身，现在已不再更新</p></li></ul><h3 id="jks、pfx和cer-证书文件"><a href="#jks、pfx和cer-证书文件" class="headerlink" title="jks、pfx和cer 证书文件"></a>jks、pfx和cer 证书文件</h3><ul><li>jks是JAVA的keytools证书工具支持的证书私钥格式。</li><li>pfx是微软支持的私钥格式。</li><li>cer是证书的公钥。</li></ul><h3 id="权威证书颁发的公钥匙一般是预装的"><a href="#权威证书颁发的公钥匙一般是预装的" class="headerlink" title="权威证书颁发的公钥匙一般是预装的"></a>权威证书颁发的公钥匙一般是预装的</h3><ul><li><p><a href="https://www.cnblogs.com/yungyu16/p/13329305.html">SSL&#x2F;TLS协议详解(中)——证书颁发机构</a></p></li><li><p>当我们安装浏览器或操作系统时，将会附有一组证书颁发机构，例如DigiCert。当浏览器自带DigiCert时，这意味着浏览器具有DigiCert的公钥，网站可以向DigiCert索取证书和签名。因此，DigiCert将使用DigiCerts私钥在服务器证书上进行加密签名。当我们发起连接时，服务器将发送嵌入了其公钥的证书。由于浏览器具有DigiCert的公钥，因此可以在服务器证书上验证DigiCert的签名，同时也说明证书上写的服务器的公钥是可信的。</p></li><li><p>根据RSA的加密原理，如果用CA的公钥解密成功，说明该证书的确是用CA的私钥加密的，可以认为被验证方是可信的。</p></li></ul><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><ul><li>全双工</li><li>二进制格式传输、多路复用、header压缩、服务端推送、优先级和依赖关系、重置、流量控制</li></ul><h3 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用(Multiplexing)"></a>多路复用(Multiplexing)</h3><ul><li>客户端发送多个请求和服务端给出多个响应的顺序不受限制, 避免”队头堵塞” </li><li>每个数据流都有一个唯一的编号，从而让请求和响应对应起来</li><li>客户端和服务器 可以发生信号取消某个数据流，并保持这个连接</li><li>客户端还可以提升提升某个数据流优先级</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>HTTP&#x2F;2 沒规定一定要使用加密（例如 SSL），但目前大部分浏览器的 HTTP&#x2F;2 都需要在 HTTPs上运行</li><li>gRPC 虽然使用 HTTP&#x2F;2，但默认并没有需要配置加密证书</li></ul><h3 id="重用连接（针对浏览器）"><a href="#重用连接（针对浏览器）" class="headerlink" title="重用连接（针对浏览器）"></a>重用连接（针对浏览器）</h3><ul><li>使用HTTP1.1协议，浏览器为了快速，针对同一域名设置了一定的并发数，稍微加快速度</li><li>使用HTTP&#x2F;2，浏览器针对同一个域名的资源，只建立一个tcp连接通道</li></ul><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul><li>头部压缩也存在一些缺点 ，不管是Client还是Server，都要维护索引表，以确定每个索引值对应HTTP header的信息，通过占用更多内存换取数据量传输的减少（空间换时间）。</li></ul><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul><li><a href="https://mp.weixin.qq.com/s/OyogMagLsm2jh2pgg0Symw">Chrome将禁用HTTP&#x2F;2服务器推送（Server Push）支持</a><ul><li>这功能逻辑本身就有问题，比如资源存放在单个业务服务器上，并行推送多个静态资源只会降低响应速度，性能不升反降。而对于前后端分离的业务来说，HTTP&#x2F;2 本身就支持多路复用，server push 只能稍微降低浏览器解析 html 的时间，对现代浏览器来说性能提升可以忽略不计。</li></ul></li></ul><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul><li><p>HTTP&#x2F;1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</p></li><li><p>HTTP&#x2F;2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</p></li><li><p>QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</p></li><li><p>HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成：HTTP3.0基于UDP的安全可靠的HTTP2.0协议。</p></li><li><p>在网络条件较差的情况下，HTTP&#x2F;3在增强网页浏览体验方面的效果非常好 </p></li><li><p>TCP从来就不适合处理有损无线环境中的数据传输</p></li><li><p>TCP中的行头阻塞</p></li></ul><h3 id="TCP的限制"><a href="#TCP的限制" class="headerlink" title="TCP的限制"></a>TCP的限制</h3><ol><li>TCP可能会间歇性地挂起数据传输<ul><li>TCP流的行头阻塞（HoL）: 序列号较低的数据段丢包问题，导致阻塞</li></ul></li><li>TCP不支持流级复用</li><li>TCP会产生冗余通信<ul><li>TCP连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。</li></ul></li></ol><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul><li>选择UDP作为底层传输层协议。抛弃TCP的缺点（TCP传输确认、重传慢启动等），同时。此外QUIC是用户层协议，不需要每次协议升级时修改内核；</li><li>流复用和流控：解决了行头阻塞问题。</li><li>灵活的拥塞控制机制、更好的错误处理能力、更快的握手</li><li>新的HTTP头压缩机制，称为QPACK，是对HTTP&#x2F;2中使用的HPACK的增强（QUIC流是不按顺序传递的，在不同的流中可能包含不同的HTTP头）</li></ul><h3 id="采用HTTP-x2F-3的限制"><a href="#采用HTTP-x2F-3的限制" class="headerlink" title="采用HTTP&#x2F;3的限制"></a>采用HTTP&#x2F;3的限制</h3><ul><li>不仅涉及到应用层的变化，还涉及到底层传输层的变化</li><li>UDP会话会被防火墙的默认数据包过滤策略所影响</li><li>中间层，如防火墙、代理、NAT设备等需要兼容</li><li>需迫使中间层厂商标准化</li><li>HTTP&#x2F;3在现有的UDP之上，以QUIC的形式在传输层处理，增加了HTTP&#x2F;3在整个协议栈中的占用空间。这使得HTTP&#x2F;3较为笨重，不适合某些IoT设备</li><li>NGINX和Apache等主流web服务器需要支持</li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="HTTP-与-TCP-backlog关系"><a href="#HTTP-与-TCP-backlog关系" class="headerlink" title="HTTP 与 TCP backlog关系"></a>HTTP 与 TCP backlog关系</h3><ol><li>没直接关系</li><li>HTTP是应用层协议，TCP backlog 是应用程序在操作系统层接收tcp连接的队列数</li><li>比如tomcat，作为一个HTTP应用服务，TCP backlog对应其acceptCount的配置</li></ol><h3 id="关于-HTTP-keepalive"><a href="#关于-HTTP-keepalive" class="headerlink" title="关于 HTTP keepalive"></a>关于 HTTP keepalive</h3><ul><li><p>要利用HTTP的keep-alive机制，需要服务器端和客户端同时支持</p></li><li><p>HTTP是应用层协议，具体的表现行为取决于HTTP服务器以及HTTP client的实现</p></li><li><p><a href="https://blog.csdn.net/Kingson_Wu/article/details/72512825">wireshark抓包简单查看HTTP keep-alive原理</a></p></li><li><p><a href="https://blog.csdn.net/Kingson_Wu/article/details/80102077">继续深入理解HTTP keepalive</a></p></li></ul><ol><li>keepalive 是否开启服务端控制还是客户端控制？<ul><li>keepalive可以由双方共同控制，需要双方都开启才能生效，HTTP1.1客户端默认开启，客户端想关闭可以通过设置Connection: Close，服务端同样想关闭可以设置Connection: Close。双方哪方先收到Connection: Close 则由收到方关闭（前提是双方的实现都支持，比如telnet就不支持）</li></ul></li><li>keepalive的时间是由服务端控制还是客户端控制？<ul><li>时间主要还是由服务端控制，时间一到由服务端主动关闭，当然客户端如果有实现设置一定时间后，由客户端主动关闭也可以。一般的HTTPclient库都有提供相应的配置，设置关闭长期不使用的连接，如connectionManager.closeIdleConnections(readTimeout * 2, TimeUnit.MILLISECONDS);</li><li><a href="https://my.oschina.net/greki/blog/83350">HTTPs://my.oschina.net/greki/blog/83350</a></li></ul></li><li>keepalive时间一到，是由客户端主动关闭还是服务端主动关闭？<ul><li>哪方的时间短，由哪一方来关闭，除非双方的实现有更明确的协议</li></ul></li><li>如果客户端不是HTTPclient，使用telnet连接服务端？<ul><li>telnet客户端除了连接时进行三次握手，用来发送数据接收数据，基本无其他实现逻辑。即接收到服务器的响应之后，不会有相关HTTP协议的处理。</li></ul></li></ol><h3 id="HTTP-keepalive-VS-TCP-keepalive"><a href="#HTTP-keepalive-VS-TCP-keepalive" class="headerlink" title="HTTP keepalive VS TCP keepalive"></a>HTTP keepalive VS TCP keepalive</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/385597183">HTTPs://zhuanlan.zhihu.com/p/385597183</a>; <a href="https://juejin.cn/post/6992845852192702477">HTTPs://juejin.cn/post/6992845852192702477</a></li><li>HTTP 的 Keep-Alive，是由应用层（用户态）  实现的，称为 HTTP 长连接；</li><li>TCP 的 Keepalive，是由 TCP 层（内核态）  实现的，称为 TCP 保活机制；</li><li>HTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求&#x2F;响应。</li><li>TCP的KeepAlive机制意图在于保活、心跳，检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。</li><li>tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而HTTP的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。</li><li>总之，HTTP的Keep-Alive和TCP的KeepAlive不是一回事。</li></ul><h3 id="Chrome中HTTP下载续传原理"><a href="#Chrome中HTTP下载续传原理" class="headerlink" title="Chrome中HTTP下载续传原理"></a>Chrome中HTTP下载续传原理</h3><ul><li><a href="https://kingson4wu.github.io/2022/08/30/20220830-Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%9A%82%E5%81%9C%E5%92%8C%E7%BB%A7%E7%BB%AD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/">Chrome下载文件时暂停和继续是什么原理？</a></li></ul><h3 id="HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？"><a href="#HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？" class="headerlink" title="HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？"></a>HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？</h3><ul><li>“队头堵塞”（Head-of-line blocking）：所有的请求-响应都是按序进行的（HTTP）</li><li>多路复用(Multiplexing)：每个数据流都有一个唯一的编号，从而让请求和响应对应起来（HTTP&#x2F;2）</li></ul><h3 id="可以外网使用HTTP-x2F-3，再转发到内网的HTTP服务？"><a href="#可以外网使用HTTP-x2F-3，再转发到内网的HTTP服务？" class="headerlink" title="可以外网使用HTTP&#x2F;3，再转发到内网的HTTP服务？"></a>可以外网使用HTTP&#x2F;3，再转发到内网的HTTP服务？</h3><ul><li>上层nginx使用HTTP3，下层应用服务器（如spring boot jetty等）还是使用HTTP，其实理论上是可以的。nginx转发时要由接受到的udp包改成tcp发送。（内网丢包概率一般应该比外网丢包低很多），如果采用这种转发方式，这就意味着内网无法使用四层负载转发，因为底层协议不一样（udp和tcp）</li><li>现在主流的代理服务Nginx&#x2F;Apache都没有实现QUIC，一些比较小众的代理服务如Caddy就实现了</li></ul><h3 id="使用HTTPS还存在中间人攻击？"><a href="#使用HTTPS还存在中间人攻击？" class="headerlink" title="使用HTTPS还存在中间人攻击？"></a>使用HTTPS还存在中间人攻击？</h3><ul><li><p>结论：可以避免。只要不信任不安全的HTTPs网站，就不会被中间人攻击</p></li><li><p>中间人攻击:<a href="https://urlify.cn/zQj6f2">HTTPs://urlify.cn/zQj6f2</a></p></li><li><p>既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？<br>其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。</p></li><li><p>只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。</p></li></ul><pre>Q: 为什么需要证书？A: 防止”中间人“攻击，同时可以为网站提供身份证明。Q: 使用 HTTPS 会被抓包吗？A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</pre> <h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="cURL-发-HTTP-x2F-2请求"><a href="#cURL-发-HTTP-x2F-2请求" class="headerlink" title="cURL 发 HTTP&#x2F;2请求"></a>cURL 发 HTTP&#x2F;2请求</h3><ol><li>Mac OS Curl HTTP&#x2F;2 支持<br><code> brew install curl --with-ngHTTP2</code></li></ol><pre>/usr/local/Cellar/curl/7.50.3/bin/curl --HTTP2 -kI  HTTPs://localhost:8443/user/1HTTP/2 200server: Jetty(9.3.10.v20160621)date: Sun, 30 Oct 2016 02:08:46 GMTcontent-type: application/json;charset=UTF-8content-length: 23</pre><ol start="2"><li>linux:<a href="https://www.sysgeek.cn/curl-with-HTTP2-support/">HTTPs://www.sysgeek.cn/curl-with-HTTP2-support/</a></li></ol><h3 id="HTTP-x2F-3-握手优化"><a href="#HTTP-x2F-3-握手优化" class="headerlink" title="HTTP&#x2F;3 握手优化"></a>HTTP&#x2F;3 握手优化</h3><ul><li>1倍时延 &#x3D; 一次单向传输时延 &#x3D; 0.5 RTT</li><li><a href="https://mp.weixin.qq.com/s/Xo9HgZXfn28VibIE9OFHqw">HTTPS 的 7 次握手以及 9 倍时延</a></li><li>HTTPS: 7 次握手以及 9 倍时延 (4.5 RTT); HTTP&#x2F;3: 3 次握手以及 5 倍时延 (2.5 RTT)<pre>当客户端想要通过 HTTPS 请求访问服务端时，整个过程需要经过 7 次握手并消耗 9 倍的延迟。如果客户端和服务端因为物理距离上的限制，RTT 约为 40ms 时，第一次请求需要 ~180ms；不过如果我们想要访问美国的服务器，RTT 约为 200ms 时，这时 HTTPS 请求的耗时为 ~900ms，这就是一个比较高的耗时了。我们来总结一下 HTTPS 协议需要 9 倍时延才能完成通信的原因：</pre></li></ul><p>TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）；<br>TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）；<br>HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）；<br>需要注意的是，本文对往返延时的计算都基于特定的场景以及特定的协议版本，网络协议的版本在不断更新和演进，过去忽略的问题最开始都会通过补丁的方式更新，但是最后仍然会需要从底层完成重写。</p><p>HTTP&#x2F;3 就是一个这样的例子，它会使用基于 UDP 的 QUIC 协议进行握手，将 TCP 和 TLS 的握手过程结合起来，把 7 次握手减少到了 3 次握手，直接建立了可靠并且安全的传输通道，将原本 ~900ms 的耗时降低至 ~500ms，<br></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/XiongMaoMengNan/p/8425724.html">HTTP协议篇(一)：多路复用、数据流</a></li><li><a href="https://developer.aliyun.com/article/436989">HTTP管线化(HTTP pipelining)</a></li><li><a href="https://imququ.com/post/HTTP2-resource.html">HTTP&#x2F;2 资料汇总</a></li><li><a href="https://www.codetd.com/article/10088188">HTTP，HTTPs，spdy，HTTP2等协议的主要区别详解</a></li><li><a href="https://www.infoq.cn/article/IgME_4ebP3d46m3tHbaT">一文看完 HTTP3 的演化历程</a></li><li><a href="https://mp.weixin.qq.com/s/i-QUbVRVicqzMSZ9FUVCfQ">深入解读HTTP3的原理及应用</a></li><li><a href="https://urlify.cn/zQj6f2">HTTPS 原理分析——带着疑问层层深入</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;粗浅概括&quot;&gt;&lt;a href=&quot;#粗浅概括&quot; class=&quot;headerlink&quot; title=&quot;粗浅概括&quot;&gt;&lt;/a&gt;粗浅概括&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP - TCP&lt;/li&gt;
&lt;li&gt;HTTPS - TCP + TLS &lt;/li&gt;
&lt;li&gt;SPDY -&amp;g</summary>
      
    
    
    
    
    <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
    <category term="HTTP/3" scheme="http://yoursite.com/tags/HTTP-3/"/>
    
    <category term="HTTP/2" scheme="http://yoursite.com/tags/HTTP-2/"/>
    
    <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Chrome下载文件时暂停和继续是什么原理？</title>
    <link href="http://yoursite.com/2022/08/30/20220830-Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%9A%82%E5%81%9C%E5%92%8C%E7%BB%A7%E7%BB%AD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/08/30/20220830-Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%9A%82%E5%81%9C%E5%92%8C%E7%BB%A7%E7%BB%AD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/</id>
    <published>2022-08-30T04:02:05.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这个问题很久前就研究过了，觉得挺有意思，这里总结记录一下</li><li>所有的文字整理来源于: <a href="https://bbs.csdn.net/topics/392163074">https://bbs.csdn.net/topics/392163074</a>,感谢wjyiooo的耐心解答</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>Range，是在 HTTP&#x2F;1.1（<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html%EF%BC%89%E9%87%8C%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%80%E4%B8%AA">http://www.w3.org/Protocols/rfc2616/rfc2616.html）里新增的一个</a> header field，也是现在众多号称多线程下载工具（如 FlashGet、迅雷等）实现多线程下载的核心所在。</li></ul><h2 id="chrome-版本58"><a href="#chrome-版本58" class="headerlink" title="chrome 版本58"></a>chrome 版本58</h2><ol><li>抓包确认，chrome点击暂停的时候会发送一系列窗口变动应答，将窗口降到5，并且不再应答ACK包。 当点击恢复的时候只是重新发送ACK给服务器，同时将窗口重新设置为256。</li><li>以上可以确认它的“续传”只是利用TCP滑动窗口的特性，跟断不断网没关系，也不属于真正意义的断点续传功能（一般用range头部实现）。当然如果你中断网络超过了服务器的TCP连接超时时间那么就不能续传了，而且如果关闭浏览器即使网络非常正常也不能续传（也是因为TCP连接断了）。</li><li>在等待足够长时间让TCP连接关掉后，chrome就可以断点续传了，原理也是头部带range。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>本地有临时下载文件</li><li>短时间内点继续，利用的是TCP滑动窗口的特性（与服务器未断开）</li><li>长时间之后点继续，再次发请求，带range头，继续下载剩余部分（与服务器断开）</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用Range进行多线程下载"><a href="#使用Range进行多线程下载" class="headerlink" title="使用Range进行多线程下载"></a>使用Range进行多线程下载</h3><ul><li>Http 请求头 Range:<a href="https://www.cnblogs.com/1995hxt/p/5692050.html">https://www.cnblogs.com/1995hxt/p/5692050.html</a></li></ul><ol><li>curl -H “Range: bytes&#x3D;0-1551” <a href="http://127.0.0.1:8180/bg-upper.png">http://127.0.0.1:8180/bg-upper.png</a> -v -o 0-1151.png</li><li>curl -H “Range: bytes&#x3D;1552-3103” <a href="http://127.0.0.1:8180/bg-upper.png">http://127.0.0.1:8180/bg-upper.png</a> -v -o 1552-end.png</li><li>合并 cat 0-1151.png 1552-end.png &gt; filename.png</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;这个问题很久前就研究过了，觉得挺有意思，这里总结记录一下&lt;/li&gt;
&lt;li&gt;所有的文字整理来源于: &lt;a href=&quot;https://bbs.csdn.net/topics/392163074&quot;&gt;https://bbs.csdn.net/topics/39216</summary>
      
    
    
    
    
    <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
    <category term="Range" scheme="http://yoursite.com/tags/Range/"/>
    
    <category term="断点续传" scheme="http://yoursite.com/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>推送技术总结</title>
    <link href="http://yoursite.com/2022/08/05/20220805-%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/08/05/20220805-%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-05T13:57:59.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>从客户端是手机APP的角度来理解推送（PUSH），展示的形式有两种：</p><ol><li>App 推送：消息内容通过手机通知栏（状态栏）展示</li><li>应用内消息：各种业务数据推送（通过定义模版或命令号等方式推送给APP内的业务使用）</li></ol></li><li><p>从Web端角度看理解推送，一般只有网页内消息（跟手机APP的应用内消息是一样的类型）  </p></li><li><p>APP推送：</p><ol><li>在线推送（应用级方案）：APP进程控制推送消息，理论上只要APP要获得“手机通知栏”的权限（一般通过在APP内维持长连接来进行推送，但前提是APP已经启动和运行，并且能常驻）</li><li>离线推送（系统级方案）：通过手机操作系统或手机厂商提供的通道进行推送。这种推送方式可以在APP未启动的情况下，推送APP的消息。</li><li>APP进程运行时，应该优先走在线推送，自己的推送系统更快、更有保障。</li></ol></li><li><p>应用场景</p><ul><li>APP推送：电商内APP（推送促销消息）</li><li>应用内消息：直播类APP（推送送礼特效消息）</li><li>APP推送和应用内消息都需要：IM类APP（推送用户聊天信息）</li></ul></li><li><p>从推送的实现角度看，基本可以概括为两种：主动轮询（pull 拉）和长连接 （push 推）</p></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>以下实现方式没有进行严格分类，从原理上看存在相互联系</li></ul><ol><li><p>HTTP轮询</p><ol><li>短轮询（Polling）</li><li>长轮询（Long-polling）(Nacos和apollo配置中心也是用这种)</li></ol><ul><li>从TCP的角度看HTTP长轮询：HTTP开启keepalive，服务端保持连接并不需要发额外数据包，有数据时可以立刻推送，跟TCP长连推送无异。展示服务端有点费连接的相关资源，数据包是HTTP相比较大而已。</li></ul></li><li><p>SSE (Server Sent Event 服务器发送事件)</p><ul><li>sse 单通道，只能服务端向客户端发消息； webscoket 是双通道</li><li>实现成本较低</li><li>http 协议，服务端响应的是text&#x2F;event-stream类型的数据流信息</li><li>场景：站内信、未读消息数、状态更新、股票行情、监控数量等场景</li></ul></li><li><p>WebSocket</p></li><li><p>MQTT （通常结合TCP长连接一起使用）</p></li><li><p>TCP长连接（自定义消息或protobuf等格式）</p></li><li><p>系统级方案</p><ul><li>Android和IOS本身的消息推送（Android的C2DM和IOS的APNS，系统与服务器建立连接，APP向系统注册关注的消息，实现系统级消息推送）</li><li>国内Android无法访问Google服务器，所以国内的手机厂商比如小米、OPPO、华为等，都实现来各自的系统级推送。</li><li>避免维持长连接而导致的过多资源消耗，IM类要求即时的更应该接系统级推送</li></ul></li><li><p>第三方推送平台</p><ul><li>集成各种手机平台，各种推送类型，甚至短信等推送</li><li>简单来说：由专业的平台做专业的事（太麻烦了，我只是想推送了消息，帮我搞定吧。。。）</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://mp.weixin.qq.com/s/wIs5wi7rf0RFFGl7sR3J8g">7种 实现web实时消息推送的方案</a></li><li><a href="https://www.cnblogs.com/yihuihui/p/12622729.html">SSE 服务器发送事件详解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从客户端是手机APP的角度来理解推送（PUSH），展示的形式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App 推送：消息内容通过</summary>
      
    
    
    
    
    <category term="PUSH" scheme="http://yoursite.com/tags/PUSH/"/>
    
  </entry>
  
  <entry>
    <title>说说CDN</title>
    <link href="http://yoursite.com/2022/08/02/20220802-%E8%AF%B4%E8%AF%B4CDN/"/>
    <id>http://yoursite.com/2022/08/02/20220802-%E8%AF%B4%E8%AF%B4CDN/</id>
    <published>2022-08-02T13:54:30.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li>CDN（Content Delivery Network）（内容分发网络）：提供内容给用户就近访问</li></ul><h2 id="CDN域名解析流程"><a href="#CDN域名解析流程" class="headerlink" title="CDN域名解析流程"></a>CDN域名解析流程</h2><ul><li>浏览器发起HTTP请求到本地DNS服务器，本地DNS服务器使用CNAME的方式，将资源域名重定向到CDN服务</li></ul><ol><li>用户机器（比如浏览器）-&gt; LocalDNS</li><li>LocalDNS -&gt; 域名授权DNS服务 (返回域名CNAME)</li><li>LocalDNS -&gt; 请求CNAME域名（重新走域名解析流程，DNS根服务器，域服务器等）（返回CNAME对应的ip）</li><li>LocalDNS -&gt; CNAME对应的CDN服务器（CDN策略，查找出最佳的CDN节点的IP地址）</li><li>LocalDNS返回CDN节点IP地址给浏览器</li><li>用户机器（比如浏览器）-&gt; CDN节点（若无缓存）</li><li>CDN节点 -&gt; 回源服务器拉取资源 (可选)</li></ol><ul><li>添加CNAME记录需要在您的域名厂商处配置；CNAME的配置和域名的解析配置一起的</li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="服务接口的数据可以使用CDN来缓存？"><a href="#服务接口的数据可以使用CDN来缓存？" class="headerlink" title="服务接口的数据可以使用CDN来缓存？"></a>服务接口的数据可以使用CDN来缓存？</h3><ul><li>CDN不仅可以缓存静态资源（图片，视频等），对于一些数据变更不大的接口，可以适当缓存接口数据。比如配置，利用CDN缓存几分钟是合理的。</li></ul><h3 id="不能缓存数据的接口，可以使用CDN吗？"><a href="#不能缓存数据的接口，可以使用CDN吗？" class="headerlink" title="不能缓存数据的接口，可以使用CDN吗？"></a>不能缓存数据的接口，可以使用CDN吗？</h3><ul><li>结论：可以使用CDN，但注意GET接口响应头设置为不缓存(比如设置 Cache-Control:no-cache)</li></ul><ol><li>通过CDN加速回源效果（使用CDN快速传输的特性）<ul><li>比如一般情况下，用户访问通过普通公网，需要经过20个路由才到达服务器</li><li>使用CDN加速后，通过5CDN节点就到达服务器了（这里涉及服务器端在CDN的接入点、用户端CDN部署的覆盖范围是否足够大）</li></ul></li><li>使用CDN隐藏服务器真实IP,起到提升安全性等作用</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2000101">DNS、CDN加速和域名解析之间的关系</a></li><li><a href="https://kingson4wu.github.io/2020/08/20/20200820-%E5%85%B3%E4%BA%8ECDN%E7%BC%93%E5%AD%98/">关于CDN缓存总结摘要</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关名词&quot;&gt;&lt;a href=&quot;#相关名词&quot; class=&quot;headerlink&quot; title=&quot;相关名词&quot;&gt;&lt;/a&gt;相关名词&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CDN（Content Delivery Network）（内容分发网络）：提供内容给用户就近访问&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="CDN" scheme="http://yoursite.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>DNS解惑</title>
    <link href="http://yoursite.com/2022/08/01/20220801-DNS%E8%A7%A3%E6%83%91/"/>
    <id>http://yoursite.com/2022/08/01/20220801-DNS%E8%A7%A3%E6%83%91/</id>
    <published>2022-08-01T09:00:30.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li>DNS（Domain Name System）域名系统: 域名和IP地址映射关系</li><li>LocalDNS : 本地DNS服务器，一般是ISP（Internet Service Provider）提供。ISP，即是互联网服务提供商(比如电信、联通和移动三大电信运营商)；对于不同运营商间的互联互通，一般是采用BGP peering（对等）的方式进行</li><li>地址解析协议，即ARP（Address Resolution Protocol）是将IP地址转换为MAC地址（TCP&#x2F;IP数据链路层协议）；DNS协议则是将域名转换为IP地址（TCP&#x2F;IP应用层协议）</li><li>ICANN  互联网名称与数字地址分配机构（The Internet Corporation for Assigned Names and Numbers）,全世界域名的最高管理机构。</li><li>CNNIC：中国互联网络信息中心（China Internet Network Information Center，CNNIC）是经国家主管部门批准，于1997年6月3日组建的管理和服务机构，行使国家互联网络信息中心的职责。</li><li>可逆DNS（rDNS，reverse DNS）是一种把一个IP地址分解成一个域名的方法，正像域名系统（DNS）把域名分解成关联的IP地址。</li></ul><h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><ul><li>不考虑每部分DNS缓存的情况下，DNS解析流程大致如下：</li></ul><ol><li>【递归查询】用户机器（比如浏览器）-&gt; 本地DNS服务器 </li><li>【迭代查询】本地DNS服务器 -&gt; DNS根服务器(返回域服务器)</li><li>【迭代查询】本地DNS服务器 -&gt; 域服务器(返回DNS服务器列表)</li><li>【迭代查询】本地DNS服务器(选择一个DNS服务器) -&gt; DNS服务器(返回域名对应的IP)（或返回其他权限服务器的IP地址，取决于域名的解析配置）</li><li>本地DNS服务器 -&gt; 权限服务器（可选步骤，取决于上一步的返回）</li><li>用户机器（根据IP发送请求访问）</li></ol><p><img src="/2022/08/01/20220801-DNS%E8%A7%A3%E6%83%91/dns-resolution-linux-1920x994.webp"></p><ul><li><p><a href="https://devconnected.com/how-to-flush-dns-cache-on-linux/">https://devconnected.com/how-to-flush-dns-cache-on-linux/</a></p></li><li><p>浏览器等各个部分一般会缓存DNS记录一段时间</p></li><li><p>本地DNS服务器（LocalDNS）使用迭代查询的方式请求；请求发起方（浏览器）使用递归查询的方式请求</p></li><li><p>递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p></li><li><p>迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</p></li><li><p>通俗地说，递归就是把一件事情交给别人，如果事情没有办完，哪怕已经办了很多，都不要把结果告诉我，我要的是你的最终结果，而不是中间结果；如果你没办完，请你找别人办完。<br>迭代则是我交给你一件事，你能办多少就告诉我你办了多少，然后剩下的事情就由我来办。</p></li></ul><h2 id="域名的管理"><a href="#域名的管理" class="headerlink" title="域名的管理"></a>域名的管理</h2><ul><li><p>.com等国际顶级域名的管理机构是ICANN；.cn等国内域名的管理机构是CNNIC</p></li><li><p>用whois可以查询域名的相关信息</p></li><li><p>域名具有管理密码和转移密码，域名转移密码又称为授权码（Authorization code）或 域名EPP代码（EPP Key）</p></li><li><p>域名其实是具有一定的层次结构的，从上到下依次为：根域名、顶级域名（top level domain，TLD）、二级域名、（三级域名）<br>先来讲讲顶级域名（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<a href="http://www.baidu.com/">www.baidu.com</a> 的顶级域名就是 .com。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。</p></li><li><p>ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个托管商，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，.cn 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 .cn 域名的各种政策。</p></li><li><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<a href="http://www.xxx.com/">www.xxx.com</a> 被写成 <a href="http://www.xxx.com.,即最后还会多出一个点.这个点就是根域名./">www.xxx.com.，即最后还会多出一个点。这个点就是根域名。</a></p></li><li><p>理论上，所有域名的查询都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商。</p></li></ul><h2 id="DNS服务器类别"><a href="#DNS服务器类别" class="headerlink" title="DNS服务器类别"></a>DNS服务器类别</h2><h3 id="权威-DNS"><a href="#权威-DNS" class="headerlink" title="权威 DNS"></a>权威 DNS</h3><ul><li>权威 DNS 指域名在域名注册商处所设置的 DNS 服务器地址。该地址决定了该域名的解析管理权（新增，删除，修改等）。比如 DNSPod 的权威服务器：*.dnspod.net, * dnsv3.com 等。当域名设置权威服务器并设置了解析记录后，客户端请求域名时，权威服务器将返回该域名的对应的解析记录信息。</li></ul><h3 id="Local-DNS"><a href="#Local-DNS" class="headerlink" title="Local DNS"></a>Local DNS</h3><ul><li><p>Local DNS 是 DNS 查询中的第一个节点。Local DNS 作为客户端与 DNS 域名服务器的中间人。客户端发送 DNS 查询时，Local DNS 将使用缓存的数据进行响应，或者将向根域名服务器发送请求，接着向根域名服务器发送另一个请求，然后向权威 DNS 发送最后一个请求。收到来自包含已请求 IP 地址的权威 DNS 服务器的响应后，Local DNS 将向客户端发送响应。</p></li><li><p>在此过程中，Local DNS 将缓存从权威 DNS 服务器收到的信息。当一个客户端请求的域名 IP 地址是另一个客户端最近请求的 IP 地址时，Local DNS 可绕过与域名服务器进行通信的过程，并仅从第二个客户端的缓存中为第一个客户端提供所请求的记录。</p></li></ul><h3 id="公共-DNS"><a href="#公共-DNS" class="headerlink" title="公共 DNS"></a>公共 DNS</h3><ul><li>公共DNS，指面向所有互联网用户的全球公共递归域名解析服务。和仅使用本地 LocalDNS 的传统解析服务相比，公共解析服务，一般具备更加“快速”、“稳定”、“安全”互联网访问。</li></ul><h2 id="DNS常用命令"><a href="#DNS常用命令" class="headerlink" title="DNS常用命令"></a>DNS常用命令</h2><ul><li>dig、 host、nslookup、traceroute、whois</li></ul><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><h3 id="域名提供商和电信服务提供商之间DNS的关系？"><a href="#域名提供商和电信服务提供商之间DNS的关系？" class="headerlink" title="域名提供商和电信服务提供商之间DNS的关系？"></a>域名提供商和电信服务提供商之间DNS的关系？</h3><ol><li>域名提供商(域名注册商)（ICANN等授权的管理机构）；电信服务提供商（ISP）</li><li>ISP的DNS：LocalDNS</li><li>域名提供商的DNS （腾讯、阿里云等），将自己的dns服务的ip直接在各个ISP中进行登记，使得ISP的DNS服务能转发过来查找，得到域名对应的ip</li><li>域名并不依赖平台，比如阿里万网只是个注册商，注册完域名后有相应的转移密码。转移密码有多种用途，比如可以在多个DNS服务商托管域名解析（有的域名注册商不一定有对应的DNS服务，而且在多个DNS服务商解析可以起到容灾作用）</li></ol><h3 id="运营商DNS和公共DNS"><a href="#运营商DNS和公共DNS" class="headerlink" title="运营商DNS和公共DNS"></a>运营商DNS和公共DNS</h3><ul><li>如何不特意去设置，我们用的就是运营商DNS（由DHCP分配）</li><li>目前国内电信运营商通过使用DNS劫持和DNS污染的方法，干扰用户正常上网，使得用户无法访问众多国外常用服务，因此可以使用公共DNS</li></ul><h3 id="自己创建的域名怎么让其他dns服务器解析"><a href="#自己创建的域名怎么让其他dns服务器解析" class="headerlink" title="自己创建的域名怎么让其他dns服务器解析"></a>自己创建的域名怎么让其他dns服务器解析</h3><ul><li>除非用户自行设置指定你的dns服务公网ip，否则只有成为认证通过的注册服务商才行</li><li>比如阿里云域名的解析生效，第一步是 阿里云 DNS 必须首先生效，然后等待世界各地 Local DNS 生效，可以通俗的理解为各大电信运营管理的 DNS 需要及时同步 阿里云 DNS 解析记录，才能最终生效。 网站是否能访问，直接相关的是 Local DNS， 阿里 云解析都是实时生效的，一般只需几秒即可同步到各地 Local DNS 上，但各地 Local DNS 均有缓存机制，解析的最终生效取决于各运营商刷新时间。</li></ul><h3 id="DNS解析相关疑问"><a href="#DNS解析相关疑问" class="headerlink" title="DNS解析相关疑问"></a>DNS解析相关疑问</h3><ul><li>DNS协议是应用层的协议，解析过程发生在用户态。</li><li>DNS协议既使用了UDP，也使用了TCP，使用的端口号都为 53。大多数情况下 DNS 都使用 UDP 进行传输。</li><li>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议；DNS区域传输的时候使用TCP协议</li><li>举个例子：浏览器返回某个HTTP服务<ol><li>浏览器调用“DNS解析模块”发出UDP请求得到域名的ip（DNS 应用层）</li><li>浏览器调用TCP（内核系统调用）发出HTTP请求（TCP 传输层）</li><li>TCP通过ARP协议得到mac地址 （ARP 数据链路层）</li></ol></li><li>“DNS解析模块” 是在哪里实现的？<ol><li>程序自行解析实现（从&#x2F;etc&#x2F;resolv.conf中取出本地dns server地址列表， 发送DNS请求(UDP报文)并获得结果）</li><li>调用到c标准库的getaddrinfo或getnameinfo函数<ul><li>要想知道getaddrinfo是如何查询信息的，可以用strace工具，追踪getaddrinfo函数 在执行时打开了哪些文件</li><li>resolv.conf是各种操作系统域名系统解析器（DNS Resolver）的配置文件。每当一个程序需要通过域名来访问Internet上面的其它主机时，需要利用Resolver库函数将域名转换成对应的IP，然后才可进行访问。</li><li>域名系统解析器（DNS Resolver）并非一个可执行程序，而是C语言的一系列库函数，用于解析resolv.conf获取域名对应的IP。</li></ul></li><li>操作系统中并不存在“DNS 查询”这个系统调用; 不同程序可能采用不同的策略获取名字对应的 IP 地址</li></ol></li></ul><h3 id="dns-resolver相关"><a href="#dns-resolver相关" class="headerlink" title="dns-resolver相关"></a>dns-resolver相关</h3><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/dns/dns-resolvers">https://docs.microsoft.com/en-us/windows/win32/dns/dns-resolvers</a></li><li><a href="https://datacadamia.com/os/linux/resolv.conf">https://datacadamia.com/os/linux/resolv.conf</a>    </li><li><a href="https://www.kernel.org/doc/html/latest/networking/dns_resolver.html">DNS Resolver Module</a><ul><li>The DNS resolver module provides a way for kernel services to make DNS queries by way of requesting a key of key type dns_resolver. These queries are upcalled to userspace through &#x2F;sbin&#x2F;request-key.</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2000101">DNS、CDN加速和域名解析之间的关系</a></li><li><a href="https://www.vpsgongyi.net/archives/2197.html">权威DNS、Local DNS、公共DNS有什么区别</a></li><li><a href="https://www.cnblogs.com/wuyepeng/p/9835839.html">DNS用的是TCP协议还是UDP协议</a></li><li><a href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析</a></li><li><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825">DNS（域名解析协议）详解</a></li><li><a href="https://www.cnblogs.com/battzion/p/4235562.html">getaddrinfo工作原理分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/42898476">Linux DNS 查询剖析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关名词&quot;&gt;&lt;a href=&quot;#相关名词&quot; class=&quot;headerlink&quot; title=&quot;相关名词&quot;&gt;&lt;/a&gt;相关名词&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DNS（Domain Name System）域名系统: 域名和IP地址映射关系&lt;/li&gt;
&lt;li&gt;LocalD</summary>
      
    
    
    
    
    <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈跨域</title>
    <link href="http://yoursite.com/2022/07/20/20220720-%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2022/07/20/20220720-%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F/</id>
    <published>2022-07-20T13:50:26.000Z</published>
    <updated>2023-05-07T14:41:07.789Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>JQuery的jsonp的success与jsonpCallback的关系:<a href="https://www.cnblogs.com/non-clockwork-cheng/p/6637491.html">https://www.cnblogs.com/non-clockwork-cheng/p/6637491.html</a>,<br><a href="https://www.cnblogs.com/tapt/p/6524946.html">https://www.cnblogs.com/tapt/p/6524946.html</a></p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">              <span class="attr">async</span>:<span class="literal">false</span>,</span><br><span class="line">              <span class="attr">url</span>: <span class="string">&quot;http://192.168.1.102:8080/carop/jsonp&quot;</span>,</span><br><span class="line">              <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">              <span class="attr">jsonpCallback</span>:<span class="string">&quot;jsonpCallback&quot;</span>,              </span><br><span class="line">              <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="title function_">alert</span>(data.<span class="property">name</span>+<span class="string">&quot;\n &quot;</span>+data.<span class="property">tel</span>);</span><br><span class="line">              &#125;</span><br><span class="line"> &#125;); </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>jsonp和jsonpcallback的使用:<a href="https://www.cnblogs.com/zhangruiqi/p/7880642.html">https://www.cnblogs.com/zhangruiqi/p/7880642.html</a></p></li></ul><pre>1. jsonp、jsonpCallback  jsonp跨域时可以自定义的两个参数2. jsonp: 回掉函数名的参数名，默认callback，服务端通过它来获取到回调函数名3. jsonpCallback: 回调函数名，默认jquery自动生成4. 指定jsonpCallback时可以将回掉函数写在ajax外面做其他操作，不指定时不能这样做，只能在success里做操作一般jquery跨域用到的两个方法为：$.ajax 和$.getJSON最后，仔细安静下来，细读 json 官方文档后发现这么一段：JSON数据是一种能很方便通过JavaScript解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。其实jquery跨域的原理是通过外链 <script>  来实现的,然后在通过回调函数加上回调函数的参数来实现真正的跨域Jquery 在每次跨域发送请求时都会有callback这个参数，其实这个参数的值就是回调函数名称，所以，服务器端在发送json数据时，应该把这个参数放到前面，这个参数的值往往是随机生成的，如：jsonp1294734708682，同时也可以通过 $.ajax 方法设置 jsonpcallback 方法的名称。</pre><ul><li><p>解决跨域有几种</p><ol><li>通过jsonp跨域(需要服务端配合),原理:动态创建script.jsonp的解决方式（仅支持GET方式）</li><li>跨域资源共享（CORS）,服务端设置Access-Control-Allow-Origin<ul><li>nginx反向代理接口跨域 : <code>add_header Access-Control-Allow-Origin http://www.domain1.com; </code></li></ul></li><li>使用jsonp还不如响应添加Access-Control-Allow-Origin?<ul><li>传统的跨域请求没有好的解决方案，无非就是jsonp和iframe，随着跨域请求的应用越来越多，W3C提供了跨域请求的标准方案（Cross-Origin Resource Sharing）。IE8、Firefox 3.5 及其以后的版本、Chrome浏览器、Safari 4 等已经实现了 Cross-Origin Resource Sharing 规范，实现了跨域请求。<br>在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息。</li><li>说明jsonp其实已经过时?是以前  CORS没出现前的方案?</li></ul></li></ol></li><li><p>springboot中通过cors协议解决跨域问题：<a href="https://www.cnblogs.com/520playboy/p/7306008.html">https://www.cnblogs.com/520playboy/p/7306008.html</a></p></li></ul></script></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JQuery的jsonp的success与jsonpCallback的关系:&lt;a href=&quot;https://www.cnblogs.com/non-clockwork-cheng/p/6637491.html&quot;&gt;https://www.cnblogs.c</summary>
      
    
    
    
    
    <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java跨平台能完全做到一次编写到处运行？</title>
    <link href="http://yoursite.com/2022/07/05/20220705-Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%AE%8C%E5%85%A8%E5%81%9A%E5%88%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/07/05/20220705-Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%AE%8C%E5%85%A8%E5%81%9A%E5%88%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C%EF%BC%9F/</id>
    <published>2022-07-05T02:20:11.000Z</published>
    <updated>2023-05-07T14:41:07.787Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/05/20220705-Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%AE%8C%E5%85%A8%E5%81%9A%E5%88%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C%EF%BC%9F/lionel-messi.jpg"></p><ul><li>最近定位一个问题，花了不少时间。事后回想起来挺低级的，在此记录一下。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>spring i18n, 在windows和mac生效，在linux不生效。</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>资源文件的名字为小写（message_zh_hant.proprties）</li><li>而文件读取时包含大写（message_zh_Hant.proprties）（这里不得不吐槽一下，spring无论请求参数传的是大写还是小写，最终都会转成大写去读文件，而且这么简单的功能，代码写得及其复杂，浪费了不少时间去debug）</li><li>windows和mac大小写不敏感，所以能读取文件成功，而linux则大小写敏感，则读取不成功（说好的Java跨平台呢？但跨平台包括处理这种不兼容的问题？似乎很难界定。）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>windows和mac文件名对大小写不敏感，而linux则大小写敏感；</li><li>即使使用Java编写代码，特殊的场景还是需要考虑各平台的兼容问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/05/20220705-Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%AE%8C%E5%85%A8%E5%81%9A%E5%88%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5</summary>
      
    
    
    
    
    <category term="大小写敏感" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>个人golang项目简要描述</title>
    <link href="http://yoursite.com/2022/06/01/20220601-%E4%B8%AA%E4%BA%BAgolang%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0/"/>
    <id>http://yoursite.com/2022/06/01/20220601-%E4%B8%AA%E4%BA%BAgolang%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0/</id>
    <published>2022-06-01T03:44:05.000Z</published>
    <updated>2023-05-07T14:41:07.780Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/01/20220601-%E4%B8%AA%E4%BA%BAgolang%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0/golang_project_3.png"></p><p><img src="/2022/06/01/20220601-%E4%B8%AA%E4%BA%BAgolang%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0/golang_deploy_2.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/272594212">golang如何优雅的实现重启服务(fvbock&#x2F;endless)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/01/20220601-%E4%B8%AA%E4%BA%BAgolang%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0/golang_project_3.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
    <category term="ngrok" scheme="http://yoursite.com/tags/ngrok/"/>
    
    <category term="wechat" scheme="http://yoursite.com/tags/wechat/"/>
    
    <category term="mail" scheme="http://yoursite.com/tags/mail/"/>
    
  </entry>
  
  <entry>
    <title>算法基础总结</title>
    <link href="http://yoursite.com/2022/05/10/20220510-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/05/10/20220510-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-10T14:33:28.000Z</published>
    <updated>2023-05-07T14:41:07.780Z</updated>
    
    <content type="html"><![CDATA[<ul><li>O这个符号的意思是“忽略重要项以外的内容”，读音同Order。O（n2）的含义就是“算法的运行时间最长也就是n2的常数倍”，准确的定义请参考相关专业书籍。重点在于，通过这种表示方法，我们可以直观地了解算法的时间复杂度</li><li>当我们知道选择排序的时间复杂度为O（n2）、快速排序的时间复杂度为O（nlogn）时，很快就能判断出快速排序的运算更为高速。二者的运行时间根据输入n产生的变化程度也一目了然。</li></ul><h2 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h2><h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h2 id="五、哈希表"><a href="#五、哈希表" class="headerlink" title="五、哈希表"></a>五、哈希表</h2><h2 id="六、堆"><a href="#六、堆" class="headerlink" title="六、堆"></a>六、堆</h2><ul><li>堆是一种图的树形结构，被用于实现“优先队列”（priority queues）</li><li>优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出</li><li>如果需要频繁地从管理的数据中取出最小值，那么使用堆来操作会非常方便。</li></ul><h2 id="七、二叉查找树"><a href="#七、二叉查找树" class="headerlink" title="七、二叉查找树"></a>七、二叉查找树</h2><ul><li>二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构</li><li>二叉查找树有两个性质。第一个是每个结点的值均大于其左子树上任意一个结点的值。</li><li>有很多以二叉查找树为基础扩展的数据结构，比如“平衡二叉查找树”。这种数据结构可以修正形状不均衡的树，让其始终保持均衡形态，以提高查找效率。</li><li>种子结点数可以自由设定，并且形状均衡的树便是B树。</li></ul><hr><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul><li>由顶点和连接每对顶点的边所构成的图形就是图。</li><li>这个值叫作边的“权重”或者“权”，加了权的图被称为“加权图”。没有权的边只能表示两个顶点的连接状态，而有权的边就可以表示顶点之间的“连接程度”</li><li>有向图、无向图</li></ul><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><ul><li>广度优先搜索会优先从离起点近的顶点开始搜索。</li><li>候补顶点是用“先入先出”（FIFO）的方式来管理的，因此可以使用“队列”这个数据结构。</li><li>广度优先搜索的特征为从起点开始，由近及远进行广泛的搜索。因此，目标顶点离起点越近，搜索结束得就越快。</li></ul><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul><li>深度优先搜索会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。</li><li>此处，候补顶点是用“后入先出”（LIFO）的方式来管理的，因此可以使用“栈”这个数据结构。</li><li>广度优先搜索选择的是最早成为候补的顶点，因为顶点离起点越近就越早成为候补，所以会从离起点近的地方开始按顺序搜索；而深度优先搜索选择的则是最新成为候补的顶点，所以会一路往下，沿着新发现的路径不断深入搜索。</li></ul><h2 id="贝尔曼-福特算法"><a href="#贝尔曼-福特算法" class="headerlink" title="贝尔曼-福特算法"></a>贝尔曼-福特算法</h2><ul><li>贝尔曼-福特（Bellman-Ford）算法是一种在图中求解最短路径问题的算法。最短路径问题就是在加权图指定了起点和终点的前提下，寻找从起点到终点的路径中权重总和最小的那条路径。</li><li>贝尔曼也因为提出了该算法中的一个重要分类“动态规划”而被世人所熟知。</li></ul><h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><ul><li>狄克斯特拉（Dijkstra）算法也是求解最短路径问题的算法，使用它可以求得从起点到终点的路径中权重总和最小的那条路径路径。</li></ul><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><ul><li>A<em>（A-Star）算法也是一种在图中求解最短路径问题的算法，由狄克斯特拉算法发展而来。狄克斯特拉算法会从离起点近的顶点开始，按顺序求出起点到各个顶点的最短路径。也就是说，一些离终点较远的顶点的最短路径也会被计算出来，但这部分其实是无用的。与之不同，A</em>就会预先估算一个值，并利用这个值来省去一些无用的计算。</li></ul><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>[我的第一本算法书] - 宫崎修一 石田保辉</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;O这个符号的意思是“忽略重要项以外的内容”，读音同Order。O（n2）的含义就是“算法的运行时间最长也就是n2的常数倍”，准确的定义请参考相关专业书籍。重点在于，通过这种表示方法，我们可以直观地了解算法的时间复杂度&lt;/li&gt;
&lt;li&gt;当我们知道选择排序的时间复</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高效工作方法论总结</title>
    <link href="http://yoursite.com/2022/05/07/20220507-%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/05/07/20220507-%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-07T01:41:15.000Z</published>
    <updated>2023-05-07T14:41:07.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考维度"><a href="#思考维度" class="headerlink" title="思考维度"></a>思考维度</h2><ul><li>事前, 事中, 事后</li><li>从三个维度  预防，及时发现，止损  三个出发</li><li>what when why who how</li><li>5W3H(what、when、why、who、where、how、how much、how feel)</li><li>金字塔思维: 主治：思维混乱，分不清主次重点 - 提高逻辑性和条理性; 总-分-总 过去-现在-将来 第一-第二-第三.</li><li>STAR 法则: 主治：不知道如何表达 - 讲述故事的绝佳手段; 情境(situation)、任务(task)、行动(action)、结果(result)</li><li>SMART 原则: 主治：不知道如何着手做目标管理 - 制定目标的黄金准则; 目标具体(Specific)、可度量(Measurable)、可实现(Attainable)、现实性(Realistic)、时限(Time bound)</li><li>PDCA 循环： 主治：工作计划性差, 自律性弱 - 过程管理: 持续反馈-&gt;持续改进 ；计划（plan）、执行（do）、 检查（check）、调整（Adjust）</li><li>四象限法则: 主治：时间分配不合理- 尽量在做最重要的事情;</li></ul><h2 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h2><ol><li>表达要有逻辑(所有的逻辑关系都在这四种顺序之内)</li></ol><ul><li>演绎（因果）顺序</li><li>时间（步骤）顺序</li><li>空间（结构）顺序</li><li>程度（重要性）顺序</li></ul><ol start="2"><li>做事要有套路</li></ol><ul><li>5W2H:Why、Who、When、Where、What、How 和 How much</li></ul><ol start="3"><li>建立中心</li></ol><ul><li>定义清楚要解决的问题，要明确目标<ul><li>自上而下:适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。</li><li>自下而上:对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。</li></ul></li><li>抽象层次越高，要解决的问题域越宽，外延越大</li></ul><ol start="4"><li>结构化分解</li></ol><ul><li>分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序</li><li>在做空间分解的时候，要注意满足 MECE（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）原则</li></ul><h2 id="合理安排自己的时间"><a href="#合理安排自己的时间" class="headerlink" title="合理安排自己的时间"></a>合理安排自己的时间</h2><ol><li>每天提前一小时醒来</li><li>每天提前 15 分钟到公司</li><li>下班前花 15 分钟总结</li><li>减少玩手机的时候</li><li>把时间切割成小块</li><li>碎片化时间利用</li><li>给休息生活留出时间</li></ol><hr><ul><li>抽象思维：帮助我们快速抽取面对问题的关键要素和本质，可以是其他能力的“元能力”</li><li>分层思维：帮助我们拆解问题，分而治之，划清问题和职责边界</li><li>归纳思维：帮助我们从个性问题中抽象出问题的一般规律和得出共同结论</li><li>结构化思维：帮助我们沉淀自己的知识树，逐步系统性的思考问题</li></ul><hr><h2 id="深度工作总结"><a href="#深度工作总结" class="headerlink" title="深度工作总结"></a>深度工作总结</h2><ul><li>如果你无法学习，就无法成功</li><li>无干扰状态下保持专注</li><li>高质量工作产出&#x3D;时间×专注度</li><li>转移工作、注意力残留 -&gt; 专注、深度工作</li><li>深度工作并非是我们的经济中唯一有价值的技能，不培养这种能力也有可能做得很好，但是不需要深度工作的职业会越来越少。</li><li>最小阻力原则</li><li>忙碌代表生产能力（Busyness as Proxy for Productivity）：在工作中，对于生产能力和价值没有明确的指标时，很多知识工作者都会采用工业时代关于生产能力的指标，以可视的方式完成很多事情。</li><li>支持深度工作往往要抵制新的高科技</li><li>当工作中没有明确目标时，围绕浮浅工作的表面忙碌会成为一种本能</li><li>工作其实比休闲时光更容易带来享受？</li><li>意志力是有限的</li><li>培养深度工作的习惯，关键在于越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序，使得进入并保持高度专注状态消耗的意志力最小化。！！！！！</li><li>选定你的深度哲学（节奏哲学）、并习惯化</li><li>恰当展开协作可以提升你在职业生活中深度工作的质量</li><li>这种隔音办公室与宽阔公共空间的组合，形成了中心辐射型的创新建筑结构，在这里偶遇的意外发现和与世隔绝的深度思考都能实现。</li><li>专注于少量“极端重要的目标”</li><li>引领性指标</li><li>专注于极度重要目标上的深度工作状态时间</li><li>4DX框架下的4种原则 ！！！</li><li>在整个4DX的实验过程中，目标的明晰性，辅以引领性指标计分板提供的简单但却难以回避的反馈，促使我达到了此前从未实现的深度状态。</li><li>定期放松大脑！！工作日结束的时候，在第二天早晨到来之前，屏蔽掉对工作问题的担忧。</li><li>定期休息大脑可以提升深度工作的质量。工作时，努力工作。完成时，就放松下来。</li><li>不要不断分心，而要不断专注</li><li>设定一个几乎不可能的时间期限；深度工作需要专注的强度远远超出了大部分知识工作者的舒适区。</li><li>有成果的冥想</li><li>远离社交媒体</li><li>在晚上或周末到来之前就确定要做的事情是十分重要的。（避免陷入其他无效的诱惑）</li><li>人的智力系统可以进行长时间的高强度活动：它不像人的手脚一样会疲倦。除睡觉以外，它只需要变化，而不是停止。！！！</li><li>如果你想抵御娱乐网站对你时间和精力的诱惑，那么就给大脑找一些高质量的替代活动。这样不仅可以使我们避免分心，保持专注的能力，同时还有可能实现本内特的宏伟目标：体验到何为生活，而不仅仅是生存。</li><li>减少浮浅工作在我们日程中的分量，而不是将其消除</li><li>一天的每一分钟都要做好计划（笔记本）</li><li>深度工作要求你尊重自己的时间。要做到真正尊重时间，下面这一条建议是个很不错的开端：提前决定你一天的每一分钟要做什么工作。</li><li>5点半之前结束工作。固定日程生产力。</li><li>变得不容易联系到；文档化</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://mp.weixin.qq.com/s/zH9kFjJQ5zE9mKGEiwEYAA">如何提升职业工作效率</a></li><li><a href="https://zhuanlan.zhihu.com/p/500696193">一线技术人的成长思考总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;思考维度&quot;&gt;&lt;a href=&quot;#思考维度&quot; class=&quot;headerlink&quot; title=&quot;思考维度&quot;&gt;&lt;/a&gt;思考维度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;事前, 事中, 事后&lt;/li&gt;
&lt;li&gt;从三个维度  预防，及时发现，止损  三个出发&lt;/li&gt;
&lt;li&gt;wha</summary>
      
    
    
    
    
    <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
