<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拉巴力的纸皮箱</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2025-08-07T04:39:38.663Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kingson Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多语言大模型如何处理不同语言？是翻译成英语后再推理的吗？</title>
    <link href="http://yoursite.com/2025/08/07/20250807-duo-yu-yan-da-mo-xing-ru-he-chu-li-bu-tong-yu-yan-shi-fan-yi-cheng-ying-yu-hou-zai-tui-li-de-ma/"/>
    <id>http://yoursite.com/2025/08/07/20250807-duo-yu-yan-da-mo-xing-ru-he-chu-li-bu-tong-yu-yan-shi-fan-yi-cheng-ying-yu-hou-zai-tui-li-de-ma/</id>
    <published>2025-08-07T04:14:48.000Z</published>
    <updated>2025-08-07T04:39:38.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>以下文章有ChatGPT生成</p></blockquote></blockquote><p>多语言大模型（Multilingual LLM）越来越普及，但一个常见的问题是：<strong>模型处理非英语语言时，是直接在原语言上推理，还是先翻译成英语再处理？</strong></p><p>简短回答：<strong>大多数主流模型并不会将输入翻译为英语后再推理，而是直接在原语言上进行理解与生成。</strong></p><p>以下是详细解释。</p><hr><h2 id="1-训练方式：直接多语言训练"><a href="#1-训练方式：直接多语言训练" class="headerlink" title="1. 训练方式：直接多语言训练"></a>1. 训练方式：直接多语言训练</h2><p>当前主流大模型（如 GPT、Claude、Gemini、Mistral、LLaMA、BLOOM 等）在训练时使用了多语种语料，模型在训练阶段就学会了多语言的语法、词汇和语义表达：</p><ul><li>不会将所有语料翻译成英语；</li><li>而是在训练过程中构建出一个“跨语言的共享语义空间”，在这个空间中不同语言的同义句会靠得很近；</li><li>因此，模型具备了直接理解和生成多语言的能力。</li></ul><hr><h2 id="2-英语的优势与“隐性中心化”"><a href="#2-英语的优势与“隐性中心化”" class="headerlink" title="2. 英语的优势与“隐性中心化”"></a>2. 英语的优势与“隐性中心化”</h2><p>虽然模型支持多语言，但英语仍然是“最强语言”，原因包括：</p><ul><li>英语在训练数据中占比通常高达 60%~90%；</li><li>模型参数对英语有更强的优化效果；</li><li>英语可能隐性地作为“锚点”来对齐其他语言的语义表示。</li></ul><p>这种语义对齐并不是翻译行为，而是一种深层语义空间的统一。</p><hr><h2 id="3-推理流程：不会翻译成英语再处理"><a href="#3-推理流程：不会翻译成英语再处理" class="headerlink" title="3. 推理流程：不会翻译成英语再处理"></a>3. 推理流程：不会翻译成英语再处理</h2><p>当你用中文或其他语言提问时，模型不会走「中文 → 英文 → 推理 → 翻译成中文」这一路径，而是：</p><ul><li>直接在中文语境中理解问题；</li><li>在语义空间中执行推理；</li><li>直接生成中文结果。</li></ul><p>当然，部分三方插件可能人为引入翻译步骤，但这不是模型本身的机制。</p><hr><h2 id="4-支持机制的实验证据"><a href="#4-支持机制的实验证据" class="headerlink" title="4. 支持机制的实验证据"></a>4. 支持机制的实验证据</h2><ul><li><strong>对比实验</strong>：模型处理法语、德语等非英语输入时，直接完成推理与生成，无中转行为。</li><li><strong>语义嵌入对齐</strong>：多语言句子在语义空间中具有高度重合性。</li><li><strong>激活层分析</strong>：输入非英语语言时，中间激活状态未显示出“语言切换”迹象。</li></ul><hr><h2 id="5-用英语输入表现是否更好？"><a href="#5-用英语输入表现是否更好？" class="headerlink" title="5. 用英语输入表现是否更好？"></a>5. 用英语输入表现是否更好？</h2><p>是的。虽然模型支持多语言，但用英语输入通常效果最佳，尤其体现在知识完整性、表达清晰度、推理深度等方面：</p><h3 id="为什么英语效果更好："><a href="#为什么英语效果更好：" class="headerlink" title="为什么英语效果更好："></a>为什么英语效果更好：</h3><table><thead><tr><th>因素</th><th>原因说明</th></tr></thead><tbody><tr><td>数据占比高</td><td>英语语料远多于其他语言，覆盖面更广，细节更丰富</td></tr><tr><td>表达优化充分</td><td>模型在英语上训练迭代次数更多，结构化表达能力更强</td></tr><tr><td>知识密度高</td><td>很多细节知识只出现在英文语料（如 Reddit、Wikipedia、新闻、论文等）中</td></tr><tr><td>推理能力领先</td><td>英文任务训练量大，模型更善于处理多步推理、复杂逻辑问题</td></tr></tbody></table><hr><h3 id="对比示例："><a href="#对比示例：" class="headerlink" title="对比示例："></a>对比示例：</h3><table><thead><tr><th>输入语言</th><th>问题</th><th>模型响应风格与质量</th></tr></thead><tbody><tr><td>英语</td><td>Why did the Roman Empire fall?</td><td>内容结构清晰，信息丰富，逻辑严密</td></tr><tr><td>中文</td><td>罗马帝国为何衰亡？</td><td>内容相似，但用词偏模板化，论证略显单薄</td></tr><tr><td>阿拉伯语</td><td>لماذا سقطت الإمبراطورية الرومانية؟</td><td>回答趋于泛泛，具体细节缺失</td></tr></tbody></table><hr><h2 id="6-Prompt-编写建议"><a href="#6-Prompt-编写建议" class="headerlink" title="6. Prompt 编写建议"></a>6. Prompt 编写建议</h2><table><thead><tr><th>使用场景</th><th>推荐策略</th></tr></thead><tbody><tr><td>复杂推理&#x2F;创作</td><td>使用英文 Prompt，提升准确性和内容质量</td></tr><tr><td>中文对话&#x2F;问答</td><td>可直接用中文，响应速度快，语义易控</td></tr><tr><td>翻译任务</td><td>直接使用目标语言作为输入&#x2F;输出，模型对翻译任务表现良好</td></tr><tr><td>多语言兼容输出</td><td>英文 Prompt + 指令 <code>Please answer in Chinese.</code> 等，结果可控</td></tr></tbody></table><hr><h2 id="7-实用技巧：英文-Prompt-中文输出"><a href="#7-实用技巧：英文-Prompt-中文输出" class="headerlink" title="7. 实用技巧：英文 Prompt + 中文输出"></a>7. 实用技巧：英文 Prompt + 中文输出</h2><h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Your task in English]</span><br><span class="line">Please answer in Chinese.</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Write a short argumentative essay about how artificial intelligence is impacting the future of employment. Focus on both the opportunities and challenges it presents. Use logical reasoning and real-world examples.</span><br><span class="line">Please answer in Chinese.</span><br></pre></td></tr></table></figure><h3 id="输出（模型生成中文）："><a href="#输出（模型生成中文）：" class="headerlink" title="输出（模型生成中文）："></a>输出（模型生成中文）：</h3><blockquote><p>人工智能正在以惊人的速度改变就业的未来……（略）</p></blockquote><hr><h2 id="8-进阶策略：先生成英文，再翻译"><a href="#8-进阶策略：先生成英文，再翻译" class="headerlink" title="8. 进阶策略：先生成英文，再翻译"></a>8. 进阶策略：先生成英文，再翻译</h2><p>对于需要最大限度保持内容质量的应用，可以：</p><ol><li>使用英文 Prompt；</li><li>得到英文结果后，用模型翻译为中文；</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Translate the following text into Chinese:</span><br><span class="line">[英文生成内容]</span><br></pre></td></tr></table></figure><p>适合精细控制内容质量的生产环境。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>大模型是否将非英语输入翻译为英语再推理？</td><td>否，直接在原语言上推理</td></tr><tr><td>英语输入是否效果更好？</td><td>是，表现更强、内容更准确、表达更自然</td></tr><tr><td>多语言之间是否共享知识？</td><td>共享语义空间，但知识覆盖仍取决于训练数据分布</td></tr><tr><td>推荐的 Prompt 编写方式？</td><td>英文 Prompt + 中文输出 或 英文生成 + 翻译为中文</td></tr></tbody></table><hr><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://arxiv.org/abs/2010.11934">Massively Multilingual Models (mT5)</a></li><li><a href="https://huggingface.co/bigscience/bloom">BLOOM: a 176B Multilingual LLM</a></li><li><a href="https://arxiv.org/abs/2201.10005">XGLM: Multilingual Autoregressive Language Model</a></li><li><a href="https://openai.com/research/multilingual">OpenAI: Language models as multilingual translators</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下文章有ChatGPT生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;多语言大模型（Multilingual LLM）越来越普及，但一个常见的问题是：&lt;strong&gt;模型处理非英语语言时，是直</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="大模型" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="多语言" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>三种学习法核心精髓</title>
    <link href="http://yoursite.com/2025/08/04/20250804-san-chong-xue-xi-fa-he-xin-jing-sui/"/>
    <id>http://yoursite.com/2025/08/04/20250804-san-chong-xue-xi-fa-he-xin-jing-sui/</id>
    <published>2025-08-04T05:55:52.000Z</published>
    <updated>2025-08-07T04:15:13.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🧠-一、费曼学习法（Feynman-Technique）"><a href="#🧠-一、费曼学习法（Feynman-Technique）" class="headerlink" title="🧠 一、费曼学习法（Feynman Technique）"></a>🧠 一、费曼学习法（Feynman Technique）</h2><p><strong>核心理念：用教别人的方式来教自己。</strong></p><h3 id="📌-关键步骤："><a href="#📌-关键步骤：" class="headerlink" title="📌 关键步骤："></a>📌 关键步骤：</h3><ol><li><strong>选择概念</strong>：挑选你想学的知识点。  </li><li><strong>解释给小白听</strong>：用简单、口语化的语言讲解，好像在教一个完全不懂的人（比如小学生）。  </li><li><strong>找出盲点</strong>：当你卡住或讲不清楚，说明你还没真正理解。  </li><li><strong>回顾补全</strong>：回到原材料查漏补缺，搞清楚所有细节。  </li><li><strong>重新讲解 &amp; 简化</strong>：再次讲解，并尽量用更简单的语言表达。</li></ol><p>✅ <strong>核心关键：</strong>  </p><blockquote><p>“能讲清楚，才算真正学懂。”</p></blockquote><hr><h2 id="🧩-二、西蒙学习法（Herbert-Simon-Learning-Strategy）"><a href="#🧩-二、西蒙学习法（Herbert-Simon-Learning-Strategy）" class="headerlink" title="🧩 二、西蒙学习法（Herbert Simon Learning Strategy）"></a>🧩 二、西蒙学习法（Herbert Simon Learning Strategy）</h2><p>（又称“问题解决导向学习”Problem-Solving Learning）</p><h3 id="📌-关键特点："><a href="#📌-关键特点：" class="headerlink" title="📌 关键特点："></a>📌 关键特点：</h3><ol><li><strong>以问题为驱动</strong>：学习过程围绕真实问题展开，而不是被动接收知识。  </li><li><strong>建立知识结构</strong>：通过已有的知识和逻辑推理解决新问题。  </li><li><strong>重视反思与优化</strong>：每一次问题解决都伴随着策略的反思和迭代。</li></ol><p>✅ <strong>核心关键：</strong>  </p><blockquote><p>“用解决问题的方式构建知识体系。”</p></blockquote><hr><h2 id="📝-三、康奈尔学习法（Cornell-Note-taking-System）"><a href="#📝-三、康奈尔学习法（Cornell-Note-taking-System）" class="headerlink" title="📝 三、康奈尔学习法（Cornell Note-taking System）"></a>📝 三、康奈尔学习法（Cornell Note-taking System）</h2><p><strong>核心理念：结构化笔记提升理解与记忆。</strong></p><h3 id="📌-五大步骤："><a href="#📌-五大步骤：" class="headerlink" title="📌 五大步骤："></a>📌 五大步骤：</h3><ol><li><strong>笔记区（右侧大块）</strong>：上课或阅读时记下主要内容。  </li><li><strong>提问区（左侧小块）</strong>：课后写下问题、关键词或提示语，用于复习时自测。  </li><li><strong>总结区（底部）</strong>：用自己的话总结整页笔记的核心。  </li><li><strong>回顾复习</strong>：定期回看并测试自己，强化记忆。  </li><li><strong>联结思考</strong>：不断将新知识与旧知识联系起来。</li></ol><p>✅ <strong>核心关键：</strong>  </p><blockquote><p>“记笔记不是为了记录，而是为了思考和复习。”</p></blockquote><hr><h2 id="🔍-总结对比表"><a href="#🔍-总结对比表" class="headerlink" title="🔍 总结对比表"></a>🔍 总结对比表</h2><table><thead><tr><th>学习法</th><th>核心关键</th><th>适用场景</th></tr></thead><tbody><tr><td>费曼学习法</td><td>教别人来检验理解深度</td><td>理论知识、概念型内容</td></tr><tr><td>西蒙学习法</td><td>以解决问题构建知识结构</td><td>数理逻辑、编程、工程类内容</td></tr><tr><td>康奈尔学习法</td><td>结构化笔记促进理解与回顾</td><td>听课、读书、考试复习</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;🧠-一、费曼学习法（Feynman-Technique）&quot;&gt;&lt;a href=&quot;#🧠-一、费曼学习法（Feynman-Technique）&quot; class=&quot;headerlink&quot; title=&quot;🧠 一、费曼学习法（Feynman Technique）&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="学习法" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>quick_worker 项目分析：基于 Channel 的高效异步批处理与 CPU 空转问题解析</title>
    <link href="http://yoursite.com/2025/07/17/20250717-quick-worker-xiang-mu-fen-xi-ji-yu-channel-de-gao-xiao-yi-bu-pi-chu-li-yu-cpu-kong-zhuan-wen-ti-jie-xi/"/>
    <id>http://yoursite.com/2025/07/17/20250717-quick-worker-xiang-mu-fen-xi-ji-yu-channel-de-gao-xiao-yi-bu-pi-chu-li-yu-cpu-kong-zhuan-wen-ti-jie-xi/</id>
    <published>2025-07-16T16:20:44.000Z</published>
    <updated>2025-07-16T16:22:06.782Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Kingson4Wu/quick_worker"><code>quick_worker</code></a> 是一个用 Go 实现的轻量级异步批处理框架。它通过 channel 和 goroutine 构建了一个高效的生产者-消费者模型，支持按批量大小或超时触发数据处理，适合高并发、吞吐敏感的场景。</p><p>本文将围绕其核心并发模型进行分析，重点讨论：</p><ul><li>是否存在 CPU 空转（Busy Waiting）问题</li><li><code>select</code> 和 channel 的阻塞特性</li><li>在什么情况下应考虑使用 <code>sync.Cond</code> 替代主动轮询</li></ul><hr><h3 id="一、项目核心架构概览"><a href="#一、项目核心架构概览" class="headerlink" title="一、项目核心架构概览"></a>一、项目核心架构概览</h3><p><code>quick_worker</code> 的核心工作流程：</p><ol><li><strong>数据投递</strong>：调用方通过 <code>Produce</code> 方法投递任务数据。</li><li><strong>缓冲通道</strong>：数据进入内部 <code>dataChan</code> 缓冲通道。</li><li><strong>消费者循环</strong>：独立的消费者 goroutine 执行 <code>consume</code> 方法，负责从通道中取出数据并批量处理。</li><li><strong>触发机制</strong>：处理可以由达到最大批量（maxBatchSize）或等待超时（maxWaitDuration）触发。</li><li><strong>退出控制</strong>：通过 <code>doneChan</code> 通知消费者优雅退出。</li></ol><p>这一模型兼具性能与可靠性，典型用于日志聚合、异步队列、延迟任务聚合等场景。</p><hr><h3 id="二、关于-CPU-空转（Busy-Waiting）问题的分析"><a href="#二、关于-CPU-空转（Busy-Waiting）问题的分析" class="headerlink" title="二、关于 CPU 空转（Busy Waiting）问题的分析"></a>二、关于 CPU 空转（Busy Waiting）问题的分析</h3><h4 id="1-消费者循环是否会导致空转？"><a href="#1-消费者循环是否会导致空转？" class="headerlink" title="1. 消费者循环是否会导致空转？"></a>1. 消费者循环是否会导致空转？</h4><p><code>core/worker.go</code> 中的主循环如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, ok := &lt;-w.dataChan:</span><br><span class="line">        <span class="comment">// 接收并处理数据</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">        <span class="comment">// 超时触发处理</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-w.doneChan:</span><br><span class="line">        <span class="comment">// 接收到退出信号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该循环具有以下特性：</p><ul><li><strong>select 是阻塞式的</strong>：当所有分支都不满足时，<code>select</code> 会自动挂起，不占用 CPU。</li><li>只要 <code>dataChan</code> 中没有数据、<code>timer</code> 没有到期、<code>doneChan</code> 没有信号，该 goroutine 会自然休眠。</li><li><strong>结论：这段代码不会导致 CPU 空转，是标准的 Go 并发写法。</strong></li></ul><h4 id="2-生产者逻辑是否安全？"><a href="#2-生产者逻辑是否安全？" class="headerlink" title="2. 生产者逻辑是否安全？"></a>2. 生产者逻辑是否安全？</h4><p>生产者调用 <code>Produce</code> 方法将数据投递进通道时，使用了非阻塞的 <code>select</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> w.dataChan &lt;- data:</span><br><span class="line">    <span class="comment">// 投递成功</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道已满，放弃投递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这避免了阻塞与死循环，也没有任何 busy loop 行为。</p><h4 id="3-可能导致空转的场景分析"><a href="#3-可能导致空转的场景分析" class="headerlink" title="3. 可能导致空转的场景分析"></a>3. 可能导致空转的场景分析</h4><table><thead><tr><th>场景</th><th>quick_worker 中是否存在</th><th>说明</th></tr></thead><tbody><tr><td><code>for &#123;&#125;</code> 死循环</td><td>❌</td><td>无此代码</td></tr><tr><td><code>for &#123; select &#123;&#125; &#125;</code> 且无阻塞分支</td><td>❌</td><td>每个 select 都含有阻塞通道</td></tr><tr><td>定时器设置过小，频繁唤醒</td><td>⚠️</td><td>频繁 wakeup 但不构成空转</td></tr><tr><td>通道满后生产者死循环 retry</td><td>❌</td><td>当前实现非阻塞，未重试</td></tr></tbody></table><h4 id="✅-总结结论："><a href="#✅-总结结论：" class="headerlink" title="✅ 总结结论："></a>✅ 总结结论：</h4><ul><li><code>quick_worker</code> 中的核心并发逻辑是以阻塞式 channel + timer 驱动的。</li><li>消费者 goroutine 不存在任何 busy waiting。</li><li>项目天然避免了 CPU 空转问题，性能开销可控。</li></ul><hr><h3 id="三、sync-Cond：在什么情况下必须使用它来避免-CPU-空转？"><a href="#三、sync-Cond：在什么情况下必须使用它来避免-CPU-空转？" class="headerlink" title="三、sync.Cond：在什么情况下必须使用它来避免 CPU 空转？"></a>三、sync.Cond：在什么情况下必须使用它来避免 CPU 空转？</h3><p>虽然 <code>quick_worker</code> 本身没有使用 <code>sync.Cond</code>，但了解它的用途对于设计其他复杂同步场景非常重要。</p><h4 id="1-什么是-CPU-空转？"><a href="#1-什么是-CPU-空转？" class="headerlink" title="1. 什么是 CPU 空转？"></a>1. 什么是 CPU 空转？</h4><p>CPU 空转（Busy Waiting）是指：<strong>线程在等待某个条件成立时，不阻塞、不 sleep，而是反复检查条件的状态，导致 CPU 被无意义地占用</strong>。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ready &#123;</span><br><span class="line">    <span class="comment">// 空转：一直检查条件，浪费 CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有任何阻塞操作，会让 CPU 持续忙碌。</p><h4 id="2-如何使用-sync-Cond-避免空转？"><a href="#2-如何使用-sync-Cond-避免空转？" class="headerlink" title="2. 如何使用 sync.Cond 避免空转？"></a>2. 如何使用 sync.Cond 避免空转？</h4><p><code>sync.Cond</code> 提供了条件变量机制，允许我们在等待某个条件时挂起 goroutine，直到条件成立被显式唤醒。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(&amp;mu)</span><br><span class="line"><span class="keyword">var</span> ready <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待方（消费者）</span></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> !ready &#123;</span><br><span class="line">    cond.Wait() <span class="comment">// 阻塞等待，自动释放锁，避免空转</span></span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知方（生产者）</span></span><br><span class="line">mu.Lock()</span><br><span class="line">ready = <span class="literal">true</span></span><br><span class="line">cond.Signal() <span class="comment">// 或 cond.Broadcast()</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li><code>Wait()</code> 会阻塞 goroutine，而不是让它空转。</li><li><code>Signal()</code> 只唤醒一个等待者，<code>Broadcast()</code> 唤醒所有等待者。</li></ul><h4 id="3-使用-sync-Cond-的典型场景"><a href="#3-使用-sync-Cond-的典型场景" class="headerlink" title="3. 使用 sync.Cond 的典型场景"></a>3. 使用 sync.Cond 的典型场景</h4><table><thead><tr><th>适用场景</th><th>原因</th></tr></thead><tbody><tr><td>缓存读取等待写入</td><td>等待数据可用，不适合用 channel 表达</td></tr><tr><td>对象池等待资源释放</td><td>条件复杂或需共享状态，channel 难以表达</td></tr><tr><td>多线程 barrier 同步</td><td>等待多个条件成立后同时唤醒</td></tr><tr><td>控制 goroutine 启停</td><td>管理状态而不是数据流</td></tr></tbody></table><h4 id="4-channel-和-sync-Cond-的选择建议"><a href="#4-channel-和-sync-Cond-的选择建议" class="headerlink" title="4. channel 和 sync.Cond 的选择建议"></a>4. channel 和 sync.Cond 的选择建议</h4><table><thead><tr><th>特性</th><th>channel</th><th>sync.Cond</th></tr></thead><tbody><tr><td>数据流驱动</td><td>✅（首选）</td><td>❌（不适合）</td></tr><tr><td>条件状态驱动</td><td>❌（难表达）</td><td>✅（适合表达条件判断）</td></tr><tr><td>是否易用</td><td>简单直观</td><td>需要配合锁、小心竞态</td></tr><tr><td>是否阻塞</td><td>✅（天然阻塞）</td><td>✅（Wait 手动阻塞）</td></tr></tbody></table><p><strong>结论：</strong></p><blockquote><p>如果你在等待某个“条件”而非“数据”，又无法用 channel 表达，那么使用 <code>sync.Cond</code> 可以有效避免 busy loop。</p></blockquote><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li><code>quick_worker</code> 项目使用阻塞式 select 循环，无 busy loop 行为，不存在 CPU 空转问题。</li><li>Go 的 channel 和 timer 本身就是高效的阻塞机制，只要 select 内有阻塞分支，goroutine 就不会占用 CPU。</li><li>只有在使用 <code>for + 条件判断</code> 等原始自旋方式等待状态时，才需要引入 <code>sync.Cond</code>。</li><li><code>sync.Cond</code> 更适合资源池、复杂状态条件协作等无法使用 channel 描述的场景。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Kingson4Wu/quick_worker&quot;&gt;&lt;code&gt;quick_worker&lt;/code&gt;&lt;/a&gt; 是一个用 Go 实现的轻量级异步批处理框架。它通过 channel 和 goroutine 构建了一个高效的</summary>
      
    
    
    
    
    <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
    <category term="CPU" scheme="http://yoursite.com/tags/CPU/"/>
    
    <category term="批处理任务" scheme="http://yoursite.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>QuicKit：高效并发任务管理工具库详解</title>
    <link href="http://yoursite.com/2025/07/16/20250716-quickit-gao-xiao-bing-fa-ren-wu-guan-li-gong-ju-ku-xiang-jie/"/>
    <id>http://yoursite.com/2025/07/16/20250716-quickit-gao-xiao-bing-fa-ren-wu-guan-li-gong-ju-ku-xiang-jie/</id>
    <published>2025-07-16T14:50:57.000Z</published>
    <updated>2025-07-16T16:13:40.932Z</updated>
    
    <content type="html"><![CDATA[<p>在现代软件开发中，高效的任务管理与并发处理是提升系统性能的关键。<strong>QuicKit</strong> 是一个基于 Java 的工具库，专注于并发任务调度、执行控制、重试机制等通用能力的封装。本文将深入介绍 QuicKit 的核心功能及其实现原理。</p><hr><h2 id="1-延迟任务调度：DelayQueueUtils"><a href="#1-延迟任务调度：DelayQueueUtils" class="headerlink" title="1. 延迟任务调度：DelayQueueUtils"></a>1. 延迟任务调度：<code>DelayQueueUtils</code></h2><p><code>DelayQueueUtils</code> 使用 <strong>HashedWheelTimer</strong> 实现延迟任务的高效调度。</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li><strong>时间轮机制</strong>：将时间划分为多个槽（slots），类似时钟的刻度。</li><li><strong>任务分配</strong>：任务根据设定的延迟时间分配至对应槽中。</li><li><strong>槽激活</strong>：时间轮旋转，当指针指向某个槽时，执行该槽内的所有任务。</li></ul><blockquote><p>✅ 优势：极大减少内存消耗和调度开销，适合高频延迟任务场景。</p></blockquote><hr><h2 id="2-执行频率控制：ExecutionFrequencyUtils"><a href="#2-执行频率控制：ExecutionFrequencyUtils" class="headerlink" title="2. 执行频率控制：ExecutionFrequencyUtils"></a>2. 执行频率控制：<code>ExecutionFrequencyUtils</code></h2><p>用于<strong>控制任务执行频率</strong>，防止系统被大量任务压垮。</p><h3 id="实现原理：-1"><a href="#实现原理：-1" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li><strong>任务分片</strong>：将任务列表切分为多个子任务，每批任务在一定时间间隔内执行。</li><li><strong>频率限制</strong>：可配置每秒允许执行的任务数量，避免突发任务过载系统。</li></ul><blockquote><p>✅ 应用场景：接口限流、批量处理限速、系统保护。</p></blockquote><hr><h2 id="3-并行任务处理：ParallelTask"><a href="#3-并行任务处理：ParallelTask" class="headerlink" title="3. 并行任务处理：ParallelTask"></a>3. 并行任务处理：<code>ParallelTask</code></h2><p>提供简洁高效的<strong>并行处理能力</strong>，充分利用多核 CPU 性能。</p><h3 id="实现原理：-2"><a href="#实现原理：-2" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li><strong>并行流</strong>：基于 Java 8 的 <code>parallelStream()</code> 并行处理任务。</li><li><strong>线程池管理</strong>：使用 <code>ExecutorService</code> 管理线程，降低线程创建销毁开销。</li></ul><blockquote><p>✅ 适用场景：批量任务处理、并发计算、数据转换等。</p></blockquote><hr><h2 id="4-重试机制：RetryUtils"><a href="#4-重试机制：RetryUtils" class="headerlink" title="4. 重试机制：RetryUtils"></a>4. 重试机制：<code>RetryUtils</code></h2><p>内置灵活的<strong>重试机制</strong>，应对任务失败后的自动恢复。</p><h3 id="实现原理：-3"><a href="#实现原理：-3" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li><strong>重试策略配置</strong>：通过 <code>RetryerBuilder</code> 设置重试次数、间隔、终止条件等。</li><li><strong>异常捕获与处理</strong>：根据异常类型与策略自动判断是否重试。</li></ul><blockquote><p>✅ 典型用途：数据库重试、远程服务调用、临时异常容忍。</p></blockquote><hr><h2 id="5-读写锁封装：ReadWriteLockWrapper"><a href="#5-读写锁封装：ReadWriteLockWrapper" class="headerlink" title="5. 读写锁封装：ReadWriteLockWrapper"></a>5. 读写锁封装：<code>ReadWriteLockWrapper</code></h2><p>封装 Java 原生 <code>ReentrantReadWriteLock</code>，简化并发数据访问控制。</p><h3 id="实现原理：-4"><a href="#实现原理：-4" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li><strong>读写分离</strong>：多个线程可同时读，写需独占。</li><li><strong>锁降级支持</strong>：支持写锁降级为读锁，提升吞吐性能。</li></ul><blockquote><p>✅ 适用场景：缓存读取、配置中心、共享资源管理等。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>QuicKit</strong> 通过提供一系列高性能并发工具，极大简化了任务调度、线程管理与错误恢复的复杂性。无论你在构建分布式系统、服务中间件，还是日常业务逻辑开发，QuicKit 都是一个值得使用的并发基础组件库。</p><hr><p>📦 <strong>项目地址</strong>：<br>👉 <a href="https://github.com/Kingson4Wu/QuicKit">https://github.com/Kingson4Wu/QuicKit</a></p><p>📚 <strong>文档地址</strong>：<br>👉 <a href="https://deepwiki.com/Kingson4Wu/QuicKit">https://deepwiki.com/Kingson4Wu/QuicKit</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在现代软件开发中，高效的任务管理与并发处理是提升系统性能的关键。&lt;strong&gt;QuicKit&lt;/strong&gt; 是一个基于 Java 的工具库，专注于并发任务调度、执行控制、重试机制等通用能力的封装。本文将深入介绍 QuicKit 的核心功能及其实现原理。&lt;/p&gt;
&lt;hr</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="延迟队列" scheme="http://yoursite.com/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    
    <category term="频率控制" scheme="http://yoursite.com/tags/%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6/"/>
    
    <category term="失败重试" scheme="http://yoursite.com/tags/%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"/>
    
    <category term="读写锁" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>刷LeetCode总结的算法基础和套路</title>
    <link href="http://yoursite.com/2025/07/09/20250709-shua-leetcode-zong-jie-de-suan-fa-ji-chu-he-tao-lu/"/>
    <id>http://yoursite.com/2025/07/09/20250709-shua-leetcode-zong-jie-de-suan-fa-ji-chu-he-tao-lu/</id>
    <published>2025-07-09T07:20:22.000Z</published>
    <updated>2025-07-30T07:17:43.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近重新刷LeetCode，对一些算法基础和套路做下总结，以做备忘</p></blockquote></blockquote><hr><h1 id="简要分类总结"><a href="#简要分类总结" class="headerlink" title="简要分类总结"></a>简要分类总结</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数组（Array）</li><li>链表（Linked List） </li><li>哈希表（HashMap &#x2F; HashSet）</li><li>堆（Heap）<ul><li>最大堆 &#x2F; 最小堆</li><li>常用于：优先队列、Top K、调度排序</li></ul></li><li>栈 &#x2F; 队列（Stack &#x2F; Queue）<ul><li>DFS 通常借助栈实现，BFS 借助队列</li></ul></li><li>树（Tree）<ul><li>普通二叉树</li><li>二叉搜索树（BST）</li><li>平衡二叉树（AVL &#x2F; 红黑树）</li><li>字典树（Trie）</li><li>线段树（Segment Tree）</li><li>树状数组（Fenwick Tree）</li><li>并查集</li></ul></li><li>图（Graph）<ul><li>表示方式：邻接表、邻接矩阵</li><li>有向图 &#x2F; 无向图，带权图 &#x2F; 无权图</li><li>拓扑排序<ul><li>Kahn 算法（BFS 实现）</li><li>DFS 逆后序（递归 + 回退）</li><li>用于检测有向图中是否存在环、任务调度等</li></ul></li><li>最短路径算法：Dijkstra、Floyd、Bellman-Ford（带权图最短路径）</li><li>最小生成树算法：Kruskal &#x2F; Prim</li><li>稠密图和稀疏图<ul><li>稠密图：边很多，接近“完全图”</li><li>稀疏图：边很少，大多数节点之间没有直接连接</li></ul></li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>遍历算法<ul><li>深度优先搜索（DFS）<ul><li>栈结构实现（递归或手动栈）</li><li>回溯 （&#x3D; DFS + 剪枝 + 状态恢复（回退））<ul><li>常用于：组合、排列、子集、数独、八皇后等问题</li></ul></li></ul></li><li>广度优先搜索（BFS）<ul><li>队列结构实现，逐层遍历</li></ul></li></ul></li><li>排序（冒泡、快速、堆）</li><li>快慢指针&#x2F; 双指针</li><li>滑动窗口</li><li>单调栈 &#x2F; 单调队列</li><li>二分查找</li><li>分治算法（Divide &amp; Conquer）</li><li>贪心算法（Greedy）</li><li>动态规划（DP）<ul><li>背包问题（0-1 背包、子集背包、完全背包）</li><li>子序列问题（LIS 最长递增子序列、LCS 最长公共子序列）</li><li>区间 DP &#x2F; 状态压缩 &#x2F; 滚动数组</li></ul></li><li>回溯算法（Backtracking）<ul><li>用于枚举所有可能解，如全排列、组合 &#x2F; 子集</li></ul></li></ul><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li><p>与数组不同，链表在构建子链时不会增加额外的空间复杂度。因此可以放心地构造子链，无需考虑节点交换的问题，也不必执着于“原地交换”的思路。</p></li><li><p>使用哨兵节点是一种常见技巧，它可以避免处理头指针等特殊情况，在代码实现上更加简洁。</p><ul><li><strong>链表内指定区间反转：</strong><br>给定一个单链表的头指针 <code>head</code>，以及两个整数 <code>left</code> 和 <code>right</code>（其中 <code>left &lt;= right</code>），请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> m == n || head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哨兵节点，避免处理头指针的特殊情况</span></span><br><span class="line">    dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 找到第 m-1 个节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转 m 到 n 之间的节点，采用头插法</span></span><br><span class="line">    start := pre.Next      <span class="comment">// 第 m 个节点</span></span><br><span class="line">    then := start.Next     <span class="comment">// 第 m+1 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n-m; i++ &#123;</span><br><span class="line">        start.Next = then.Next</span><br><span class="line">        then.Next = pre.Next</span><br><span class="line">        pre.Next = then</span><br><span class="line">        then = start.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li><p><strong>二叉树遍历（先序、中序、后序）</strong></p><ul><li>先序（中左右）、中序（左中右）、后序（左右中）</li><li>包含递归与非递归两种实现方式</li><li><strong>DFS</strong>：先序 &#x2F; 中序 &#x2F; 后序（递归 &#x2F; 栈实现）</li><li><strong>BFS</strong>：层序遍历（借助队列实现）</li></ul></li><li><p><strong>二叉查找树（Binary Search Tree，简称 BST）</strong></p><ul><li>左子树所有节点的值均小于根节点，右子树所有节点的值均大于根节点（<strong>不允许等于</strong>）</li><li><strong>中序遍历结果是升序序列</strong></li></ul></li><li><p><strong>完全二叉树</strong></p><ul><li>如果一棵深度为 <code>h</code> 的二叉树，除了第 <code>h</code> 层，其它每一层的节点数都达到最大值，并且第 <code>h</code> 层的节点都尽量靠左排列，则该树是完全二叉树</li><li>第 <code>h</code> 层可能包含 <code>1 ~ 2^h</code> 个节点</li><li><strong>堆</strong>（大顶堆 &#x2F; 小顶堆）是一种基于完全二叉树的结构</li></ul></li><li><p><strong>平衡二叉树（Balanced Binary Tree）</strong></p><ul><li>要么是空树，要么满足以下条件：左右子树的高度差的绝对值不超过 1，且左右子树也分别是平衡二叉树</li></ul></li></ul><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ul><li><p>树的遍历主要分为两类：</p><ul><li><p><strong>广度优先遍历（BFS）</strong>：也称层序遍历，使用队列实现</p></li><li><p><strong>深度优先遍历（DFS）</strong>：包括先序、中序、后序三种形式，可使用递归或栈实现</p><ul><li>递归</li><li>栈</li></ul></li></ul></li><li><p><strong>深度优先遍历（DFS）说明</strong></p><ul><li>使用递归实现 DFS 时，虽然代码中未显式使用栈，但其实是借助系统的 <strong>调用栈（Call Stack）</strong> 来进行函数的递归与回溯</li></ul></li></ul><h3 id="先序遍历（前序）"><a href="#先序遍历（前序）" class="headerlink" title="先序遍历（前序）"></a>先序遍历（前序）</h3><ul><li><p>栈实现流程：</p><ol><li>循环条件：<code>root != nil || len(stack) &gt; 0</code></li><li>若 <code>root != nil</code>，访问节点、入栈、转向左子树</li><li>否则出栈、转向右子树</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> preorder() []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">stack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, root.data)      <span class="comment">// 访问当前节点</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, root)       <span class="comment">// 入栈</span></span><br><span class="line">root = root.Lchild                <span class="comment">// 向左子树移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]        <span class="comment">// 出栈</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">root = root.Rchild                <span class="comment">// 转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li><p>栈实现流程：</p><ol><li>循环条件：<code>root != nil || len(stack) &gt; 0</code></li><li>若 <code>root != nil</code>，将当前节点入栈并转向左子树</li><li>否则出栈并访问节点</li><li>然后转向右子树</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> inorder() []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">stack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, root)       <span class="comment">// 入栈，等待回溯</span></span><br><span class="line">root = root.Lchild                <span class="comment">// 向左走</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]        <span class="comment">// 出栈</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res, root.data)      <span class="comment">// 访问节点</span></span><br><span class="line">root = root.Rchild                <span class="comment">// 转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例题目：判断一棵二叉树是否为二叉搜索树</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    inorder := math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> || root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt;= inorder &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder = root.Val</span><br><span class="line">        root = root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li>非递归实现关键：访问节点需保证其左右子树均已访问或为空</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> Postorder() []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">stack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> pre *TreeNode = <span class="literal">nil</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 如果是叶子节点，或子节点已访问，则访问当前节点</span></span><br><span class="line"><span class="keyword">if</span> (cur.Lchild == <span class="literal">nil</span> &amp;&amp; cur.Rchild == <span class="literal">nil</span>) || (pre != <span class="literal">nil</span> &amp;&amp; (pre == cur.Lchild || pre == cur.Rchild)) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, cur.data)</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">pre = cur <span class="comment">// 标记当前已访问</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.Rchild != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Rchild)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Lchild != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Lchild)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><ul><li><p>删除节点的四种情况：</p><ol><li><p><strong>叶子节点（无子节点）</strong></p><ul><li>直接删除，返回 <code>nil</code>。</li></ul></li><li><p><strong>只有左子树</strong></p><ul><li>用左子节点替代当前节点，返回 <code>root.Left</code>。</li></ul></li><li><p><strong>只有右子树</strong></p><ul><li>用右子节点替代当前节点，返回 <code>root.Right</code>。</li></ul></li><li><p><strong>左右子树都有</strong></p><ul><li>找右子树中最小的节点（即<strong>后继 successor</strong>），</li><li>用 successor 的值替代当前节点的值，</li><li>然后在右子树中递归删除该 successor 节点。</li></ul></li></ol></li><li><p>情况 4 的说明：</p><ul><li>**右子树的最小节点（successor）**不一定是叶子节点；</li><li>它一定没有左子节点，但<strong>可能有右子节点</strong>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  10                        11        </span><br><span class="line"> /  \                      /  \</span><br><span class="line">5    15                   5   15</span><br><span class="line">    /                         /  </span><br><span class="line">   11       --&gt;             13</span><br><span class="line">     \                     /  \  </span><br><span class="line">     13                   12  14</span><br><span class="line">    /  \</span><br><span class="line">   12   14</span><br></pre></td></tr></table></figure><ul><li><p>什么是“递归删除 successor 节点”？</p><ul><li>当我们删除一个节点（设为 <code>root</code>）且其有左右子树时，选择右子树中最小节点（successor）作为替代；</li><li>但此时右子树中仍存在原来的 successor 节点，因此需在右子树中递归删除该节点；</li><li>这样才能确保整棵树依然符合**二叉搜索树（BST）**的性质。</li></ul></li></ul><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> key &lt; root.Val &#123;</span><br><span class="line">root.Left = deleteNode(root.Left, key)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> key &gt; root.Val &#123;</span><br><span class="line">root.Right = deleteNode(root.Right, key)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况4：左右子树都有</span></span><br><span class="line"><span class="comment">//需要找右子树的最小值的结点, 最小的一定在最左边</span></span><br><span class="line">successor := root.Right</span><br><span class="line"><span class="keyword">for</span> successor.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">successor = successor.Left</span><br><span class="line">&#125;</span><br><span class="line">successor.Right = deleteNode(root.Right, successor.Val)</span><br><span class="line">successor.Left = root.Left</span><br><span class="line"><span class="keyword">return</span> successor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组（Fenwick-Tree-x2F-Binary-Indexed-Tree）"><a href="#树状数组（Fenwick-Tree-x2F-Binary-Indexed-Tree）" class="headerlink" title="树状数组（Fenwick Tree &#x2F; Binary Indexed Tree）"></a>树状数组（Fenwick Tree &#x2F; Binary Indexed Tree）</h2><ul><li><p><strong>适用场景</strong>：一维前缀和问题（如区间求和、频率统计等）</p></li><li><p><strong>核心思想</strong>：</p><ul><li>利用二进制的最低位（lowbit）来定位负责某段区间的节点</li><li>是一种空间压缩形式的前缀树结构</li></ul></li><li><p>一种可动态维护序列前缀和的数据结构，支持以下操作：</p><ul><li>**单点更新 <code>update(i, v)</code>**：将第 <code>i</code> 个位置的值增加 <code>v</code>（如本题中 <code>v = 1</code>）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(i <span class="type">int</span>, v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i &lt;= n &#123;  <span class="comment">// n 是树状数组的长度</span></span><br><span class="line">        bit[i] += v</span><br><span class="line">        i += i &amp; -i  <span class="comment">// 跳到下一个负责这个区间的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>**区间查询 <code>query(i)</code>**：查询区间 <code>[1..i]</code> 的前缀和</p><ul><li>通过跳跃式回溯累加，效率高</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 bit[1] 到 bit[i] 的前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res += bit[i]</span><br><span class="line">        i -= i &amp; -i  <span class="comment">// i &amp; -i 取最低位的 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="query-p-的跳跃计算示意"><a href="#query-p-的跳跃计算示意" class="headerlink" title="query(p) 的跳跃计算示意"></a>query(p) 的跳跃计算示意</h3><ul><li>树状数组 <code>bit[]</code> 示意如下：</li></ul><table><thead><tr><th>下标（i）</th><th>bit[i]</th><th>表示的区间</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>sum(1)</td></tr><tr><td>2</td><td>1</td><td>sum(1..2)</td></tr><tr><td>3</td><td>0</td><td>sum(3)</td></tr><tr><td>4</td><td>3</td><td>sum(1..4)</td></tr><tr><td>5</td><td>0</td><td>sum(5)</td></tr><tr><td>6</td><td>0</td><td>sum(5..6)</td></tr><tr><td>7</td><td>0</td><td>sum(7)</td></tr><tr><td>8</td><td>?</td><td>sum(1..8)</td></tr></tbody></table><ul><li><p>查询 <code>query(5)</code> 实际执行过程如下：</p><ul><li>第一次：<code>p = 5</code> → <code>sum += bit[5] = 0</code> → <code>p = 5 - 1 = 4</code></li><li>第二次：<code>p = 4</code> → <code>sum += bit[4] = 3</code> → <code>p = 4 - 4 = 0</code></li><li>退出循环，结果为 <code>sum = 3</code></li></ul></li><li><p>实际加了哪些区间：</p><ul><li><code>bit[5]</code> → 表示 <code>[5]</code></li><li><code>bit[4]</code> → 表示 <code>[1..4]</code></li><li>所以 <code>sum[1..5] = bit[5] + bit[4]</code></li></ul></li></ul><h3 id="为什么-x-amp-x-能取得-x-的最低位-1？"><a href="#为什么-x-amp-x-能取得-x-的最低位-1？" class="headerlink" title="为什么 x &amp; (-x) 能取得 x 的最低位 1？"></a>为什么 <code>x &amp; (-x)</code> 能取得 <code>x</code> 的最低位 1？</h3><ul><li><p>原理：使用补码</p><ul><li><code>-x = ^x + 1</code>（按位取反再加 1）</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x     = <span class="number">00001100</span></span><br><span class="line">-x    = <span class="number">11110100</span></span><br><span class="line">----------------</span><br><span class="line">x &amp; -x = <span class="number">00000100</span>  <span class="comment">// 取出最低位的 1</span></span><br></pre></td></tr></table></figure><ul><li>补码运算确保 <code>x &amp; -x</code> 恰好保留最低位的 1，其它位互斥</li></ul><h3 id="树状数组的安全构造方式"><a href="#树状数组的安全构造方式" class="headerlink" title="树状数组的安全构造方式"></a>树状数组的安全构造方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算最小安全长度（为离散化后的数组保留空间）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSafeFenwickArraySize</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    nextPowerOf2 := <span class="number">1</span> &lt;&lt; bits.Len(<span class="type">uint</span>(n))</span><br><span class="line">    <span class="keyword">return</span> nextPowerOf2 + <span class="number">1</span> <span class="comment">// +1 处理边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：315-计算右侧小于当前元素的个数"><a href="#例题：315-计算右侧小于当前元素的个数" class="headerlink" title="例题：315. 计算右侧小于当前元素的个数"></a>例题：<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/">315. 计算右侧小于当前元素的个数</a></h2><ul><li><strong>题意</strong>：返回数组 <code>counts</code>，其中 <code>counts[i]</code> 表示 <code>nums[i]</code> 右侧比它小的元素数量</li><li><strong>解法</strong>：树状数组 + 离散化优化空间</li></ul><h3 id="解题流程："><a href="#解题流程：" class="headerlink" title="解题流程："></a>解题流程：</h3><ol><li><p><strong>离散化</strong>：将原数组值映射到连续整数范围（防止值域过大）</p></li><li><p><strong>从后向前遍历</strong>：</p><ul><li>查询当前数 <strong>前面比它小</strong> 的数的出现次数 → <code>query(id - 1)</code></li><li>更新当前数出现次数 → <code>update(id)</code></li></ul></li><li><p><strong>树状数组操作时间复杂度：O(log n)</strong></p></li></ol><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 离散化映射：数值 -&gt; 索引</span></span><br><span class="line">    numToId := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> &#123;</span><br><span class="line">        set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            set[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(set))</span><br><span class="line">        <span class="keyword">for</span> num := <span class="keyword">range</span> set &#123;</span><br><span class="line">            a = <span class="built_in">append</span>(a, num)</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Ints(a)</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num := <span class="keyword">range</span> a &#123;</span><br><span class="line">            m[num] = i + <span class="number">1</span>  <span class="comment">// 从 1 开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;(nums)</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums)+<span class="number">5</span>)</span><br><span class="line">    lowBit := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    &#125;</span><br><span class="line">    query := <span class="function"><span class="keyword">func</span><span class="params">(pos <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        ret := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pos &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ret += c[pos]</span><br><span class="line">            pos -= lowBit(pos)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    update := <span class="function"><span class="keyword">func</span><span class="params">(pos <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> pos &lt; <span class="built_in">len</span>(c) &#123;</span><br><span class="line">            c[pos]++</span><br><span class="line">            pos += lowBit(pos)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        id := numToId[nums[i]]</span><br><span class="line">        ans[i] = query(id - <span class="number">1</span>)</span><br><span class="line">        update(id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><ul><li><p><strong>适用场景</strong>：支持区间查询 + 单点或区间修改等</p></li><li><p><strong>典型用途</strong>：</p><ul><li>区间最大值、最小值、区间和</li><li>区间赋值、区间加法（懒标记 &#x2F; Lazy Propagation）</li></ul></li><li><p><strong>结构特征</strong>：</p><ul><li>完全二叉树结构</li><li>每个节点维护一个区间的信息</li><li>父节点信息由左右子树合并而来</li></ul></li></ul><h2 id="例题：699-掉落的方块"><a href="#例题：699-掉落的方块" class="headerlink" title="例题：699. 掉落的方块"></a>例题：<a href="https://leetcode.cn/problems/falling-squares/description/">699. 掉落的方块</a></h2><ul><li>问题：模拟落方块过程，返回每一步的最高高度</li><li>典型的线段树区间最大值更新与查询问题</li></ul><h3 id="解题流程：-1"><a href="#解题流程：-1" class="headerlink" title="解题流程："></a>解题流程：</h3><ol><li><p><strong>离散化所有坐标</strong>：防止空间浪费（坐标最大值可达 10^9）</p></li><li><p><strong>使用线段树</strong>维护每个区间的最大高度</p></li><li><p><strong>每次插入一个方块</strong>：</p><ul><li>查询当前 <code>[left, right]</code> 区间的最大高度 <code>h</code></li><li>更新该区间的值为 <code>h + sideLength</code></li><li>记录全局最大高度</li></ul></li></ol><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="例题：684-冗余连接"><a href="#例题：684-冗余连接" class="headerlink" title="例题：684. 冗余连接"></a>例题：<a href="https://leetcode.cn/problems/redundant-connection/description">684. 冗余连接</a></h2><ul><li>在含有一个环的无向图中找出一条可删边使其变为树</li></ul><h3 id="解题流程：-2"><a href="#解题流程：-2" class="headerlink" title="解题流程："></a>解题流程：</h3><ul><li>使用并查集判断边是否构成环：<ul><li>初始化每个节点为不同集合；<ul><li>遍历 edges 中每条边 (u, v)：<ul><li>如果 u 与 v 已在同一集合中，说明这条边构成环 → 返回它；</li><li>否则合并 u 和 v；</li></ul></li></ul></li><li>因为题目要求返回「最后构成环的边」，只需从前往后遍历一次即可。</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRedundantConnection</span><span class="params">(edges [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    parent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(edges)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> parent &#123;</span><br><span class="line">        parent[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> find <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    find = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent[x] != x &#123;</span><br><span class="line">            parent[x] = find(parent[x])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    union := <span class="function"><span class="keyword">func</span><span class="params">(from, to <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x, y := find(from), find(to)</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent[x] = y</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> edges &#123;</span><br><span class="line">        <span class="keyword">if</span> !union(e[<span class="number">0</span>], e[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h3 id="基本性质与操作（以最大堆为例）"><a href="#基本性质与操作（以最大堆为例）" class="headerlink" title="基本性质与操作（以最大堆为例）"></a>基本性质与操作（以最大堆为例）</h3><ol><li><p>最大堆的性质</p><ul><li>最大堆是一种<strong>完全二叉树</strong>，满足每个父节点的值都<strong>大于或等于</strong>其左右子节点的值。</li><li>虽然逻辑结构为树，实际通常使用<strong>数组</strong>来实现。</li></ul></li><li><p>元素的插入与删除方式</p><ul><li><p><strong>插入新节点</strong>：将元素追加到数组末尾，然后进行<strong>向上调整（Sift-Up）</strong>，直到堆序性恢复。</p></li><li><p><strong>删除任意节点</strong>：将目标节点与数组最后一个元素交换，然后删除最后一个元素：</p><ul><li>若新值<strong>大于父节点</strong> → 进行<strong>向上调整</strong>；</li><li>若新值<strong>小于任一子节点</strong> → 进行<strong>向下调整</strong>。</li></ul></li></ul></li><li><p>特殊操作：删除堆顶（最大值）</p><ul><li>删除堆顶（即数组第一个元素）时，将最后一个元素移至根节点位置，再进行<strong>向下调整（Sift-Down）</strong>，以恢复堆的结构。</li></ul></li><li><p>时间复杂度分析</p><ul><li><p><strong>插入</strong>或<strong>删除</strong>操作中，最多需要调整一条从叶节点到根节点或从根节点到叶节点的路径，因此时间复杂度均为：</p><blockquote><p>✅ <strong>O(log n)</strong></p></blockquote></li></ul></li><li><p>与二分查找的比较</p><ul><li><p><strong>二分查找</strong>的时间复杂度也是：</p><blockquote><p>✅ <strong>O(log n)</strong></p></blockquote></li><li><p>不过它依赖于<strong>有序数组</strong>，而最大堆只维护<strong>局部有序结构</strong>（即每个父节点大于子节点）。两者在原理和应用场景上存在本质区别。</p></li></ul></li></ol><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><ul><li><p>由两个部分组成：</p><ul><li><strong>顶点（Vertices）</strong>：图中的节点。</li><li><strong>边（Edges）</strong>：连接两个顶点的线段。</li></ul></li><li><p><strong>边用集合表示</strong>：一条边连接两个顶点，用 <code>&#123;A, B&#125;</code> 表示（不区分方向），区别于有向图中的 <code>(A, B)</code>。<br><strong>度（Degree）</strong>：一个顶点的度是连接它的边的数量（不考虑方向）。</p></li><li><p>无向图可以表示为：</p><ul><li>顶点：<code>&#123;A, B, C&#125;</code></li><li>边：<code>&#123;&#123;A, B&#125;, &#123;B, C&#125;&#125;</code></li></ul></li><li><p>图形示意：</p><ul><li><code>A —— B —— C</code></li></ul></li><li><p><strong>无向图的深度优先搜索（DFS）</strong></p><ul><li>从某个顶点开始；</li><li>标记为“已访问”；</li><li>遍历它的邻居；</li><li>对每一个未访问的邻居递归执行 DFS；</li><li>如果遇到没有未访问邻居的死胡同，则回退。</li></ul></li><li><p><strong>递归实现 DFS</strong>：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, start, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="built_in">print</span>(start)  <span class="comment"># 访问当前节点</span></span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[start]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(graph, neighbor, visited)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">dfs(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>非递归实现（使用栈）</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_iterative</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    stack = [start]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 为了保持访问顺序，反转邻居顺序</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> <span class="built_in">reversed</span>(graph[node]):</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    stack.append(neighbor)</span><br><span class="line"></span><br><span class="line">dfs_iterative(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>无向图 DFS 的注意事项</strong>：</p><ul><li><strong>防止死循环</strong>：必须使用 <code>visited</code> 集合记录已访问节点，因为无向图的边是双向的，若不记录，会在 A-B-A-B 间无限循环。</li><li><strong>图不连通的情况</strong>：只对一个起点 DFS 无法遍历所有节点。可对所有节点进行一次 DFS。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_all</span>(<span class="params">graph</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(graph, node, visited)</span><br></pre></td></tr></table></figure><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="有向图的拓扑排序"><a href="#有向图的拓扑排序" class="headerlink" title="有向图的拓扑排序"></a>有向图的拓扑排序</h3><ul><li><p>拓扑排序（Topological Sorting）适用于 <strong>有向无环图（DAG，Directed Acyclic Graph）</strong>。其目标是将所有顶点排成一个线性序列，使得每条边 <code>u → v</code> 中，顶点 <code>u</code> 排在 <code>v</code> 的前面。</p></li><li><p>举例说明：</p><ul><li><strong>学习顺序</strong>：先学 A，再学 B，最后学 C。</li><li><strong>任务依赖</strong>：任务 B 必须在任务 A 完成后执行。</li><li>将任务抽象为节点，依赖关系为边，则问题转化为 DAG 的拓扑排序。</li></ul></li><li><p><strong>适用范围</strong>：</p><ul><li>必须是有向无环图（DAG）。</li><li>若图中存在环，则无法进行拓扑排序。</li></ul></li><li><p><strong>拓扑排序的两种常用算法</strong>：</p><ul><li><p><strong>方法一：Kahn 算法（入度表 + 队列）</strong></p><ul><li>统计所有顶点的入度。</li><li>将入度为 0 的顶点加入队列。</li><li>从队列中取出顶点 <code>u</code> 加入结果序列。</li><li>删除 <code>u</code> 指向的边（使相邻顶点 <code>v</code> 入度减 1）。</li><li>若 <code>v</code> 入度变为 0，加入队列。</li><li>重复以上过程直至队列为空。</li><li>若最终结果序列包含所有节点，则拓扑排序成功；否则图中存在环。</li></ul></li><li><p><strong>方法二：DFS 法（后序入栈）</strong></p><ul><li>从未访问的节点开始 DFS。</li><li>递归访问其所有后继节点。</li><li>当前节点所有后继访问完成后，将其压入栈中。</li><li>所有节点访问完成后，从栈顶依次弹出即为拓扑序列。</li></ul></li></ul></li><li><p><strong>常见应用场景</strong>：</p><ul><li>编译器模块依赖分析</li><li>项目任务调度</li><li>数据处理管道排序</li><li>课程安排问题（Leetcode 207、210）</li></ul></li></ul><h3 id="Kahn-算法（Golang-实现）："><a href="#Kahn-算法（Golang-实现）：" class="headerlink" title="Kahn 算法（Golang 实现）："></a>Kahn 算法（Golang 实现）：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序（Kahn 算法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topologicalSort</span><span class="params">(graph <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">  inDegree := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化入度表</span></span><br><span class="line">  <span class="keyword">for</span> u := <span class="keyword">range</span> graph &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := inDegree[u]; !ok &#123;</span><br><span class="line">      inDegree[u] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> graph[u] &#123;</span><br><span class="line">      inDegree[v]++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入度为 0 的节点入队</span></span><br><span class="line">  <span class="keyword">var</span> queue []<span class="type">string</span></span><br><span class="line">  <span class="keyword">for</span> node, deg := <span class="keyword">range</span> inDegree &#123;</span><br><span class="line">    <span class="keyword">if</span> deg == <span class="number">0</span> &#123;</span><br><span class="line">      queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拓扑排序</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    node := queue[<span class="number">0</span>]</span><br><span class="line">    queue = queue[<span class="number">1</span>:]</span><br><span class="line">    result = <span class="built_in">append</span>(result, node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[node] &#123;</span><br><span class="line">      inDegree[neighbor]--</span><br><span class="line">      <span class="keyword">if</span> inDegree[neighbor] == <span class="number">0</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否存在环</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="built_in">len</span>(inDegree) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  graph := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;C&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;D&quot;</span>: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  order, ok := topologicalSort(graph)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;图中存在环，无法拓扑排序&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;拓扑排序结果：&quot;</span>, order)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Kahn 算法的核心逻辑</strong>：</p><ul><li>每次只处理入度为 0 的节点，即“无依赖”的任务。</li><li>处理后从图中移除该节点影响（即更新其邻接节点的入度）。</li><li>保证每个节点的依赖都先被处理。</li></ul></li><li><p><strong>为什么 Kahn 算法只适用于 DAG？</strong></p><ul><li>如果存在环，某些节点将永远无法变为入度 0，导致无法完成排序。</li><li>若排序结果节点数 &lt; 总节点数，说明图中存在环。</li></ul></li></ul><p>✅ <strong>因此：Kahn 算法不仅能进行拓扑排序，还能用于判断图中是否存在环。</strong></p><ul><li><strong>Kahn 算法实质上是 BFS 的变种</strong>，关注“入度为 0”的节点而不是“邻接点”。</li></ul><h3 id="Kahn-算法-vs-广度优先搜索（BFS）"><a href="#Kahn-算法-vs-广度优先搜索（BFS）" class="headerlink" title="Kahn 算法 vs 广度优先搜索（BFS）"></a>Kahn 算法 vs 广度优先搜索（BFS）</h3><table><thead><tr><th>项目</th><th>Kahn 算法（拓扑排序）</th><th>广度优先搜索（BFS）</th></tr></thead><tbody><tr><td>遍历方式</td><td>一层一层，按入度为 0 的点</td><td>一层一层，按邻接点</td></tr><tr><td>使用数据结构</td><td>队列（Queue）</td><td>队列（Queue）</td></tr><tr><td>访问顺序</td><td>所有无依赖的点先访问</td><td>当前点的所有邻居先访问</td></tr><tr><td>主要用途</td><td>拓扑排序 &#x2F; 检测环</td><td>遍历所有可达节点</td></tr></tbody></table><blockquote><p><strong>Kahn 算法 &#x3D; BFS 的拓扑排序版本</strong>，核心是基于“入度为 0”的节点层层推进，保证拓扑顺序合法。</p></blockquote><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol><li><p><code>for lower &lt;= upper</code> —— <strong>闭区间版本 <code>[lower, upper]</code></strong></p><ul><li><p><code>mid = (lower + upper) / 2</code>（向下取整）</p><ul><li>如果 <code>mid</code> 满足条件（要往左找更小或更左的）：<code>upper = mid - 1</code></li><li>如果不满足条件（要往右找）：<code>lower = mid + 1</code></li></ul></li><li><p><strong>是否跳过了 mid？</strong></p><ul><li>表面上看，<code>upper = mid - 1</code> 似乎跳过了 <code>mid</code></li><li>实际上，<code>mid</code> 已经被判断过，<code>lower</code> 没变，下一轮中 <code>lower == mid</code></li><li>循环仍会继续执行，直到 <code>lower &gt; upper</code> 时退出</li></ul></li><li><p><strong>示例分析：</strong></p><ul><li>在数组 <code>[3, 4, 5]</code> 中查找“第一个大于等于 4 的数”</li><li>初始区间为 <code>[3, 5]</code>，<code>mid = 4</code></li><li><code>mid = 4</code> 满足条件 → <code>upper = 3</code></li><li>下一轮区间为 <code>[3, 3]</code>，<code>mid = 3</code></li><li><code>mid = 3</code> 不满足条件 → <code>lower = 4</code></li><li>区间变为 <code>[4, 3]</code>，循环结束</li><li>返回 <code>lower = 4</code>，即最小满足条件的值</li></ul></li></ul></li><li><p><code>for lower &lt; upper</code> —— <strong>半开区间版本 <code>[lower, upper)</code></strong></p><ul><li>如果 <code>mid</code> 满足条件（要往左找）：<code>upper = mid</code></li><li>如果不满足条件：<code>lower = mid + 1</code></li><li>循环结束时 <code>lower == upper</code>，即为最小满足条件的位置</li></ul></li></ol><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>相邻元素两两比较并交换，使用双重循环；</li><li>若某次遍历中未发生任何交换，说明数组已有序，可提前结束；</li><li>代码示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        unChanged := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                unChanged = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> unChanged &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>通过一趟排序将序列划分为左右两个子区间，其中左边的元素都小于右边的元素，再分别对左右区间递归排序，从而实现整体有序。</p></li><li><p>分区逻辑说明（采用首元素为基准）：</p><ul><li>交替比较并交换元素值，最终确定基准值的位置；</li><li>每步都需判断 <code>low &lt; high</code>，不要遗漏；</li><li><code>high--</code> 与 <code>low++</code> 的条件是与 <code>temp</code>（基准值）进行比较。</li></ul></li><li><p>TopK 剪枝优化（用于只需前K个元素的场景）：</p><ul><li>若 <code>mid &gt; k</code>，递归处理左边；</li><li>若 <code>mid &lt; k</code>，递归处理右边。</li></ul></li><li><p>分区函数定义模板：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 首先从 high 开始比较，循环 high--，跳出后赋值；</span></span><br><span class="line">    <span class="comment">// 然后从 low 开始比较，同理；</span></span><br><span class="line">    <span class="comment">// 每步都要判断 low &lt; high；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>快速排序递归模板：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span></span><br><span class="line">quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span></span><br><span class="line">    quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid := partition(arr, start, end)</span><br><span class="line">        quick(arr, start, mid)</span><br><span class="line">        quick(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">    quick(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，low &lt; high 判断不要漏！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    temp := arr[low]</span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        <span class="keyword">for</span> low &lt; high &amp;&amp; arr[high] &gt;= temp &#123;</span><br><span class="line">            high--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">            arr[low] = arr[high]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> low &lt; high &amp;&amp; arr[low] &lt; temp &#123;</span><br><span class="line">            low++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">            arr[high] = arr[low]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = temp</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前K个最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSortTopK</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end, k <span class="type">int</span>)</span></span></span><br><span class="line">    quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end, k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid := partition(arr, start, end)</span><br><span class="line">        <span class="keyword">if</span> mid &gt; k &#123;</span><br><span class="line">            quick(arr, start, mid, k)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid &lt; k &#123;</span><br><span class="line">            quick(arr, mid+<span class="number">1</span>, end, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quick(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>堆是一种<strong>完全二叉树结构</strong>；</li><li><strong>最大堆</strong>：父节点 ≥ 子节点；<strong>最小堆</strong>：父节点 ≤ 子节点；</li></ol><ul><li><p><strong>实现步骤</strong>：</p><ol><li><p><strong>调整堆（自上而下）</strong>：</p><ul><li>函数签名：<code>adjust(nums []int, root int, length int)</code></li><li>从当前根节点开始，比较左右子节点，找出较大者与根交换，递归向下直到无需调整。</li></ul></li><li><p><strong>初始化堆</strong>：</p><ul><li>从最后一个非叶子节点（<code>length/2</code>）开始，依次向上调整；</li></ul></li><li><p><strong>堆排序过程</strong>：</p><ul><li>每次将堆顶元素与末尾交换，再对堆顶进行调整；</li><li>排序范围逐步缩小，直到全部有序。</li></ul></li></ol></li><li><p><strong>最大堆调整函数</strong>：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">(nums []<span class="type">int</span>, root, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    child := root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child &lt; length &#123;</span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; length &amp;&amp; nums[child+<span class="number">1</span>] &gt; nums[child] &#123;</span><br><span class="line">            child++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[child] &lt;= nums[root] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[child], nums[root] = nums[root], nums[child]</span><br><span class="line">        root = child</span><br><span class="line">        child = root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化堆（自底向上）</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序过程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">        adjust(nums, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大堆取 TopK（前K大）且有序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSortTopK</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前K大元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="built_in">len</span>(nums)<span class="number">-1</span>-k; i-- &#123;</span><br><span class="line">        nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">        adjust(nums, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-k:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️注意事项：</p><ul><li>初始化堆：自底向上遍历构建，但每个节点的调整是自上而下；</li><li>排序时：堆顶与尾部交换，再调整堆顶；</li><li><code>adjust</code> 函数中需确保越界处理、优先选择较大子节点交换；</li></ul></blockquote><h1 id="贪心算法（Greedy）"><a href="#贪心算法（Greedy）" class="headerlink" title="贪心算法（Greedy）"></a>贪心算法（Greedy）</h1><ul><li><p><strong>贪心算法：通过局部最优解实现全局最优</strong></p></li><li><p><a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p><ul><li>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</li><li>判断你是否能够到达最后一个下标</li></ul></li><li><p>遍历数组，并实时维护「最远可以到达的位置」</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mostIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt;= mostIndex &#123;</span><br><span class="line">            mostIndex = max(mostIndex, i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> mostIndex &gt;= <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">45. 跳跃游戏 II</a></p><ul><li>计算到达最后一个位置的最小跳跃次数</li></ul></li><li><p><strong>贪心 + 正向查找「可达的最远位置」</strong></p><ul><li>每次在当前跳跃的范围内，选择可以跳得最远的位置，作为下一跳的终点</li></ul></li><li><p><strong>贪心策略的正确性：</strong></p><ul><li>在当前跳跃范围内尽量跳得远，可以最大化下一跳的「选择空间」</li><li>避免走回头路或多跳一次的情况</li></ul></li><li><p><strong>为什么不遍历到最后一个元素？</strong></p><ul><li><p>跳到最后一个位置时，必然是在前一步完成跳跃</p></li><li><p>如果访问 <code>i == len(nums) - 1</code>，可能导致「多跳一步」</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    end, farthest := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    steps := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;</span><br><span class="line">            steps++</span><br><span class="line">            end = farthest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h1><ul><li><p><strong>动态规划的本质</strong>：通过<strong>穷举所有可能解法</strong>来寻找最优解。</p><ul><li>常见的穷举方式有两种：<strong>回溯算法</strong>和<strong>动态规划</strong>。回溯是暴力尝试每种可能，动态规划则利用<strong>状态转移方程</strong>推导各个状态。</li><li>动态规划相比暴力穷举更高效，其核心优势在于：<strong>利用状态转移 + 记忆</strong>，<strong>消除重复计算的子问题（重叠子问题）</strong>。</li></ul></li><li><p>动态规划问题通常具有大量<strong>重叠子问题</strong>，直接穷举效率极低，因此需借助以下两种优化方式：</p><ul><li>使用 <strong>备忘录（记忆化递归）</strong> 或 <strong>DP table（递推表格）</strong> 来<strong>避免重复计算</strong>；</li><li>其中，<strong>记忆化递归为自顶向下</strong>，<strong>DP table 为自底向上</strong>。</li></ul></li><li><p><strong>动态规划 &#x3D; 穷举 + 剪枝</strong></p></li><li><p>动态规划的标准解题流程：</p><ol><li>明确“<strong>状态</strong>”和“<strong>选择</strong>”；</li><li>定义 <code>dp</code> 数组或函数的含义；</li><li>写出<strong>状态转移方程（递推关系）</strong>。</li></ol></li><li><p>常通过<strong>状态压缩</strong>优化空间复杂度，例如将 <code>O(N^2)</code> 降为 <code>O(N)</code>。</p></li></ul><h2 id="背包问题（Knapsack）"><a href="#背包问题（Knapsack）" class="headerlink" title="背包问题（Knapsack）"></a>背包问题（Knapsack）</h2><h3 id="✅-分类依据：每个物品的使用次数是否受限"><a href="#✅-分类依据：每个物品的使用次数是否受限" class="headerlink" title="✅ 分类依据：每个物品的使用次数是否受限"></a>✅ 分类依据：<strong>每个物品的使用次数是否受限</strong></h3><table><thead><tr><th>问题类型</th><th>每种物品使用次数</th><th>描述</th></tr></thead><tbody><tr><td><strong>0-1 背包问题</strong></td><td>最多使用一次</td><td>每件物品要么选，要么不选，不能重复使用。</td></tr><tr><td><strong>子集和问题</strong></td><td>最多使用一次</td><td>0-1 背包的特例：目标是恰好凑出某个和，而非最大价值。</td></tr><tr><td><strong>完全背包问题</strong></td><td>可无限次使用</td><td>每种物品可选多次，适用于硬币兑换、无限供给的资源选择等场景。</td></tr></tbody></table><h3 id="🎯-拓展理解："><a href="#🎯-拓展理解：" class="headerlink" title="🎯 拓展理解："></a>🎯 拓展理解：</h3><ul><li><strong>0-1 背包</strong> &#x3D; 最经典模型，用于资源受限问题。</li><li><strong>子集和问题</strong> &#x3D; 判断“是否可以凑出某个值”，不关心价值。</li><li><strong>完全背包</strong> &#x3D; 每种物品无限可选，常见于无限物品、找零等问题。</li></ul><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><ul><li><p><strong>题目描述</strong></p><ul><li>给定一个容量为 <code>W</code> 的背包，以及 <code>N</code> 个物品，每个物品有：重量 <code>wt[i]</code> 和价值 <code>val[i]</code></li><li>每种物品只能选择一次，求在不超过总容量 <code>W</code> 的前提下，最大可获得的总价值。</li></ul></li><li><p><strong>解题思路</strong></p><ul><li><p>状态定义：<code>dp[i][w]</code> 表示前 <code>i</code> 个物品中，容量为 <code>w</code> 的背包所能达到的最大价值。</p></li><li><p>状态转移：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w &lt; wt[i<span class="number">-1</span>]:</span><br><span class="line">    dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></li><li><p>初始化：</p><ul><li><code>dp[0][..] = 0</code>：没有物品可选，价值为 0；</li><li><code>dp[..][0] = 0</code>：背包容量为 0，价值也为 0。</li></ul></li></ul></li><li><p><strong>代码实现</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(W <span class="type">int</span>, wt, val []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    N := <span class="built_in">len</span>(wt)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, N+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, W+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= N; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= W; w++ &#123;</span><br><span class="line">            <span class="keyword">if</span> w &lt; wt[i<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子集背包问题（Subset-Sum）"><a href="#子集背包问题（Subset-Sum）" class="headerlink" title="子集背包问题（Subset Sum）"></a>子集背包问题（Subset Sum）</h3><ul><li><p><strong>Leetcode 416. <a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">分割等和子集</a></strong></p><ul><li>给定一个只包含正整数的非空数组 <code>nums</code>，判断是否可以将其分割为两个子集，且两个子集的元素和相等。</li><li>转换为背包问题：给一个容量为 <code>sum / 2</code> 的背包，判断是否可以从数组中选出若干数字恰好装满它。</li></ul></li><li><p><strong>解题思路</strong></p><ul><li>状态定义：<code>dp[i][j]</code> 表示前 <code>i</code> 个数中，是否存在子集和为 <code>j</code>。</li><li>状态转移：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i]]</span><br></pre></td></tr></table></figure><ul><li><p>初始化：</p><ul><li><code>dp[..][0] = true</code>：背包容量为 0，总能装满；</li><li><code>dp[0][nums[0]] = true</code>：只有一个数且恰好等于容量；</li></ul></li><li><p>剪枝条件：</p><ul><li>若 <code>sum</code> 为奇数，直接返回 <code>false</code>；</li><li>若某元素大于 <code>sum / 2</code>，可提前跳过。</li></ul></li></ul></li><li><p><strong>二维数组实现</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    N := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &#123;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; N; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= target; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; nums[i] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N<span class="number">-1</span>][target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>状态压缩：一维优化版本（倒序）</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j - num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包问题（Unbounded-Knapsack）"><a href="#完全背包问题（Unbounded-Knapsack）" class="headerlink" title="完全背包问题（Unbounded Knapsack）"></a>完全背包问题（Unbounded Knapsack）</h3><ul><li><p><strong>Leetcode 518. <a href="https://leetcode.cn/problems/coin-change-ii/description/">零钱兑换 II</a></strong></p><ul><li>给定一个背包容量为 <code>amount</code>，以及一个物品数组 <code>coins</code>（可重复使用），求有多少种不同的方法可以凑出该金额。</li></ul></li><li><p><strong>解题思路</strong></p><ul><li><p>状态定义：<code>dp[i][j]</code> 表示使用前 <code>i</code> 种硬币，凑出金额 <code>j</code> 的方法数。</p></li><li><p>状态转移：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j &lt; coins[i<span class="number">-1</span>]:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]</span><br></pre></td></tr></table></figure></li><li><p>初始化：</p><ul><li><code>dp[0][..] = 0</code>：没有硬币无法组成正金额；</li><li><code>dp[..][0] = 1</code>：金额为 0，只有 1 种凑法（什么都不选）。</li></ul></li></ul></li><li><p><strong>二维数组实现</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(coins)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; coins[i<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>一维数组优化（正序遍历）</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="keyword">for</span> j := coin; j &lt;= amount; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - coin]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li>适用于排列、组合、子集等构造类枚举问题</li></ul><h3 id="通用回溯模板总结"><a href="#通用回溯模板总结" class="headerlink" title="通用回溯模板总结"></a>通用回溯模板总结</h3><table><thead><tr><th>题型</th><th>递归参数</th><th>关键点</th><th>重复处理策略</th><th>代码模板示例（Go 伪码简化）</th></tr></thead><tbody><tr><td><strong>排列（Permutation）</strong></td><td>无需起点</td><td>需要标记已使用元素 <code>used[]</code></td><td>排序 + <code>used</code> + 跳过相邻重复元素</td><td>见 <em>排列 II</em> 模板</td></tr><tr><td><strong>组合 &#x2F; 子集（Combination &#x2F; Subset）</strong></td><td>需要起点</td><td>控制遍历起点，防止重复使用前面元素</td><td>排序 + 跳过同层相邻重复元素</td><td>见 <em>组合 II &#x2F; 子集 II</em> 模板</td></tr></tbody></table><h2 id="1-排列（Permutation）"><a href="#1-排列（Permutation）" class="headerlink" title="1. 排列（Permutation）"></a>1. 排列（Permutation）</h2><h3 id="1-1-无重复元素-—-基础排列（46-全排列）"><a href="#1-1-无重复元素-—-基础排列（46-全排列）" class="headerlink" title="1.1 无重复元素 — 基础排列（46. 全排列）"></a>1.1 无重复元素 — 基础排列（<a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-有重复元素-—-排列-II（47-全排列-II）"><a href="#1-2-有重复元素-—-排列-II（47-全排列-II）" class="headerlink" title="1.2 有重复元素 — 排列 II（47. 全排列 II）"></a>1.2 有重复元素 — 排列 II（<a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a>）</h3><ul><li><p>相较于 46，需增加：</p><ul><li>排序以便判断相邻重复</li><li>重复剪枝：跳过已访问前一个相同元素</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只能先用同一组重复数字的“第一个”，不能先用后面的。</span></span><br><span class="line"><span class="comment">//如果现在选择了后一个重复元素，就会导致重复排列。</span></span><br><span class="line"><span class="comment">//!used[i-1]表明前一个相同的还没用，所以你这边就别先用了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !used[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-组合-x2F-子集（Combination-x2F-Subset）"><a href="#2-组合-x2F-子集（Combination-x2F-Subset）" class="headerlink" title="2. 组合 &#x2F; 子集（Combination &#x2F; Subset）"></a>2. 组合 &#x2F; 子集（Combination &#x2F; Subset）</h2><blockquote><p>本质都是选取元素的子集，区别主要在题意和输出要求。</p></blockquote><h3 id="2-1-无重复元素-—-子集-I（78-子集）"><a href="#2-1-无重复元素-—-子集-I（78-子集）" class="headerlink" title="2.1 无重复元素 — 子集 I（78. 子集）"></a>2.1 无重复元素 — 子集 I（<a href="https://leetcode.cn/problems/subsets/">78. 子集</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-有重复元素-—-子集-II（90-子集-II）"><a href="#2-2-有重复元素-—-子集-II（90-子集-II）" class="headerlink" title="2.2 有重复元素 — 子集 II（90. 子集 II）"></a>2.2 有重复元素 — 子集 II（<a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子集的另一种方式：不使用-for-循环（显式选与不选）"><a href="#子集的另一种方式：不使用-for-循环（显式选与不选）" class="headerlink" title="子集的另一种方式：不使用 for 循环（显式选与不选）"></a>子集的另一种方式：不使用 for 循环（显式选与不选）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsDfs</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> set []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(cur <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), set...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择当前</span></span><br><span class="line">        set = <span class="built_in">append</span>(set, nums[cur])</span><br><span class="line">        dfs(cur + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        set = set[:<span class="built_in">len</span>(set)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 不选择当前</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><table><thead><tr><th>特征</th><th>排列（Permutation）</th><th>组合 &#x2F; 子集（Combination &#x2F; Subset）</th></tr></thead><tbody><tr><td>是否用 <code>used</code></td><td>是</td><td>否（一般）</td></tr><tr><td>是否排序</td><td>有重复元素时必须排序</td><td>同左</td></tr><tr><td>是否有起点参数</td><td>无需（但可选）</td><td>必须有，通常为 <code>start</code></td></tr><tr><td>去重策略</td><td><code>i &gt; 0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1]</code></td><td><code>i &gt; start &amp;&amp; nums[i]==nums[i-1]</code> 跳过</td></tr><tr><td>递归形式</td><td><code>dfs()</code> &#x2F; <code>dfs(index)</code></td><td><code>dfs(start int)</code></td></tr></tbody></table><h2 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h2><ul><li><p><strong>全局变量 vs 参数传递：</strong></p><ul><li>全局变量：书写更简洁，多个函数共享更方便。</li><li>参数传递：封装更清晰，递归状态更独立，减少副作用。</li></ul></li><li><p><strong>for 循环的角色：</strong></p><ul><li>回溯中 for 循环用于枚举“选项”。</li><li>不要在 for 中处理“不选”的逻辑，不然会重复或乱序。</li></ul></li></ul><h2 id="举例：组合总和（39-Combination-Sum）"><a href="#举例：组合总和（39-Combination-Sum）" class="headerlink" title="举例：组合总和（39. Combination Sum）"></a>举例：组合总和（<a href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a>）</h2><ul><li>元素可重复使用，需遍历所有可行组合</li></ul><h4 id="✅-推荐写法：for-中只做“选”的动作"><a href="#✅-推荐写法：for-中只做“选”的动作" class="headerlink" title="✅ 推荐写法：for 中只做“选”的动作"></a>✅ 推荐写法：for 中只做“选”的动作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, target <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> target &gt;= candidates[i] &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">                dfs(i, target - candidates[i])</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🚫-不推荐写法：用“选-x2F-不选”逻辑递归（逻辑复杂，易错）"><a href="#🚫-不推荐写法：用“选-x2F-不选”逻辑递归（逻辑复杂，易错）" class="headerlink" title="🚫 不推荐写法：用“选&#x2F;不选”逻辑递归（逻辑复杂，易错）"></a>🚫 不推荐写法：用“选&#x2F;不选”逻辑递归（逻辑复杂，易错）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index, target <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(candidates) || target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选当前</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, candidates[index])</span><br><span class="line">        dfs(index, target - candidates[index])</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 不选当前</span></span><br><span class="line">        dfs(index + <span class="number">1</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS-模板的两种核心模式"><a href="#DFS-模板的两种核心模式" class="headerlink" title="DFS 模板的两种核心模式"></a>DFS 模板的两种核心模式</h2><h3 id="模式一：组合型问题（需-for-循环）"><a href="#模式一：组合型问题（需-for-循环）" class="headerlink" title="模式一：组合型问题（需 for 循环）"></a>模式一：<strong>组合型问题（需 for 循环）</strong></h3><ul><li>子集、组合、排列等</li><li>每一步从当前位置开始向后枚举选项</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">    dfs(i + <span class="number">1</span>)</span><br><span class="line">    path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式二：构造型问题（不需-for-循环）"><a href="#模式二：构造型问题（不需-for-循环）" class="headerlink" title="模式二：构造型问题（不需 for 循环）"></a>模式二：<strong>构造型问题（不需 for 循环）</strong></h3><ul><li>例如：电话号码字母组合、迷宫路径、树遍历等</li><li>每层只能处理一个“位置”的合法选项，当前层不枚举后面</li></ul><h4 id="示例：17-电话号码的字母组合"><a href="#示例：17-电话号码的字母组合" class="headerlink" title="示例：17. 电话号码的字母组合"></a>示例：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    phoneMap := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&#x27;2&#x27;</span>: <span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&quot;def&quot;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&quot;ghi&quot;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>: <span class="string">&quot;mno&quot;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&quot;pqrs&quot;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&quot;tuv&quot;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>, str <span class="type">string</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>, str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, ch := <span class="keyword">range</span> phoneMap[<span class="type">rune</span>(digits[index])] &#123;</span><br><span class="line">            dfs(index + <span class="number">1</span>, str + <span class="type">string</span>(ch))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结结构图"><a href="#总结结构图" class="headerlink" title="总结结构图"></a>总结结构图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回溯问题分类</span><br><span class="line">├── 排列类：顺序重要，used + path</span><br><span class="line">├── 组合类：顺序不重要，start 起点控制，元素不可重复</span><br><span class="line">├── 子集类：所有组合（选 or 不选）</span><br><span class="line">└── 构造类：必须填满所有位置，如数字组合/字符串构造等</span><br></pre></td></tr></table></figure><blockquote><p>✅ 判断是否需要 for：是否在当前层“枚举选项”</p><ul><li>有枚举（子集&#x2F;组合&#x2F;排列）：需要 <code>for</code></li><li>无枚举（构造型）：不需要 <code>for</code></li></ul></blockquote><hr><h1 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h1><h2 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h2><ul><li><p><strong>不要求有序</strong>：使用快速选择算法（基于快速排序思想）；也可以使用堆结构</p></li><li><p><strong>要求有序</strong>：使用堆</p><ul><li>最大堆：用于求前 K 个最大值</li><li>最小堆：用于求前 K 个最小值</li></ul></li></ul><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><ul><li><strong>19. 删除链表的倒数第 N 个节点</strong><br>快指针先走 N 步，然后快慢指针一起前进，快指针到达末尾时，慢指针刚好指向待删除节点的前一个节点</li><li><strong>141. 环形链表</strong><br>快慢指针，快指针每次走两步，慢指针每次走一步；若存在环，两者最终会相遇</li><li><strong>142. 环形链表 II</strong><br>快慢指针相遇后，快指针从头开始，慢指针继续前进；再次相遇点即为入环点</li><li><strong>234. 回文链表</strong><br>快慢指针找到链表中点，同时将前半部分链表原地反转；再从中点与反转后的链表逐一比较，判断是否回文</li><li><strong>287. 寻找重复数</strong><br>使用 Floyd 判圈算法，将数组视为链表结构；第一次快慢指针相遇后，将其中一个指针重新指向起点，两个指针再次相遇时即为重复数字（环的入口）</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li><strong>160. 相交链表</strong><br>两指针分别从两个链表头出发，走到末尾后切换至对方链表头继续走；若相交，则最终会在交点相遇；若无交点，则会同时为 <code>null</code> 结束</li></ul><hr><h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><p><strong>146. LRU 缓存</strong>（<code>HashMap + 双向链表</code>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    data     <span class="keyword">map</span>[<span class="type">int</span>]*LinkedNode</span><br><span class="line">    head     *LinkedNode</span><br><span class="line">    tail     *LinkedNode</span><br><span class="line">    count    <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="type">int</span></span><br><span class="line">    val  <span class="type">int</span></span><br><span class="line">    pre  *LinkedNode</span><br><span class="line">    next *LinkedNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>data</code>: 使用 HashMap 存储 key 与节点指针的映射</li><li><code>双向链表</code>: 头部表示最近访问节点，新加入或访问的节点会被移动到头部，尾部为最久未使用节点，便于淘汰</li></ul></li><li><p><strong>460. LFU 缓存</strong>（<code>双 Hash + 双向链表</code>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToValFreq   <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    freqToKeysHead <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    freqToKeysTail <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    minFreq        <span class="type">int</span></span><br><span class="line">    capacity       <span class="type">int</span></span><br><span class="line">    size           <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="type">int</span></span><br><span class="line">    val  <span class="type">int</span></span><br><span class="line">    freq <span class="type">int</span></span><br><span class="line">    pre  *LFUNode</span><br><span class="line">    next *LFUNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>keyToValFreq</code>: 记录每个 key 的值和频率</li><li><code>freqToKeys</code>: 按照频率映射到对应频率的链表（内部按 LRU 顺序）</li><li><code>minFreq</code>: 当前缓存中的最小访问频率</li><li>注意 <code>put</code> 操作中若 key 已存在，需要更新其值和频率！</li></ul></li></ul><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><ul><li><p><strong>198. 打家劫舍</strong>（相邻房屋不能偷）</p><ul><li>动态规划</li><li><code>dp[i]</code> 表示前 <code>i</code> 间房屋能偷到的最大金额</li><li>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></li></ul></li><li><p><strong>213. 打家劫舍 II</strong>（房屋围成一圈）</p><ul><li>环状结构，首尾不能同时选择</li><li>拆分为两种情况：<code>(0, n-2)</code> 和 <code>(1, n-1)</code>，分别计算最大值，取较大者</li></ul></li><li><p><strong>2560. 打家劫舍 IV</strong>（给定偷 <code>k</code> 间房的条件，求最小窃取能力）</p><ul><li>题考的是：在不能偷相邻房子的条件下，选择至少 k 个房子，求所有方案中「最大金额最小」的那种偷法的最大单间金额（即窃取能力）的最小值。  </li><li>二分 + 贪心</li><li>在 <code>[min(nums), max(nums)]</code> 范围内二分 <code>x</code>，判断是否存在方案在不相邻的前提下偷到 <code>k</code> 间房且每间 ≤ <code>x</code></li><li>最小可行的 <code>x</code> 即为答案</li></ul></li><li><p><strong>337. 打家劫舍 III</strong>（树形结构）</p><ul><li>二叉树结构，不能偷父子节点</li><li>返回两个值：偷当前节点与不偷当前节点的最大值</li><li>后序遍历递归实现</li></ul></li></ul><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><ul><li><p><strong>207. 课程表</strong></p><ul><li>判断有向图是否存在环</li><li>使用拓扑排序（Kahn 算法）</li><li>若排序后的节点数 <code>== numCourses</code>，说明可完成全部课程</li></ul></li></ul><h2 id="会议室"><a href="#会议室" class="headerlink" title="会议室"></a>会议室</h2><ul><li><p><strong>253. 会议室 II</strong>（计算最少需要多少间会议室）</p><ul><li>将所有会议按开始时间排序</li><li>使用最小堆记录正在进行的会议的结束时间</li><li>遇到新的会议时，检查是否能复用已结束的会议室</li><li>最后堆的大小即为最少会议室数</li></ul></li><li><p><strong>2402. 会议室 III</strong>（找出被安排次数最多的会议室编号）（如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 相同 ）</p><ul><li><p>所有会议按开始时间排序</p></li><li><p>构造两个最小堆：</p><ul><li>空闲会议室（按编号）</li><li>占用会议室（按结束时间 + 编号）</li></ul></li><li><p>每轮会议安排时：</p><ul><li>如果无空闲会议室，则延期</li><li>记录每个会议室的使用次数</li></ul></li><li><p>最终返回使用次数最多的会议室中编号最小者</p></li></ul></li></ul><h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><ul><li><strong>309. 最佳买卖股票时机含冷冻期</strong><ul><li><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p></li><li><p>三种状态转移：</p><ul><li><code>f[i][0]</code>: 第 i 天持有股票</li><li><code>f[i][1]</code>: 第 i 天卖出股票（进入冷冻期）</li><li><code>f[i][2]</code>: 第 i 天未持股（非冷冻期）</li></ul></li><li><p>状态转移方程：</p><ul><li><code>f[i][0] = max(f[i-1][0], f[i-1][2] - prices[i])</code></li><li><code>f[i][1] = f[i-1][0] + prices[i]</code></li><li><code>f[i][2] = max(f[i-1][1], f[i-1][2])</code></li></ul></li><li><p>最终答案：<code>max(f[n-1][1], f[n-1][2])</code></p></li></ul></li></ul><h2 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h2><ul><li><p><strong>887. 鸡蛋掉落</strong></p><ul><li><p>给定 <code>k</code> 个鸡蛋和 <code>n</code> 层楼，找出确定临界楼层所需的最少操作次数（最坏情况下）</p></li><li><p>定义：<code>f(t, k)</code> 表示在最多尝试 <code>t</code> 次、拥有 <code>k</code> 个鸡蛋的情况下，最多能测试的楼层数</p><ul><li>转移方程：<code>f(t, k) = 1 + f(t-1, k-1) + f(t-1, k)</code></li></ul></li><li><p>最终寻找最小的 <code>t</code>，使得 <code>f(t, k) &gt;= n</code></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superEggDrop</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j++ &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j++ &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[i][k] &gt;= n &#123;</span><br><span class="line">            ans = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>学习总被寄予理解的希望，现实却常逼我们回归重复与记忆的路径。掌握技巧、熟悉模板，也许并不光鲜，却是应对复杂世界最有效的方式之一。</li><li>然而熟练，何尝不是另一种形式的“背”呢。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近重新刷LeetCode，对一些算法基础和套路做下总结，以做备忘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;简要分类总结&quot;&gt;&lt;a href=&quot;#简要分类总结&quot; class=</summary>
      
    
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>“人工智能”一词是否准确？一次关于AI本质的反思</title>
    <link href="http://yoursite.com/2025/05/31/20250531-ren-gong-zhi-neng-yi-ci-shi-fou-zhun-que-yi-ci-guan-yu-ai-ben-zhi-de-fan-si/"/>
    <id>http://yoursite.com/2025/05/31/20250531-ren-gong-zhi-neng-yi-ci-shi-fou-zhun-que-yi-ci-guan-yu-ai-ben-zhi-de-fan-si/</id>
    <published>2025-05-30T16:22:28.000Z</published>
    <updated>2025-05-30T16:34:13.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>AI – “基于数据的规律发现系统”</p></blockquote></blockquote><ul><li>“人工智能（AI）”这个名字，其实是一种历史性命名，也是一种拟人化的表达。它给人一种错觉，仿佛机器在模仿或复制人类的智能。然而，从技术本质上看，今天的人工智能主要依赖于数据驱动的模式识别和规律学习，更准确地说，它是一种“基于数据的规律发现系统”。无论是人类还是机器，学习的对象都是客观存在的规律，只是各自的方法不同。规律本身并不依赖于学习者，它们存在于自然和社会系统之中，等待被发现。机器学习的意义，不在于赋予机器“像人一样的智能”，而在于它可以在极大规模和复杂度下识别人类难以企及的模式，这种能力甚至在某些领域已经超越了人类。然而，AI虽能拟合规律，却不具备理解、动机和意识，因此我们说它“智能”仍属工程性描述，而非哲学意义上的智能。从这个角度看，“人工智能”这一术语在一定程度上是误导性的，如果要更准确地描述其本质，也许“规律学习系统”或“模式发现机器”更贴切，但这类表述在传播和产业化上显然不如“AI”简洁有力。因此，当前的术语是一种权衡：技术准确性让位于传播效率。我们需要清醒地认识到，AI不是在“思考”，它只是以统计和优化的方式，从数据中提取规律，并按特定目标进行预测或生成。</li></ul><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><pre>AI这个名字其实并不准确人工智能其实是通过数据来学习规律跟人没有关系只是人或机器用他们的方式去学习，不管你人类或机器学不学习规律就在那里，只是表现形式不一样，但规律的本质是一样的，而且有些规律人类也学不会，超过人的能力所以叫人工智能是片面的表达应该叫智能规律，或规律学习？——当然，以下是对原文的整理和简要总结：⸻整理后的表达：“人工智能（AI）”这个名称其实并不准确。所谓人工智能，本质上只是通过数据来学习和提取规律的过程，与人类的思维或意识没有直接关系。无论是人还是机器，学习的只是客观存在的规律，而这些规律本身独立于学习主体，始终存在，只是表现形式不同而已。机器和人只是用不同的方式去接近这些规律，有些规律甚至超出了人类的认知能力，只有机器才能捕捉到。因此，用“人工智能”来命名这种技术是片面的，更准确的表达也许应该是“智能规律”或“规律学习”。⸻简要总结观点：这段文字认为，“人工智能”这一术语带有误导性，因为它强调了“人”而忽略了技术的本质：对客观规律的学习和拟合。作者主张，AI其实是一种“规律学习”系统，不应被简单等同于模仿人类智能。</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;AI – “基于数据的规律发现系统”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;“人工智能（AI）”这个名字，其实是一种历史性命名，也是一种拟人化的表达。它给人一种错觉，仿佛机器在模</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>使用Java调用Rust构建的动态库</title>
    <link href="http://yoursite.com/2025/03/23/20250323-shi-yong-java-diao-yong-rust-gou-jian-de-dong-tai-ku/"/>
    <id>http://yoursite.com/2025/03/23/20250323-shi-yong-java-diao-yong-rust-gou-jian-de-dong-tai-ku/</id>
    <published>2025-03-23T06:41:37.000Z</published>
    <updated>2025-03-23T16:12:12.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>近期帮朋友做一个需求，需要将某个Rust项目的一部分功能移植到Java中，使Java应用能使用</p></blockquote></blockquote><h2 id="方案1-直接将Rust翻译成Java代码"><a href="#方案1-直接将Rust翻译成Java代码" class="headerlink" title="方案1: 直接将Rust翻译成Java代码"></a>方案1: 直接将Rust翻译成Java代码</h2><blockquote><blockquote><p>前置准备：将Rust项目跑通，方便通过debug对照执行细节，从而一步步翻译成Java代码<br>希望借助AI的力量帮忙完成</p></blockquote></blockquote><ul><li>借助AI的方案如下：<ul><li>首先，我已经跑通了需要抽取的功能的相关测试用例</li><li>然后，让AI帮忙将涉及这些功能相关的代码抽取成单独的Rust项目（结果还是很乱七八糟）</li><li>大概是因为上下文内容太多的关系，AI执行任务的效果很差</li><li>没办法，于是自己拆分代码，让AI软件帮忙根据代码块逐个进行转化，结果效果是好了很多，能帮助不少，不过这样效率太低，而且AI有时候也经常出错，需要自己慢慢调整</li><li>看来AI目前在一次性的转化大量代码的效率和准确性还是不够</li><li>本次程序员该懒就懒的宗旨，我决定另辟蹊径，采用方案2</li></ul></li></ul><h2 id="方案2-直接将相关功能的Rust功能编译成动态库，由Java直接调用"><a href="#方案2-直接将相关功能的Rust功能编译成动态库，由Java直接调用" class="headerlink" title="方案2: 直接将相关功能的Rust功能编译成动态库，由Java直接调用"></a>方案2: 直接将相关功能的Rust功能编译成动态库，由Java直接调用</h2><blockquote><blockquote><p>省去翻译代码的重复工作<br>需要构建不同平台的动态库<br>Java代码在加载前需要判断环境加载相应的动态库<br>使用Github Action来构建各种平台的动态库<br>Java端充分测试，Java8应用测试，Java9以上模块化系统是否可用测试，Windows等其他平台测试</p></blockquote></blockquote><hr><blockquote><blockquote><p>以下由AI（ChatGPT）帮我完成的文章</p></blockquote></blockquote><h1 id="使用Java调用Rust构建的动态库"><a href="#使用Java调用Rust构建的动态库" class="headerlink" title="使用Java调用Rust构建的动态库"></a>使用Java调用Rust构建的动态库</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在最近的一个项目中，我需要将一个Rust项目中的部分功能迁移到Java应用中，供Java系统调用。为了简化过程，我决定绕过将Rust代码完全转化为Java的复杂任务，而是直接通过Rust构建动态库，再通过Java来调用。这种方法不仅减少了代码转换的工作量，还利用了Rust的高性能特点，提高了Java应用的效率。</p><h2 id="方案1-直接将Rust翻译成Java代码-1"><a href="#方案1-直接将Rust翻译成Java代码-1" class="headerlink" title="方案1: 直接将Rust翻译成Java代码"></a>方案1: 直接将Rust翻译成Java代码</h2><h3 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h3><p>为了开始这个过程，我首先确保了Rust项目能够成功运行，并且通过调试工具逐步分析每个功能的执行细节。这是为了确保我可以一步步将Rust的实现逻辑转化为Java代码。</p><h3 id="使用AI进行代码转换"><a href="#使用AI进行代码转换" class="headerlink" title="使用AI进行代码转换"></a>使用AI进行代码转换</h3><p>最初，我尝试借助AI工具自动化地将Rust代码转换为Java代码。以下是我使用AI进行代码转换的过程：</p><ul><li>我首先跑通了相关的测试用例，确保所有需要移植的功能都能正常工作。</li><li>然后，我让AI帮助抽取与这些功能相关的Rust代码，并转化成单独的Rust项目。但由于上下文过多，AI的效果并不理想，生成的代码混乱且不完整。</li><li>之后，我将代码拆分成更小的部分，让AI逐一处理，虽然效果有所改善，但这种方式依旧效率低下，且AI经常会出错，导致我不得不花大量时间修正。</li></ul><p>这一过程中，我意识到AI在一次性大规模转化代码时的准确性和效率仍然有待提升。最终，我决定放弃这条路，转而尝试另一种更直接的方案——方案2。</p><h2 id="方案2-直接将Rust功能编译成动态库，由Java调用"><a href="#方案2-直接将Rust功能编译成动态库，由Java调用" class="headerlink" title="方案2: 直接将Rust功能编译成动态库，由Java调用"></a>方案2: 直接将Rust功能编译成动态库，由Java调用</h2><h3 id="思路与优势"><a href="#思路与优势" class="headerlink" title="思路与优势"></a>思路与优势</h3><p>与其将Rust代码翻译成Java代码，我决定直接将Rust的功能编译成动态库（.dll 或 .so），然后在Java中通过JNI（Java Native Interface）调用这些动态库。这样可以避免代码翻译过程中的麻烦，并且能够充分利用Rust在性能上的优势。</p><h3 id="构建Rust动态库"><a href="#构建Rust动态库" class="headerlink" title="构建Rust动态库"></a>构建Rust动态库</h3><p>在实现这一方案时，我需要做以下几个步骤：</p><ol><li><p><strong>编译Rust代码为动态库</strong>：通过Rust的<code>cargo</code>工具，将Rust代码编译成适用于不同平台的动态库。这需要为每个平台生成相应的二进制文件，如Windows下的<code>.dll</code>，Linux下的<code>.so</code>，以及MacOS下的<code>.dylib</code>。</p></li><li><p><strong>使用Github Actions自动化构建</strong>：为了支持多平台的动态库构建，我使用了Github Actions来自动化构建过程。这样，无论是Windows、Linux还是MacOS，都会根据需要自动生成对应的动态库，极大地简化了跨平台的构建工作。</p></li><li><p><strong>Java端加载动态库</strong>：Java通过JNI加载Rust编译出的动态库，并调用其中的函数。在加载时，Java代码会先检测当前运行环境，根据操作系统加载相应的库文件。</p></li><li><p><strong>平台兼容性测试</strong>：为了确保Java能够顺利调用Rust动态库，我在多个平台上进行了充分的测试。这包括：</p><ul><li>在Java 8环境下进行功能测试。</li><li>验证在Java 9及以上版本的模块化系统下，Java与Rust动态库的兼容性。</li><li>测试在Windows、Linux和MacOS等不同平台下的表现。</li></ul></li></ol><h3 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h3><ul><li><strong>减少工作量</strong>：不需要将Rust代码完全翻译为Java代码，避免了翻译过程中的复杂性和错误。</li><li><strong>高效的性能</strong>：Rust的性能优势得以保留，Java通过调用Rust动态库，可以在性能上得到显著提升。</li><li><strong>跨平台支持</strong>：通过自动化构建不同平台的动态库，Java应用能够轻松支持Windows、Linux、MacOS等多种操作系统。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过将Rust功能编译成动态库并在Java中调用，我成功地绕过了将Rust代码完全转化为Java的复杂过程，同时还能够充分利用Rust的性能优势。虽然在构建过程中涉及到平台适配和自动化构建，但这一方案的灵活性和高效性使其成为解决问题的最佳选择。对于有类似需求的开发者来说，这无疑是一个值得尝试的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;近期帮朋友做一个需求，需要将某个Rust项目的一部分功能移植到Java中，使Java应用能使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方案1-直接将Rust翻译成Java代码&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Rust" scheme="http://yoursite.com/tags/Rust/"/>
    
    <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>开源知识库系统试用</title>
    <link href="http://yoursite.com/2025/02/26/20250226-kai-yuan-zhi-shi-ku-xi-tong-shi-yong/"/>
    <id>http://yoursite.com/2025/02/26/20250226-kai-yuan-zhi-shi-ku-xi-tong-shi-yong/</id>
    <published>2025-02-26T14:22:04.000Z</published>
    <updated>2025-02-27T09:09:16.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>帮助朋友的公司搭建内部知识库的原型<br>简单记录一下相关技术</p></blockquote></blockquote><p><img src="/2025/02/26/20250226-kai-yuan-zhi-shi-ku-xi-tong-shi-yong/dify.drawio.png"></p><ul><li><p>目前看权限管理都很不精细，只在固定角色上进行控制，用于内部团队管理仍不是很方便</p></li><li><p>文档嵌入效果一般，可能要研究里面一些复杂的选项用法，或者寻求其他方案</p></li><li><p>除了dify，还有很多其他开源的知识库系统，比如 Cherry Studio、MaxKB、FastGPT、AnythingLLM、Ragflow等</p></li><li><p>dify功能很多，anythingllm功能较少，Cherry Studio 就是个人知识库</p></li><li><p>所谓的各种助手其实就是提示词模版</p></li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul><li>传统RAG通常依赖单次检索，这可能不足以处理需要逐步构建上下文的复杂查询</li><li>向量相似性检索依赖知识库中明确提及的信息，可能无法捕捉隐含或关系信息。相比之下，知识图谱（如GraphRAG）通过利用数据结构中的关系，能更好地处理需要全面理解数据集的全局查询</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;帮助朋友的公司搭建内部知识库的原型&lt;br&gt;简单记录一下相关技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/26/20250226-kai-yuan-zhi-</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="RAG" scheme="http://yoursite.com/tags/RAG/"/>
    
    <category term="知识库" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于大模型的Prompt</title>
    <link href="http://yoursite.com/2025/02/25/20250225-guan-yu-da-mo-xing-de-prompt/"/>
    <id>http://yoursite.com/2025/02/25/20250225-guan-yu-da-mo-xing-de-prompt/</id>
    <published>2025-02-25T13:48:37.000Z</published>
    <updated>2025-02-26T11:10:33.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>网上资料摘要<br>一些个人理解</p></blockquote></blockquote><h1 id="大模型交互的核心：提示词工程"><a href="#大模型交互的核心：提示词工程" class="headerlink" title="大模型交互的核心：提示词工程"></a>大模型交互的核心：提示词工程</h1><blockquote><blockquote><p>以下基于个人理解，并通过claude优化（2025-02-26）</p></blockquote></blockquote><ul><li>提示词（Prompt）是大模型的输入，也是调用大模型能力的接口，用以激发或引导大模型生成特定类型的回答。</li><li>提示词工程的目的是尽量把任务说清楚，让大模型能充分理解我们的意图，以按照正确的方向回答问题。  </li><li>在不微调大模型的情况下，外部与大模型交互的唯一途径就是提示工程。即便是已经微调过的大模型，后续与其沟通的唯一途径仍是通过提供提示词，尽管微调可能改变模型对提示词的响应方式。</li><li>所谓的RAG、短期记忆（对话历史）、长期记忆等功能，都是基于提示工程这一与大模型交互的路径作为切入点，建立的其他优化策略和架构。</li></ul><h1 id="ICIO框架（Prompt包含的要素）"><a href="#ICIO框架（Prompt包含的要素）" class="headerlink" title="ICIO框架（Prompt包含的要素）"></a>ICIO框架（Prompt包含的要素）</h1><ul><li><a href="https://mp.weixin.qq.com/s/xYC6saH3PU6nJc9mzV5alw">从原理出发 - 提示词如何影响大模型的输出</a></li><li>核心思想，是通过明确定义任务的各个方面，来提高AI响应时的效率和准确性。</li><li>在ICIO的框架的设计中，Prompt可能包含四要素：<ul><li>Instruction（指令）：这是最重要的部分，它直接告诉模型需要执行的具体任务。</li><li>Context（上下文&#x2F;背景）：上下文提供了任务执行所需的背景信息，帮助模型理解任务的情景和环境。</li><li>Input Data（输入数据）：输入数据是模型需要处理的具体信息。</li><li>Output Indicator（输出指示器）：输出指示器告诉模型用户期望的输出类型或格式。</li></ul></li><li>其中除了指令以外，其他要素都是可选的，说明指令对于大模型来说是最重要的，其他要素都是对指令的补充。</li><li>优质的Prompt，可以清晰地传达用户的意图</li></ul><h1 id="Prompt五大框架"><a href="#Prompt五大框架" class="headerlink" title="Prompt五大框架"></a>Prompt五大框架</h1><ul><li><a href="https://mp.weixin.qq.com/s/u-79q3R0l01oO-7WWUNF2A">大模型Prompt技巧全解析</a>    </li><li>RTF框架 <ul><li>R-Role(角色)、R-Role(角色)、F-Format(格式)</li></ul></li><li>思考链模式 <ul><li>适合一些复杂的任务处理</li><li>要使用这种模式，只需要在末尾添加”让我们逐步思考”即可</li></ul></li><li>RISEN框架<ul><li>R-Role:大模型扮演的角色</li><li>I-Instructions: 指示命令，和Task-任务差不多</li><li>S-Steps: 步骤</li><li>E-End Goal: 最终目标</li><li>N-Narrowing(Constraints): 缩小范围(约束条件)，和RTF框架中的Format有异曲同工之妙</li><li>该框架主要适合<ul><li>撰写具有特定约束的任务(例如博客文章)</li><li>有明确指导方针的任务（例如商业计划）</li></ul></li></ul></li><li>RODES框架<ul><li>R-Role: 角色、O - Objective: 目标、D - Details: 详细的细节、E - Examples: 示例、S - Sense Check: 感官检查</li></ul></li><li>密度链模式<ul><li>使用递归来创建越来越好的输出的提示，与普通提示生成的 GPT-4 摘要相比，它生成的摘要更加密集且更适合人们理解</li><li>适合：总结、改进您最喜欢的提示、通过递归生成可用的长格式内容</li></ul></li></ul><h1 id="打造高效Prompt的两大核心原则"><a href="#打造高效Prompt的两大核心原则" class="headerlink" title="打造高效Prompt的两大核心原则"></a>打造高效Prompt的两大核心原则</h1><ul><li><a href="https://mp.weixin.qq.com/s/u-79q3R0l01oO-7WWUNF2A">大模型Prompt技巧全解析</a> </li><li>原则一：编写明确和具体的指令<ul><li>策略1：使用分隔符清晰界定输入部分</li><li>策略2：要求结构化输出</li><li>策略3：要求模型检查条件是否满足</li><li>策略4：Few-shot prompting（少样本提示）</li></ul></li><li>原则二：给予模型充足的思考时间<ul><li>策略1：明确完成任务所需的步骤</li><li>策略2：引导模型在得出结论前充分思考方案</li></ul></li></ul><h1 id="Prompt技术剖析与应用"><a href="#Prompt技术剖析与应用" class="headerlink" title="Prompt技术剖析与应用"></a>Prompt技术剖析与应用</h1><ul><li><a href="https://mp.weixin.qq.com/s/u-79q3R0l01oO-7WWUNF2A">大模型Prompt技巧全解析</a> </li><li>一、零样本提示（Zero-Shot Prompting）</li><li>二、少样本提示（Few-Shot Prompting）<ul><li>在零样本提示效果不佳时发挥作用</li></ul></li><li>三、思维链提示（Chain-of-Thought Prompting）<ul><li>与少样本提示结合，增强效果，尤其适用于算术、常识推理等任务，帮助模型更有条理地处理问题</li></ul></li><li>四、自我一致性（Self-Consistency）   <ul><li>主要用于优化思维链提示中的推理路径选择</li><li>核心思想是通过提供多个少样本推理示例，让模型从多样的推理结果中筛选出最一致的答案，增强模型在算术和常识推理任务中的可靠性</li></ul></li><li>五、生成知识提示（Generated Knowledge Prompting）<ul><li>主要用于解决模型在处理需要额外知识的任务时出现的局限性   </li><li>个人理解：一种特殊的RAG罢了</li></ul></li><li>六、链式提示（Prompt Chaining）<ul><li>将复杂任务拆解为多个子任务，通过逐个子任务生成提示并传递结果的方式来实现复杂任务的有序处理</li></ul></li><li>七、思维树（ToT）<ul><li>为了帮助模型应对复杂的探索性任务而设计</li><li>通过维护一棵思维树，让模型在解决问题时能够生成和评估中间思维步骤，并结合搜索算法进行系统性探索</li></ul></li><li>八、检索增强生成（RAG）<ul><li>将信息检索与文本生成相结合，专门用于处理知识密集型任务</li><li>通过检索相关文档来为模型提供额外的知识支持，从而缓解模型的“幻觉”问题</li></ul></li><li>九、自动推理并使用工具（ART）<ul><li>使模型能够自动生成包含推理步骤的程序，并在需要时调用外部工具</li></ul></li><li>十、自动提示工程师（APE）<ul><li>自动生成和筛选任务指令</li><li>利用大型语言模型生成指令候选项，再依据评估分数选择最佳指令，从而提升提示生成的效率与效果</li></ul></li><li>十一、Active-Prompt<ul><li>用于解决思维链示例有效性的问题</li><li>通过先查询模型生成多个答案，计算不确定度后挑选最不确定的问题由人类注释示例，再用新示例推断其他问题，从而优化模型对不同任务的适应性</li></ul></li><li>十二、方向性刺激提示（Directional Stimulus Prompting）<ul><li>通过训练策略 LM 生成引导提示，增强对模型生成结果的掌控力。例如文本摘要任务</li></ul></li><li>十三、PAL（程序辅助语言模型）<ul><li>让模型生成程序来解决问题，借助编程运行时提升解决复杂问题的能力</li></ul></li><li>十四、ReAct 框架<ul><li>ReAct 框架使模型交错生成推理轨迹和操作，提升答案的可靠性与可解释性</li></ul></li><li>十五、自我反思（Reflexion）<ul><li>包含参与者、评估者和自我反思三个模型，旨在帮助模型从错误中学习并提升性能</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://mp.weixin.qq.com/s/xYC6saH3PU6nJc9mzV5alw">从原理出发 - 提示词如何影响大模型的输出</a><ul><li>大模型如何理解Prompt<ul><li>基于Transformer的解码器的大模型</li><li>最核心的两层<ul><li>掩码多头自注意力层（Masked Multi Self Attention Layers，对应Transformer的Masked Multi-Head Attention，简称MHA）</li><li>前置反馈网络层（Feed Forward Networks Layers，简称FFN）</li></ul></li><li>Prompt会影响自注意力层对上下文信息的捕捉</li><li>自注意力机制<ul><li>它的核心思想是模仿人类的注意力，即在处理大量信息时，能够聚焦于当前任务最相关的部分，而忽略其他不太重要的信息</li></ul></li></ul></li></ul></li><li><a href="https://mp.weixin.qq.com/s/u-79q3R0l01oO-7WWUNF2A">大模型Prompt技巧全解析</a>            </li><li><a href="https://kingson4wu.github.io/2024/12/26/20241226-llm-xiang-guan-ji-zhu-jian-dan-liao-jie/">LLM相关技术简单了解</a></li><li><a href="https://mp.weixin.qq.com/s/q2iMW0t5456btmIPS1ba6Q">大型语言模型的提示注入</a><ul><li>三种防范此类漏洞的方法<ul><li>可以在提示中添加指令</li><li>使用对抗性探测器添加第二层保护</li><li>对模型进行微调，使其更符合用户需求，同时提供最高级别的保护，防止提示注入和窃取</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;网上资料摘要&lt;br&gt;一些个人理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;大模型交互的核心：提示词工程&quot;&gt;&lt;a href=&quot;#大模型交互的核心：提示词工程&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="Prompt" scheme="http://yoursite.com/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>大模型应用开发AI Agent要点记录</title>
    <link href="http://yoursite.com/2025/02/21/20250221-da-mo-xing-ying-yong-kai-fa-ai-agent-yao-dian-ji-lu/"/>
    <id>http://yoursite.com/2025/02/21/20250221-da-mo-xing-ying-yong-kai-fa-ai-agent-yao-dian-ji-lu/</id>
    <published>2025-02-21T09:28:05.000Z</published>
    <updated>2025-02-25T08:14:54.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>基于书籍简单记录要点</p></blockquote></blockquote><p><img src="/2025/02/21/20250221-da-mo-xing-ying-yong-kai-fa-ai-agent-yao-dian-ji-lu/%E7%94%9F%E6%88%90%E5%BC%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%845%E4%B8%AA%E5%B1%82%E6%AC%A1.png"></p><ul><li>从L3到L4的跨越是一个从被动到自主的分水岭，在这个跨越过程中，Agent将成为关键的驱动力</li></ul><p><img src="/2025/02/21/20250221-da-mo-xing-ying-yong-kai-fa-ai-agent-yao-dian-ji-lu/AI-Agent.png"></p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《大模型应用开发 动手做AI Agent》</li><li><a href="https://developer.baidu.com/article/detail.html?id=3372236">AIGC生成式人工智能的五个进阶层次</a></li><li><a href="https://blog.csdn.net/surfirst/article/details/142661951">AIGC：生成式人工智能的5个层次</a></li><li><a href="https://zhuanlan.zhihu.com/p/671355141">2024年大模型Multi-agent多智能体应用技术：AutoGen, MetaGPT, XAgent, AutoAgents，crewAI</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于书籍简单记录要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/21/20250221-da-mo-xing-ying-yong-kai-fa-ai-age</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="AI-Agent" scheme="http://yoursite.com/tags/AI-Agent/"/>
    
  </entry>
  
  <entry>
    <title>基于大模型的RAG应用开发要点记录</title>
    <link href="http://yoursite.com/2025/02/20/20250220-ji-yu-da-mo-xing-de-rag-ying-yong-kai-fa-yao-dian-ji-lu/"/>
    <id>http://yoursite.com/2025/02/20/20250220-ji-yu-da-mo-xing-de-rag-ying-yong-kai-fa-yao-dian-ji-lu/</id>
    <published>2025-02-20T13:12:52.000Z</published>
    <updated>2025-05-28T08:51:07.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>基于书籍简单记录要点</p></blockquote></blockquote><p><img src="/2025/02/20/20250220-ji-yu-da-mo-xing-de-rag-ying-yong-kai-fa-yao-dian-ji-lu/RAG.png"></p><hr><ul><li><p>一种借助“外挂”的提示工程</p></li><li><p>最核心的思想：给大模型补充外部知识以提高生成质量</p></li><li><p>大模型的 RAG 应用中，最常见的检索方式是借助基于向量的语义检索来获得相关的数据块，并根据其相似度排序，最后输出最相关的前 K 个数据块（简称top_K）</p></li><li><p>自然语言处理中用于把各种形式的信息转换成向量表示的模型叫嵌入模型</p></li><li><p>基于向量的语义检索就是通过计算查询词与已有信息向量的相似度（如余弦相似度），找出与查询词在语义上最接近的信息。</p></li><li><p>如果大模型是一个优秀学生，正在参加一门考试，那么 RAG 和微调的区别如下。</p><ul><li>RAG：在考试时给他提供某个领域的参考书，要求他现学现用，并给出答案。</li><li>微调：在考试前一天对他进行辅导，使他成为某个领域的专家，然后让他参加考试。</li></ul></li><li><p>大模型与 Prompt 并不只在最后生成结果时才需要，在 RAG 应用流程的很多阶段都需要用到它们，比如在生成摘要、查询转换、查询路由、智能体推理、响应评估等很多阶段，都需要利用设计的Prompt 来让大模型完成任务。</p></li><li><p>与查询引擎相关的几个关键组件如下。</p><ul><li>（1）VectorIndexRetriever：向量索引检索器。用于完成相关知识的检索，基于索引来完成，输出多个相关 Node。</li><li>（2）Synthesizer：响应生成器。借助大模型来完成 Prompt 组装，并根据响应生成模式的要求来生成响应结果。</li><li>（3）NodePostProcessor：节点后处理器。通常用于在检索完成之后，对检索器输出的 Node 列表做补充处理，比如重排序。</li></ul></li><li><p>Agent 就是通过 AI 模型驱动，能够自主地理解、规划、执行，并最终完成任务的 AI 程序。Agent 与大模型的区别类似于人与大脑的区别：大脑指挥人的行动，但是只有人才是执行任务的完整体。    </p></li><li><p>Agent 就是在大模型作为智慧大脑的基础上实现记忆（Memory）、自我规划（Planning）、使用工具（Tool）等能力，从而开发一个具有自主认知与行动能力的完全“智能体”。</p></li><li><p>与 RAG 应用相比，Data Agent 具备以下能力。</p><ul><li>（1）兼具 RAG 应用的数据检索与查询生成能力。</li><li>（2）通过观察环境与任务目标推理出完成下一个数据任务的步骤。</li><li>（3）通过调用外部服务工具（API）完成复杂任务，并返回执行结果。</li><li>（4）具备长期记忆能力（如使用向量库）与短期记忆（一次任务中的交互历史等）能力。</li></ul></li><li><p>与 RAG 应用相比，Data Agent 的主要增强之处如下。</p><ul><li>（1）规划与推理出完成任务的步骤的能力。</li><li>（2）定义与使用工具的能力。</li></ul></li></ul><h1 id="LlamaIndex-框架整体结构"><a href="#LlamaIndex-框架整体结构" class="headerlink" title="LlamaIndex 框架整体结构"></a>LlamaIndex 框架整体结构</h1><ul><li>(1)Core Framework:这是 LlamaIndex 的核心框架，实现了 LlamaIndex 框 架中大量可扩展的基础组件与工具组件。</li><li>(2)Integrations:这是在 Core Framework 基础上由官方或者第三方提供的 大量扩展组件。这些组件大大扩充了 LlamaIndex 框架的兼容能力与应用场景， 包括各种类型的数据加载器、大语言模型与嵌入模型、向量库、Agent 工具等。</li><li>(3)Templates:这是官方或者第三方提供的更上层的应用模板。开发者可 以基于这些模板来修改和开发自己的应用。</li><li>(4)Eval Datasets:评估数据集。这是一些用于测试评估的现成数据集。 一个数据集通常包含两个部分:一部分是用于开发 RAG 应用的原始知识数据 集;另一部分是用于评估 RAG 应用的测试数据集。</li></ul><hr><h1 id="LlamaIndex-的向量存储索引和传统数据库（如-MySQL）的索引的区别"><a href="#LlamaIndex-的向量存储索引和传统数据库（如-MySQL）的索引的区别" class="headerlink" title="LlamaIndex 的向量存储索引和传统数据库（如 MySQL）的索引的区别"></a>LlamaIndex 的向量存储索引和传统数据库（如 MySQL）的索引的区别</h1><ul><li>From Grok3 (2025-02-24)</li></ul><h2 id="传统数据库索引（如-MySQL）-vs-向量存储索引"><a href="#传统数据库索引（如-MySQL）-vs-向量存储索引" class="headerlink" title="传统数据库索引（如 MySQL） vs 向量存储索引"></a>传统数据库索引（如 MySQL） vs 向量存储索引</h2><h3 id="1-传统数据库索引（B-树、哈希索引等）"><a href="#1-传统数据库索引（B-树、哈希索引等）" class="headerlink" title="1. 传统数据库索引（B-树、哈希索引等）"></a>1. 传统数据库索引（B-树、哈希索引等）</h3><ul><li><strong>目的</strong>：加速精确匹配或范围查询，比如在 <code>WHERE id = 5</code> 或 <code>WHERE age &gt; 30</code> 时快速定位数据。</li><li><strong>数据结构</strong>：通常基于 B-树、B+树 或哈希表，存储的是原始数据（如整数、字符串）的某种排序或映射。</li><li><strong>存储内容</strong>：索引本身不保存完整数据，而是指向数据库中实际数据的引用（行指针）。</li><li><strong>使用场景</strong>：结构化数据的高效检索。</li></ul><h3 id="2-LlamaIndex-的向量存储索引"><a href="#2-LlamaIndex-的向量存储索引" class="headerlink" title="2. LlamaIndex 的向量存储索引"></a>2. LlamaIndex 的向量存储索引</h3><ul><li><strong>目的</strong>：支持语义相似性搜索，比如找到与“人工智能是什么”语义最接近的文档。</li><li><strong>数据结构</strong>：基于向量空间的高效搜索结构（如 FAISS、HNSW、Annoy），存储的是文本的嵌入向量（高维浮点数数组）。</li><li><strong>存储内容</strong>：索引里直接保存的是嵌入向量（通常还会关联原始文本或其引用），而不仅仅是指针。这种嵌入向量本身就是数据的某种“表示”。</li><li><strong>使用场景</strong>：非结构化数据（如文本、图像）的语义搜索。</li></ul><p>所以你说得对，向量存储索引和 MySQL 的索引在设计目标和实现上完全不同。传统索引是为了快速定位具体值，而向量存储索引是为了快速找到“最相似”的内容。</p><h2 id="为什么叫“向量存储索引”而不是“向量存储数据”？"><a href="#为什么叫“向量存储索引”而不是“向量存储数据”？" class="headerlink" title="为什么叫“向量存储索引”而不是“向量存储数据”？"></a>为什么叫“向量存储索引”而不是“向量存储数据”？</h2><ul><li><p><strong>“索引”在这里的含义</strong>：</p><ul><li>在向量搜索领域，“索引”指的是一个经过优化的数据结构，用于加速向量之间的相似性计算和检索。它不只是存数据，而是以某种方式组织数据（比如 FAISS 用聚类或倒排索引），让查询效率更高。</li><li>比如 FAISS 可能会把向量分桶（clustering），HNSW 用图结构连接向量，这些都是“索引”的体现。</li></ul></li><li><p><strong>为什么不叫“向量存储数据”</strong>：</p><ul><li>“数据”听起来像是原始的、未经组织的存储，比如直接把向量一股脑扔进数据库。而“索引”强调的是结构化和查询优化。</li><li>LlamaIndex 的向量存储索引不仅存了向量，还为快速检索做了预处理（比如降维、构建树或图）。它是个功能性工具，而不仅是数据的容器。</li></ul></li><li><p><strong>命名习惯</strong>：</p><ul><li>在向量搜索和机器学习领域，像 FAISS、Annoy、HNSW 这些工具都叫“索引”（index），因为它们的核心是构建一个可搜索的结构。LlamaIndex 沿用了这种惯例。</li></ul></li></ul><h2 id="举个类比"><a href="#举个类比" class="headerlink" title="举个类比"></a>举个类比</h2><ul><li>MySQL 的 B-树索引就像图书馆的卡片目录，按书名首字母排序，帮你快速找到某本书。</li><li>LlamaIndex 的向量存储索引更像是推荐系统，根据你喜欢的书，找到内容相似的其他书，靠的是“向量空间的距离”而不是精确匹配。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LlamaIndex 的向量存储索引确实和 MySQL 的索引差别很大，它更像是一个专门为高维向量设计的“搜索加速器”。叫“索引”是因为它不仅存向量，还组织向量以提升查询效率，而不是简单的数据存储。</p><hr><h1 id="关于RAG的优化：个人结合深度强化学习的思考"><a href="#关于RAG的优化：个人结合深度强化学习的思考" class="headerlink" title="关于RAG的优化：个人结合深度强化学习的思考"></a>关于RAG的优化：个人结合深度强化学习的思考</h1><ul><li><p>对于RAG应用，优化方法有很多。我的想法是，把这些优化方法想象成一堆‘工具’，然后用强化学习这个‘聪明助手’来挑出最好用的组合。</p></li><li><p>“优化策略”变成了“工具”，“强化学习”变成了“聪明助手”，“奖励函数”简化为“任务需求”</p></li><li><p>From ChatGPT</p></li><li><p>你表达的意思可以理解为：你试图用一个类比来形象地说明深度强化学习在RAG（Retrieval-Augmented Generation）系统优化中的角色与价值。</p></li><li><p>具体地说：</p><ul><li><strong>RAG优化方法</strong>很多，比如检索器选择、reranker排序、embedding优化、prompt设计等，这些在你眼中就像一堆**“工具”**。</li><li>这些工具的使用方式组合非常多，所以你不想手动去调优，而是引入一个“聪明助手”——也就是<strong>强化学习智能体</strong>，来<strong>自动地组合和选择最合适的优化策略</strong>。</li><li><strong>任务需求</strong>（比如更高的准确率、更好的用户体验）就变成了强化学习中的<strong>奖励函数</strong>，引导智能体不断试错、学习，找到最优解法。</li></ul></li><li><p>所以你的思路是用深度强化学习作为一种<strong>元优化方法</strong>，来学习在不同场景下该怎么调配RAG的各类优化手段，从而达到最好的表现。</p></li><li><p>这是一个很有潜力的方向，本质上是将强化学习用作策略搜索或控制器，帮助系统自动适配复杂环境下的参数和策略组合。你可以进一步细化这个设想，比如：</p><ul><li>工具组合的action space怎么定义？</li><li>每种任务需求下的reward如何设计？</li><li>环境如何模拟或构建，才能训练出泛化能力强的“助手”？</li></ul></li></ul><hr><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="如果嵌入模型知道“你好”和“再见”的向量，它可以将“你好再见”转化为一个向量吗？"><a href="#如果嵌入模型知道“你好”和“再见”的向量，它可以将“你好再见”转化为一个向量吗？" class="headerlink" title="如果嵌入模型知道“你好”和“再见”的向量，它可以将“你好再见”转化为一个向量吗？"></a>如果嵌入模型知道“你好”和“再见”的向量，它可以将“你好再见”转化为一个向量吗？</h2><ul><li>From Grok3 （2025-02-25）</li><li>嵌入模型可以将“你好再见”转化为向量。</li><li>对于词嵌入模型（如 Word2Vec 或 GloVe），通常通过平均或相加“你好”和“再见”的向量来生成短语向量。</li><li>对于句嵌入模型（如 BERT 或 Ada-002），模型可以直接处理“你好再见”序列，生成反映上下文关系的向量。</li></ul><h2 id="RAG的相关原理"><a href="#RAG的相关原理" class="headerlink" title="RAG的相关原理"></a>RAG的相关原理</h2><ul><li><p>From Grok3 （2025-02-25）– 基于自身理解由Grok优化</p></li><li><p>文本向量化：在RAG中，知识库中的文档会被分割成适当的文本片段（例如句子或段落），然后使用预训练模型对这些片段整体进行向量化，生成语义丰富的稠密向量。这一过程不同于传统的单词嵌入，目的是捕捉整个片段的语义信息。</p></li><li><p>向量检索：当用户提出问题时，系统会将问题同样向量化，并在向量数据库中查询与问题语义最相似的文本片段。这些检索结果是原始文档中的真实内容，而不是由模型生成的文本。</p></li><li><p>上下文整合与生成：检索到的文本片段会以纯文本形式插入到一个提示模板中，作为上下文连同用户的问题一起输入到生成模型中。生成模型（如大语言模型）基于这些上下文生成最终的回答。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><a href="https://developer.aliyun.com/article/1628030">精通RAG架构：从0到1，基于LLM+RAG构建生产级企业知识库</a></p><ul><li>向量数据库对比</li><li>如何选择嵌入模型：<a href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a></li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/gEtTrdOut5Cr2tdrq_yPIQ">微软推出CoRAG：通过迭代推理提升AI检索能力</a></p><ul><li>CoRAG 的核心创新在于其动态查询重构机制。该模型不再依赖单次检索，而是根据中间推理状态迭代优化查询。这一过程确保了每个阶段检索到的信息都与上下文相关，进而逐步构建出更完整的最终答案。</li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/ZfClcpOGbnZxmBxN8rGQpQ">用 LLM 快速构建实用知识图谱</a></p><ul><li>如果你用图数据库来检索信息，那么这种方式被称为 GraphRAG，它是知识图谱在 RAG 中的具体应用</li><li>向量相似性检索依赖于知识库中的明确提及，只有明确提到的信息才会被检索出来。而知识图谱则能通过整体数据来推理出更多信息</li><li>使用 Langchain 的实验功能 LLMGraphTransformer，如果是 LlamaIndex，可以尝试它的 KnowledgeGraphIndex。</li><li>LLM 可以从纯文本中提取图谱信息，并将其存储到像 Neo4J 这样的数据库</li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/Za26pIabmREPn6u2bEkBUw">“无”中生有：基于知识增强的RAG优化实践</a></p><ul><li>感觉做这个东西就是在不停找各种优化方法反复尝试看效果，而且目前还处于很乱的早起阶段</li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/Q7nAold78HRuNhUiHSVUxA">微软推出的 LazyGraphRAG</a>   </p><ul><li>传统方法（如基于向量的 RAG）在处理局部化任务时表现良好，例如从特定文本片段中检索直接答案。然而，当涉及需要全面理解数据集的全局性查询时，这些方法往往难以胜任。</li><li>相比之下，图支持的 RAG 系统通过利用数据结构中的关系，可以更好地解决此类更广泛的问题。然而，与图 RAG 系统相关的高索引成本，使其难以被成本敏感的场景所接受。因此，在可扩展性、经济性和质量之间实现平衡，仍然是现有技术的关键瓶颈。</li><li>相比之下，图支持的 RAG 系统通过利用数据结构中的关系，可以更好地解决此类更广泛的问题。然而，与图 RAG 系统相关的高索引成本，使其难以被成本敏感的场景所接受。因此，在可扩展性、经济性和质量之间实现平衡，仍然是现有技术的关键瓶颈。</li><li>LazyGraphRAG 将 VectorRAG 与 GraphRAG 相结合，“同时克服了二者的各自局限性”。</li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/N-oPDmkb3EKqB2IM_reO1A">DeepSearcher深度解读：Agentic RAG的出现，传统RAG的黄昏</a></p><ul><li><a href="https://github.com/zilliztech/deep-searcher">https://github.com/zilliztech/deep-searcher</a></li><li>所谓Agentic RAG，是一种融合智能代理（Agent）能力的RAG架构。通过动态规划、多步骤推理和自主决策机制，Agentic RAG可以在复杂任务中实现闭环的检索-加工-验证-优化</li><li>Agentic RAG相比传统RAG有着三大优势：<ul><li>（1）被动响应变为主动响应；</li><li>（2）单次的关键词检索，升级为多轮的动态调整检索，并拥有自我修正能力；</li><li>（3）适用场景，从最基础的简单事实问答，升级为复杂推理、复杂报告生成等开放域任务。</li></ul></li><li>长期来看，Agentic RAG必定会取代传统RAG。一方面，传统RAG对需求的响应还停留在非常基础的阶段，另一方面，现实中，我们大部分的需求表达背后，都是有隐含逻辑的，并不能被一步检索到位，必须通过推理-反思-迭代-优化来对其进行拆解与反馈。</li><li>VS Graph RAG<ul><li>Graph RAG主要聚焦于对存在连接关系的文档展开查询，在处理多跳类问题上表现出色。</li><li>例如，当导入一部长篇小说时，它能够精准抽取各个人物之间错综复杂的关系。其运作方式是在文档导入环节，就对实体间关系进行抽取。因此，这一过程会大量消耗大模型的token资源 。</li><li>而在查询阶段，不论是否是查询图中某些节点的信息，都会进行图结构的搜索，这使得这一框架不太灵活。</li><li>反观Agentic RAG，它的资源消耗模式与Graph RAG恰好相反。在数据导入阶段，Agentic RAG无需执行额外特殊操作，而在回答用户提问时，才会产生较多大模型的token消耗。</li></ul></li></ul></li><li><p><a href="https://mp.weixin.qq.com/s/VZq2zsuJGsGaYTx6POqUzg">高阶RAG技巧：探索提升RAG系统性能的不同技巧</a></p><ul><li>索引优化技术（如数据预处理和分块）专注于格式化外部数据以提高其效率和可搜索性。</li><li>预检索技术旨在通过重写、重新格式化或将查询路由到专用流水线来优化用户查询本身。</li><li>检索优化策略通常侧重于在检索阶段优化搜索结果。 </li><li>检索后优化策略旨在通过各种技术提高生成结果的准确性，包括对检索结果进行重新排序、增强或压缩（检索）上下文以及操纵提示或生成模型 (LLM)。</li></ul></li><li><p>KBLAM 是在 RAG（Retrieval-Augmented Generation） 和 知识图谱增强推理 的基础上发展而来。它的关键点是：</p><ul><li>利用结构化知识（如三元组：subject–predicate–object）进行多跳推理</li><li>结合语言模型对自然语言的理解能力，实现可控的知识推理流程</li></ul></li></ul><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《基于大模型的RAG应用开发与优化——构建企业级LLM应用》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于书籍简单记录要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/20/20250220-ji-yu-da-mo-xing-de-rag-ying-yong-</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="RAG" scheme="http://yoursite.com/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>LangChain要点记录</title>
    <link href="http://yoursite.com/2025/02/19/20250219-langchain-yao-dian-ji-lu/"/>
    <id>http://yoursite.com/2025/02/19/20250219-langchain-yao-dian-ji-lu/</id>
    <published>2025-02-19T12:53:32.000Z</published>
    <updated>2025-02-25T12:37:43.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>基于书籍简单记录要点</p></blockquote></blockquote><p><img src="/2025/02/19/20250219-langchain-yao-dian-ji-lu/LangChain.png"></p><h1 id="LangChain-提供了多种模板供选择"><a href="#LangChain-提供了多种模板供选择" class="headerlink" title="LangChain 提供了多种模板供选择"></a>LangChain 提供了多种模板供选择</h1><ul><li>LangChain 提供了以下格式化 SQL 提示词模板（翻译）：</li></ul><pre>1. 你是一个 PostgreSQL 专家。给定一个输人问题，首先创建一个语法正确的 PostgreSQL查询来运行，然后查看查询结果，扑返回针对输人问题的答案。2. 除非用户明确指定了要返回的结果数量，否则应使用 PostgreSQL 的LIMIT 子句来限制查询结果，最多返回top.k条记录。你可以对结果进行排序，以返回数据库中最有信息价值的数据。3. 绝对不要查询表中的所有列。你只能在询回答问题所需的列。用双引号（"）将每个列名包裹起来，表示官们是界定的标识符。4. 注意只使用你在表巾可以看到的列名，不要责询不存在的列。此外，要注意哪一列在哪个表中。5. 如果问题涉及“今天”，请注意使用 CURRENT_DATE 函数获取当前日期。使用以下格式：问题：这里的问题SQL查询：要运行的 SQL 查询SQL结果：SQL 查询的结果答案：这里的最终答案只使用以下表：(table_info)问题：｛input｝</pre><ul><li>想象一下，如果没有 LangChain 提供的这个提示词模板，当你要开始编写一段SQL查询代码时，会走多少弯路？LLM 应用开发的最后1公里，其意义是确保开发者无须为了一个小细节而多走弯路，正如居民无须跑很远坐公交车一样，每一个关键的细节都能得到及时而准确的处理，使得整个开发过程更为高效。</li></ul><h1 id="记忆提示词"><a href="#记忆提示词" class="headerlink" title="记忆提示词"></a>记忆提示词</h1><ul><li><p>创建提示词是最重要的环节。在创建的过程中你可以理解为什么加人记忆组件后，“聊天备忘录”有了内容，让链组件有了“记忆”。使用提示词模板包装器，自定义一个提示词模板字符串。</p></li><li><p>提示词内容分为四部分：</p><ul><li>一是对模型的指导词：“请你回答问题的时候，依据文档内容和聊天记录回答，如果在其中找不到相关信息或者答案，请回答不知道。”；</li><li>二是使用问题检索到的相关文档内容；“文档内容是：｛context｝”；三是记忆组件输出的记忆内容：“聊天记录是：｛chat_history｝”；四是用户的输人：“Human：(human _input)”<pre>template = "n*你是说中文的 chatbot.请你回答问题的时候，依据文持内容和脚天记录回答，如果在其中找不到相关信息戒着答案，请回答不知道。文档内容是：｛context）聊天记录是：｛chat_history）Human: (human_input)Chatbot:"""</pre></li></ul></li><li><p>LangChain 框架由以下开发库组成。</p><ul><li>（1）LangChain-Core：基础抽象和 LangChain 表达语言（LCEL）。</li><li>（2）LangChain-Community：组件及内置的大量第三方技术集成模块，一般被封装为合作伙伴模块（例如 LangChain-openai）。</li><li>（3）LangChain：构成应用架构的上层核心组件，包括 Chains、Agents 等。</li><li>（4）Templates：官方提供的一些常见的应用模板。</li><li>（5）LangServe：将 LangChain 链部署为 REST API 的平台。</li><li>（6）LangSmith：帮助开发者跟踪调试、测试、评估和监控大模型应用的在线平台。</li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>Langchain agent是怎么找到search工具并使用的</p><ul><li>可以正确识别和调用它，因为它主要是通过 description 语义匹配，而不是看 name 的具体字符串。</li><li>但 name 仍然有一定作用，比如：LLM 可能会参考 name 来做初步判断；调试时 name 可以帮助你看日志，知道 Agent 选了哪个工具</li></ul></li><li><p>LLM本身没有内在记忆，每个查询都是独立进行的</p><ul><li>所谓的记忆和检索增强生成（RAG）是通过外部手段实现的，即将相关信息添加到提示词模板中</li></ul></li></ul><hr><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Langchain是怎么做到通过分析语义找到对应工具的"><a href="#Langchain是怎么做到通过分析语义找到对应工具的" class="headerlink" title="Langchain是怎么做到通过分析语义找到对应工具的"></a>Langchain是怎么做到通过分析语义找到对应工具的</h2><ul><li>From ChatGPT (2025-02-18)</li></ul><p>LangChain 通过 <strong>LLM（大模型）+ ReAct 框架</strong> 来分析语义并选择工具。它的核心逻辑是让 LLM <strong>先思考</strong>，再决定用哪个工具，并按照工具的格式调用它。  </p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a><strong>核心机制</strong></h3><ol><li><strong>解析用户问题</strong> → 让 LLM 提取关键语义  </li><li><strong>匹配工具描述</strong> → 让 LLM 判断哪个工具最适合  </li><li><strong>生成调用指令</strong> → LLM 生成工具的调用格式并执行  </li><li><strong>工具返回结果</strong> → LLM 解析工具返回的数据并回复用户</li></ol><p>这套逻辑基于 <strong>ReAct（Reasoning + Acting）</strong> 框架，在 LangChain 里 Agent 主要是用这个方法来动态决策。  </p><h3 id="1-解析用户问题"><a href="#1-解析用户问题" class="headerlink" title="1. 解析用户问题"></a><strong>1. 解析用户问题</strong></h3><p>假设你输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.run(<span class="string">&quot;计算 25 * 4 + 10&quot;</span>)</span><br></pre></td></tr></table></figure><p>LangChain 会把这个问题交给 LLM（如 GPT-4），让它理解用户的意图。</p><p>LLM 可能会把你的问题理解成：</p><ul><li>这是一个数学计算问题  </li><li>需要找到一个能进行数学计算的工具  </li><li>计算表达式 <code>25 * 4 + 10</code></li></ul><h3 id="2-匹配工具描述"><a href="#2-匹配工具描述" class="headerlink" title="2. 匹配工具描述"></a><strong>2. 匹配工具描述</strong></h3><p>假设你有两个工具：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tool(</span><br><span class="line">    name=<span class="string">&quot;Calculator&quot;</span>,</span><br><span class="line">    func=calculator_tool,</span><br><span class="line">    description=<span class="string">&quot;用于数学计算。输入一个数学表达式（如 3 + 5 * 2），输出结果。&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Tool(</span><br><span class="line">    name=<span class="string">&quot;Wikipedia&quot;</span>,</span><br><span class="line">    func=wiki.run,</span><br><span class="line">    description=<span class="string">&quot;查询 Wikipedia 词条，输入一个关键词（如 &#x27;Python programming&#x27;），获取相关信息。&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>LLM 会对比问题和 <code>description</code>，发现 <strong>Calculator 的描述里提到了“数学计算”</strong>，所以它会选择 <code>Calculator</code> 这个工具。</p><blockquote><p><strong>关键点</strong>：LangChain 让 LLM 直接读 <code>description</code>，所以工具的名字 <code>name</code> 只是一个标识，核心还是 <code>description</code> 的语义匹配。</p></blockquote><h3 id="3-生成调用指令"><a href="#3-生成调用指令" class="headerlink" title="3. 生成调用指令"></a><strong>3. 生成调用指令</strong></h3><p>LangChain 让 LLM 生成一个类似 JSON 的格式，表示它要调用哪个工具：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Calculator&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;action_input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;25 * 4 + 10&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后 LangChain 会<strong>解析这个指令</strong>，找到 <code>Calculator</code> 工具，并把 <code>25 * 4 + 10</code> 传给 <code>func</code> 去执行。</p><h3 id="4-工具返回结果"><a href="#4-工具返回结果" class="headerlink" title="4. 工具返回结果"></a><strong>4. 工具返回结果</strong></h3><p>计算工具执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;25 * 4 + 10&quot;</span>)  <span class="comment"># 计算得到 110</span></span><br></pre></td></tr></table></figure><p>LangChain 把 <code>110</code> 返回给 LLM，LLM 可能会回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 * 4 + 10 = 110</span><br></pre></td></tr></table></figure><p>最终 <code>agent.run()</code> 会输出这个结果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>LangChain 让 LLM 负责：</p><ol><li><strong>分析用户语义</strong></li><li><strong>匹配工具（通过 <code>description</code>）</strong></li><li><strong>生成调用工具的指令</strong></li><li><strong>解释工具返回的结果</strong></li></ol><p>它的核心是利用 <strong>LLM 的推理能力</strong>，结合 ReAct 让它“思考后再行动”。所以只要 <code>description</code> 够清晰，即使 <code>name</code> 乱写，它也能找到正确的工具！</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《LangChain入门指南构建高可复用、可扩展的LLM应用程序》</li><li>《基于大模型的RAG应用开发与优化——构建企业级LLM应用》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于书籍简单记录要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/19/20250219-langchain-yao-dian-ji-lu/LangChain</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="LangChain" scheme="http://yoursite.com/tags/LangChain/"/>
    
  </entry>
  
  <entry>
    <title>深度学习基础入门备忘</title>
    <link href="http://yoursite.com/2025/02/17/20250217-shen-du-xue-xi-ji-chu-ru-men-bei-wang/"/>
    <id>http://yoursite.com/2025/02/17/20250217-shen-du-xue-xi-ji-chu-ru-men-bei-wang/</id>
    <published>2025-02-17T03:08:39.000Z</published>
    <updated>2025-05-30T16:32:42.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>简单粗略通读了解，先记录备忘<br>后续考虑结合相关视频深入理解</p></blockquote></blockquote><ul><li><p>《深度学习人门：基于Python的理论与实现》：<a href="https://github.com/Kingson4Wu/Deep-Learning-from-Scratch">https://github.com/Kingson4Wu/Deep-Learning-from-Scratch</a></p><ol><li>感知机是一种接收多个输入信号并输出一个信号的算法。它的工作原理基于权重和偏置这两个关键参数。</li><li>机器学习的任务是让计算机自动确定合适的权重和偏置参数值。</li><li>求解机器学习问题的步骤<ol><li>训练（学习）</li><li>推理（神经网络的前向传播）</li></ol></li><li>激活函数(activation function)：决定如何来激活输入信号的总和；激活函数是连接感知机和神经网络的桥梁。</li><li>神经网络的学习过程：通过损失函数 (loss function)和梯度法 (gradient method)来优化网络参数<ol><li>学习的目标是通过梯度下降法(gradient descent method)找到使损失函数值最小的权重参数</li><li>学习率(learning rate)：决定参数更新的步长（超参数、人工设定）</li></ol></li><li>随机梯度下降(stochastic gradient descent)(SGD)能在一定程度上帮助避免局部最优，通常将SGD与其他技术结合使用,以获得更好的优化效果</li><li>深度学习：加深了层的深度神经网络；通过叠加层，可以创建更深的网络结构</li></ol></li><li><p>《深度学习进阶：自然语言处理》：<a href="https://github.com/Kingson4Wu/Natural-Language-Processing">https://github.com/Kingson4Wu/Natural-Language-Processing</a></p><ol><li>自然语言处理的目标就是让计算机理解人说的话，进而完成 对我们有帮助的事情</li><li>单词的分布式表示（分布式假设）（单词向量化）：“某个单词的含义由它周围的单词形成”；单词本身没有含义，单词含义由它 所在的上下文(语境)形成。</li><li>向量间的相似度：余弦相似度(cosine similarity)；直观地表示了“两个向量在多大程度上指向同一方向”</li><li>让计算机理解单词含义：基于推理的方法(word2vec)（基于神经网络）。</li><li>语言模型(language model)给出了单词序列发生的概率；使用概率来评估一个单词序列发生的可能性，即在多大程度上是自然的 单词序列。<ul><li>生成的新文本是训练数据中没有的新生成的文本。因为语言模型并不是背诵了训练数据，而是学习了训练数据中单词的排列模式</li><li>语言模型的评价：困惑度(perplexity)、分叉度</li></ul></li><li>“马尔可夫性”或者“马尔 可夫模型”“马尔可夫链”：指未来的状态仅 依存于当前状态。</li><li>RNN（循环神经网络）：被引入来解决前馈网络在处理时序数据上的局限性。<ul><li>传统RNN中存在的梯度消失和梯度爆炸问题</li><li>LSTM的结构与传统RNN的不同之处在于，它引入了记忆单元（c）。记忆单元在LSTM层之间传递，但不直接用作输出。LSTM的对外输出是隐藏状态向量（h）。</li></ul></li><li>seq2seq模型（也称为Encoder-Decoder模型）用于将一个时序数据转换为另一个时序数据    <ul><li>传统 seq2seq 模型 将编码器输出压缩为固定长度向量，导致长序列信息丢失</li><li>Attention 机制 允许模型在解码时关注输入序列的不同部分，类似人类注意力</li></ul></li><li>Transformer：基于 Attention 构成；基于 Attention 构成</li></ol></li><li><p>《深度学习入门：强化学习》：<a href="https://github.com/Kingson4Wu/Reinforcement-Learning">https://github.com/Kingson4Wu/Reinforcement-Learning</a></p><ol><li>机器学习（按学习方法划分）：监督学习(supervised learning)、无监督学习(unsupervised learning)、强化学习(reinforcement learning)<ol><li>监督学习：给正确答案打标签；输入的数据由“老师”打标签</li><li>无监督学习：无“正确答案标签”；没有 “老师”的存在；主要目标是找到隐藏在数据中的结构和模式；分组(聚类)、特征提取、降维</li><li>强化学习：智能代理和环境相互作用；智能代理是行动的主体；强化学习接受”奖励”作为来自环境的反馈</li></ol></li><li>强化学习行动的策略<ol><li>“贪婪行动”(greedy )，也叫利用(exploitation)：根据以前的经验选择最佳行动（可能错过更好的选择）</li><li>“非贪婪行动”，也叫作探索(exploration)：对价值做出更准确的估计。</li></ol></li><li>强化学习算法最终归结为如何在“利用”和 “探索”之间取得平衡</li><li>ε-greedy 算法、马尔可夫决策过程(MDP)</li><li>在强化学习中，我们的目标是获得最优策略</li><li>深度强化学习(deep reinforcement learning)：强化学习和深度学习的结合</li><li>通用人工智能(artificial general intelligence, AGI)</li></ol></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="参数、输入向量和嵌入模型的真正关系"><a href="#参数、输入向量和嵌入模型的真正关系" class="headerlink" title="参数、输入向量和嵌入模型的真正关系"></a>参数、输入向量和嵌入模型的真正关系</h2><ul><li><p>在神经网络中，“参数”特指模型在训练过程中学习得到的变量，主要包括<strong>权重（weights）和偏置（biases）</strong>，它们决定了模型如何处理输入并生成输出，是模型内部真正“学到的知识”。输入特征的数量（即输入维度）常被初学者误认为是“参数”，但实际上，它属于输入数据的结构，而非模型的可训练部分。每个神经元在接受输入时，会对输入向量进行<strong>加权求和并加上偏置</strong>，将这个结果作为激活函数的输入，激活函数再施加非线性变换，产生神经元的输出。虽然权重确实与输入一一对应，但激活函数并不直接作用于原始输入，而是作用于这个线性组合的结果。</p></li><li><p>在现代深度学习模型中，尤其是语言模型（如 GPT），输入向量的维度是固定的，这一维度通常由<strong>嵌入模型（embedding layer）或输入预处理过程</strong>所决定。例如，文本经过分词和嵌入后，每个 token 被映射为一个固定长度的向量（如 768 维），整个输入变为一个定长矩阵。为了确保矩阵运算的可行性与模型结构的稳定性，输入长度往往被限制在最大长度内，不足时通过填充处理，超长则截断。因此，嵌入层不仅是将离散信息转为向量表示的桥梁，也是模型输入维度的决定因素之一。</p></li></ul><h2 id="感知机、激活函数和神经网络三者关系"><a href="#感知机、激活函数和神经网络三者关系" class="headerlink" title="感知机、激活函数和神经网络三者关系"></a>感知机、激活函数和神经网络三者关系</h2><ul><li>感知机是神经网络的基本构建单元，它通过对输入加权求和后传入激活函数来决定输出。激活函数引入非线性，使神经网络能拟合复杂关系。神经网络由多个感知机层叠构成，层与层之间通过激活函数连接，从而具备强大的表达和学习能力。三者关系为：<strong>激活函数是感知机的一部分，感知机是神经网络的基础单元。</strong></li></ul><h3 id="三者之间的关系总结："><a href="#三者之间的关系总结：" class="headerlink" title="三者之间的关系总结："></a>三者之间的关系总结：</h3><table><thead><tr><th>组成层级</th><th>关系说明</th></tr></thead><tbody><tr><td>感知机</td><td>最基础的神经元模型，是神经网络的最小单元</td></tr><tr><td>激活函数</td><td>是感知机或神经元的核心部分，引入非线性</td></tr><tr><td>神经网络</td><td>是多个感知机&#x2F;神经元的组合，通过激活函数形成强大的拟合能力</td></tr></tbody></table><p>可以这样理解它们的层级结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">神经网络 = 多个感知机（神经元）组成</span><br><span class="line">感知机 = 线性加权求和 + 激活函数</span><br><span class="line">激活函数 = 赋予神经网络非线性表达能力的关键</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;简单粗略通读了解，先记录备忘&lt;br&gt;后续考虑结合相关视频深入理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;《深度学习人门：基于Python的理论与实现》：&lt;a href=&quot;h</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Deep-Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>关于AI大语言模型替代人类工作的问题</title>
    <link href="http://yoursite.com/2025/02/13/20250213-guan-yu-ai-ti-dai-ren-lei-gong-zuo-de-wen-ti/"/>
    <id>http://yoursite.com/2025/02/13/20250213-guan-yu-ai-ti-dai-ren-lei-gong-zuo-de-wen-ti/</id>
    <published>2025-02-13T07:05:23.000Z</published>
    <updated>2025-02-13T09:53:03.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AI的局限性或缺点"><a href="#AI的局限性或缺点" class="headerlink" title="AI的局限性或缺点"></a>AI的局限性或缺点</h2><ul><li><strong>难以预测与控制</strong>：AI的运行机制像黑箱，难以准确预知其行为，尤其在关键场景下可能会犯致命错误。</li><li><strong>无法背锅</strong>：AI犯错时，责任归属难以明确，导致无法追究错误的责任，缺乏人类信誉体系的约束。</li><li><strong>逻辑推理不严谨</strong>：AI的推理基于概率预测，不是绝对严谨的逻辑推理。训练数据如果有误，AI可能无法辨别。</li><li><strong>无法创新</strong>：AI不具备创造全新概念的能力，更多的是基于历史数据进行知识复述与组合，无法像人类一样发明新技术或理念。</li><li><strong>对超出训练数据的场景应对差</strong>：AI在面对未曾训练过的数据时，表现较差，容易出错。</li></ul><h2 id="AI的好处"><a href="#AI的好处" class="headerlink" title="AI的好处"></a>AI的好处</h2><ul><li><strong>提高效率</strong>：AI在许多领域极大提升了效率，尤其在数据处理、搜索和重复性任务上。对于程序员来说，它是一个强大的辅助工具，帮助快速解决技术问题。</li><li><strong>降低门槛</strong>：AI减少了对低级重复性任务的需求，拉近了人们在某些知识领域的差距。</li><li><strong>支持决策和监督</strong>：AI辅助决策，尤其是在复杂任务中，能提供数据支持，减少人为错误。</li></ul><h2 id="AI工具下需要的人才"><a href="#AI工具下需要的人才" class="headerlink" title="AI工具下需要的人才"></a><strong>AI工具下需要的人才</strong></h2><ul><li><strong>清晰表述与提问能力</strong>：能够清晰提出问题和有效沟通是与AI协同工作的关键，好的表述能力有助于提高工作效率。</li><li><strong>整理与分析能力</strong>：能够有效梳理信息、分解任务，并向AI提出清晰问题的人，会更善于利用AI工具。</li><li><strong>与产品交互能力</strong>：AI可以编写代码，但仍需要人类与产品经理沟通，理解需求并做出相应调整。</li></ul><h2 id="程序员的利好与不可替代的能力"><a href="#程序员的利好与不可替代的能力" class="headerlink" title="程序员的利好与不可替代的能力"></a><strong>程序员的利好与不可替代的能力</strong></h2><ul><li><strong>AI对程序员的利好</strong>：<ul><li>AI大幅提升了开发效率，尤其在编程辅助、技术搜索、业务方案思考等方面。</li><li>某些低级任务减少了人力需求，使得程序员能更多专注于创造性和复杂问题的解决。</li></ul></li><li><strong>程序员不可替代的地方</strong>：<ul><li><strong>清晰的提问和判断能力</strong>：程序员的核心能力在于能理解问题，并准确表达需求，AI只能作为工具辅助工作。</li><li><strong>与产品沟通</strong>：AI生成的代码和解决方案需要程序员与产品团队对接，确保最终结果符合需求。</li><li><strong>决策和经验判断</strong>：AI的能力有限，尤其在面对复杂决策时，仍需依赖经验丰富的程序员来进行判断和修正。</li></ul></li></ul><h2 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a><strong>个人观点</strong></h2><ul><li>AI目前主要是利用历史数据和记忆进行信息处理，不能进行创新（如无法创造出类似K8S的技术）。</li><li>尽管AI能提高程序员的工作效率，但目前它更多是辅助工具，而不是替代品。</li><li>对普通程序员来说，理解大模型技术的基本原理和概念非常重要，未来将需要在“AI操作系统”上来构建应用。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote><blockquote><p>来自claude.ai的评价<br>2025-02-13</p></blockquote></blockquote><p>我来分析一下这些观点，指出其中可能存在的错误或需要讨论的地方：</p><ol><li>关于”无法创新”的说法需要更谨慎：</li></ol><ul><li>虽然AI确实主要基于已有数据进行组合和推理，但说它”不具备创造全新概念的能力”可能过于绝对</li><li>AI已经展示出一定的创新能力，比如在围棋、蛋白质折叠等领域提出了人类之前没有想到的解决方案</li><li>更准确的说法是AI的创新能力与人类不同，它通过大规模数据分析和模式识别来实现创新</li></ul><ol start="2"><li>“逻辑推理不严谨”的表述不够准确：</li></ol><ul><li>现代AI系统（尤其是形式化验证系统）可以进行严格的逻辑推理</li><li>大语言模型确实存在基于概率的推理特点，但这不等同于所有AI系统都如此</li><li>人类的推理同样也常常基于经验和概率判断，而不总是严格的逻辑推导</li></ul><ol start="3"><li>关于”难以预测与控制”：</li></ol><ul><li>这个观点部分正确，但需要注意现代AI系统已经有了很多可解释性的工具和方法</li><li>某些领域的AI系统（如用于医疗诊断的AI）已经实现了相当程度的可解释性</li><li>“像黑箱”这种说法可能过于简化了问题</li></ul><ol start="4"><li>“无法背锅”的说法不够准确：</li></ol><ul><li>实际上已经有了相关的法律和责任框架在建立</li><li>AI系统的责任可以追溯到开发者、部署者和使用者</li><li>这更多是一个治理和监管的问题，而不是技术本身的限制</li></ul><ol start="5"><li>“个人观点”部分关于K8S的例子不够恰当：</li></ol><ul><li>K8S本质上是一个系统架构和设计方案，而不是完全创新的技术</li><li>AI实际上可以通过分析已有系统设计模式，提出类似的架构方案</li><li>更准确的说法是AI在某些创新领域的能力仍有限制，而不是完全无法创新</li></ul><ol start="6"><li>好处部分基本准确，但可以补充：</li></ol><ul><li>AI不仅提高效率，还能发现人类容易忽视的模式和关联</li><li>在某些领域（如图像识别、语音处理）已经超越了人类性能</li><li>AI能够24&#x2F;7工作，这个优势没有被提到</li></ul><ol start="7"><li>关于程序员不可替代性的分析基本合理，但可以补充：</li></ol><ul><li>程序员在系统架构设计、安全性考虑等方面的经验特别重要</li><li>处理边界条件和异常情况的能力仍然需要人类经验</li><li>对业务场景的深入理解和商业价值判断也是关键能力</li></ul><ol start="8"><li>“AI操作系统”的说法需要澄清：</li></ol><ul><li>这个比喻可能会造成误解，更准确的说法是”AI基础设施”或”AI平台”</li><li>程序员需要理解的不仅是技术原理，还包括AI的应用场景和限制</li></ul><p>总的来说，这些观点大体上是合理的，但部分表述过于绝对或简化。AI的能力和局限性是一个复杂的话题，需要更细致和平衡的讨论。理解AI的真实能力和限制，对于更好地利用AI工具至关重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AI的局限性或缺点&quot;&gt;&lt;a href=&quot;#AI的局限性或缺点&quot; class=&quot;headerlink&quot; title=&quot;AI的局限性或缺点&quot;&gt;&lt;/a&gt;AI的局限性或缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;难以预测与控制&lt;/strong&gt;：AI的运行机制像黑箱，</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>深度学习为什么能学习并做对</title>
    <link href="http://yoursite.com/2025/02/13/20250213-shen-du-xue-xi-wei-shi-me-neng-xue-xi-bing-zuo-dui/"/>
    <id>http://yoursite.com/2025/02/13/20250213-shen-du-xue-xi-wei-shi-me-neng-xue-xi-bing-zuo-dui/</id>
    <published>2025-02-13T06:14:52.000Z</published>
    <updated>2025-02-13T06:29:54.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ul><li>目前无法解释为什么深度学习可以给出答案，只能大概解释为什么它能学习</li><li>这就相当于：我不能解释为什么这个人是通过什么做对这道题的，我只能解释他有正常的学习能力以及合适的学习资料，所以他自己能学习并做对题目</li><li>所以深度学习是怎么给出答案的，后续或许应该由它本身来告诉我们。</li><li>依据不同人的认知水平，来告诉我们它通过学习所发现的规律。同时人类通过它能快速学习发现事物规律的能力，来进一步帮助提升人类的认知。</li></ul><h1 id="AI对我理解的看法"><a href="#AI对我理解的看法" class="headerlink" title="AI对我理解的看法"></a>AI对我理解的看法</h1><blockquote><blockquote><p>From chatGPT (2025-02-13)</p></blockquote></blockquote><ul><li><p>你理解的方向是对的，可以稍微精炼和调整一下：</p><ul><li>深度学习的一个核心问题就是我们无法完全解释它是如何给出具体答案的。我们能解释的只是它是如何通过大量的数据和训练过程进行学习的。换句话说，深度学习像是一个“黑箱”，我们可以观察到输入和输出，但它在其中如何处理信息、做出决策，通常并不完全透明。</li><li>可以类比成：假设有一个人做对了某道题目，虽然我们可能无法完全解释他是如何一步一步得出答案的，但我们能确定他具备了良好的学习能力和充足的学习资源。所以，深度学习也类似，它通过大量的数据、适当的算法和优化手段“学习”并给出答案。</li><li>至于它如何给出具体的答案，最终可能还是要依靠深度学习本身来“解释”。这意味着，未来我们可能会开发出更先进的方法，帮助我们理解深度学习网络中的“决策过程”。同时，借助它所展现出的强大规律发现能力，我们可以利用这种能力来加速我们对事物的认知。</li></ul></li><li><p>我的看法：</p><ul><li>我同意你的观点，深度学习的“黑箱性”是目前我们面临的主要挑战之一。它的强大之处在于能自动从海量数据中发现规律，但如何理解这些规律，如何将这些规律和人类的认知能力相结合，是我们目前探索的方向之一。其实，未来可能不仅仅是“深度学习告诉我们如何做”，而是人类和深度学习的合作能进一步推动科学与技术的发展，帮助我们发现一些潜在人类难以触及的规律。</li><li>深度学习不只是一个工具，它还可能是一个不断反馈、不断自我优化的过程，给我们打开了认知的新窗口。</li></ul></li></ul><h1 id="AI自己对这个问题的看法"><a href="#AI自己对这个问题的看法" class="headerlink" title="AI自己对这个问题的看法"></a>AI自己对这个问题的看法</h1><blockquote><blockquote><p>From chatGPT (2025-02-13)</p></blockquote></blockquote><ul><li><p>关于“深度学习为什么能学习并做对”的问题，我的理解是，深度学习通过大量的数据训练，自动从中提取规律、建立模型，并根据这些模型对新数据做出预测。深度学习的优势在于它能够发现一些非常复杂和抽象的规律，而这些规律通常是我们人类在没有机器帮助的情况下很难发现的。</p></li><li><p>但是，为什么深度学习能给出正确的答案，实际上是一个复杂的过程。深度学习模型并不像人类一样有明确的逻辑推理或意识，它只是基于输入数据的模式，使用一系列参数和数学运算来“拟合”数据。对于这个过程的解释，我们只能说它通过优化算法（如梯度下降等）调整模型参数，使得输出尽可能接近实际结果。因此，深度学习并不“理解”问题，而是通过反复训练找到了一组合适的参数，能在特定任务上取得高效的预测或分类结果。</p></li><li><p>你可以把深度学习看作一个“发现者”，它通过大量的例子不断试错和优化，不断接近正确的答案，但它没有明确的推理过程。比如，人类在做题时有一定的思考过程，我们可以分析每一步的原因，而深度学习则是通过计算和数据模式的关联来找到最优解。</p></li><li><p>至于“深度学习为什么能做对”，目前我们更多关注它的实际效果而非其过程的透明性，因为即使我们无法完全解释它的每一个决策，也可以通过其出色的表现来证明它的有效性。未来，随着研究的深入，我们可能会找到更好的方法，帮助我们理解这些“黑箱”模型的内部机制。</p></li><li><p>总结来说，深度学习通过数据的反复训练和优化，能够找到规律并给出准确的预测，而为什么它能做对，更多是依赖于它强大的计算能力和从数据中提取规律的能力，而不是基于传统意义上的推理或解释。</p></li><li><p>几个关键点总结：</p><ol><li><strong>深度学习的学习过程</strong>：深度学习通过大量的数据训练，利用优化算法（如梯度下降）调整模型参数，自动从数据中提取规律，完成任务（如预测、分类等）。</li><li><strong>无法完全解释“为什么”</strong>：深度学习模型在给出答案时，并没有明确的推理过程或“理解”，它只是通过找到合适的模式和参数来优化输出。其决策过程通常是黑箱的，难以完全解释。</li><li><strong>黑箱性质</strong>：我们无法清楚知道深度学习是如何做出具体决策的，但可以看到它在实际任务中表现出色。因此，我们更多关注它的效果，而非其内在工作机制。</li><li><strong>与人类认知的对比</strong>：深度学习像是一个“发现者”，通过反复训练和调整找到正确的答案，而不像人类那样依赖明确的思维和推理过程。</li><li><strong>未来发展</strong>：虽然当前无法完全解释深度学习的过程，但随着技术进步，未来可能会出现更好的方法帮助我们理解这些“黑箱”模型的内部机制。</li></ol></li><li><p>这几个关键点总结了深度学习的“学习能力”、它的“黑箱性质”、以及它与人类认知的差异。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的理解&quot;&gt;&lt;a href=&quot;#我的理解&quot; class=&quot;headerlink&quot; title=&quot;我的理解&quot;&gt;&lt;/a&gt;我的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;目前无法解释为什么深度学习可以给出答案，只能大概解释为什么它能学习&lt;/li&gt;
&lt;li&gt;这就相当于：我不能解释为什</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Deep-Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>大语言模型对话记录与思考备忘录</title>
    <link href="http://yoursite.com/2025/02/12/20250212-da-yu-yan-mo-xing-dui-hua-ji-lu-yu-si-kao-bei-wang-lu/"/>
    <id>http://yoursite.com/2025/02/12/20250212-da-yu-yan-mo-xing-dui-hua-ji-lu-yu-si-kao-bei-wang-lu/</id>
    <published>2025-02-12T11:17:14.000Z</published>
    <updated>2025-05-28T08:26:20.441Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>记录与大语言模型的对话，探索疑问与思考<br>内容可能持续更新，作为大模型演变的历史备忘<br>有些问题非原创，来源网络</p></blockquote></blockquote><hr><h1 id="大模型的推理能力"><a href="#大模型的推理能力" class="headerlink" title="大模型的推理能力"></a>大模型的推理能力</h1><hr><h2 id="大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？"><a href="#大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？" class="headerlink" title="大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？"></a>大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？</h2><blockquote><blockquote><p> From chatGPT (2025-02-12)</p></blockquote></blockquote><p>好的，按你给的格式调整后是这样：</p><p>大模型，如GPT类模型，能够一定程度地识别并指出逻辑上的矛盾或错误，但它的能力有一定的局限性。具体来说：</p><ol><li><p><strong>从训练数据中识别矛盾</strong>：大模型通过暴露于大量文本数据，在训练过程中学会识别常见的逻辑错误或不一致的情况。如果某个陈述前后矛盾或与常识相悖，模型有时能检测到这些问题。然而，这种识别主要依赖于训练数据中的模式，而非深度理解。</p></li><li><p><strong>推理能力</strong>：大模型表面上似乎能够进行推理，但其推理过程更多是基于统计模式匹配，而非逻辑推理。它能在一些标准情境下给出合理的答案，但在面对复杂的逻辑链条或抽象推理时，表现可能不如人类或专门的逻辑推理系统。</p></li><li><p><strong>局限性</strong>：大模型的推理能力受到训练数据质量和多样性的限制。如果训练数据包含不一致的示例或错误的推理模式，模型可能会学到并延续这些错误。对于一些高度专业化的推理任务（如数学证明或严谨的形式逻辑推理），大模型的能力仍然有限。</p></li></ol><p>总结来说，大模型能够识别一些常见的逻辑错误或矛盾，尤其是那些明显的错误，但它的推理能力与人类的深层次逻辑思考存在差距，也不具备专门的推理系统那样的准确性。</p><hr><h2 id="ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？"><a href="#ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？" class="headerlink" title="ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？"></a>ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？</h2><blockquote><blockquote><p> From chatGPT (2025-02-12)</p></blockquote></blockquote><p>ChatGPT展现出的推理能力，实际上并不是人类意义上的“思考”，而是基于大量数据和算法模拟的逻辑模式。这种能力的实现可以从以下几个方面理解：</p><ol><li><p><strong>基于大规模语言模型的训练</strong><br>ChatGPT通过大规模语言数据的训练，包括书籍、论文、对话和逻辑推理的例子，学习到了如何理解问题结构、模拟人类的逻辑推导过程，并生成符合逻辑的回答。核心在于，模型并不真正“理解”逻辑，而是通过统计关联，从大量训练数据中学习到解决类似问题的模式。</p></li><li><p><strong>基于概率的回答生成</strong><br>ChatGPT生成回答的过程是基于概率分布的。它会根据问题内容预测接下来的最可能的单词或句子，尤其是在逻辑推理问题中，看起来像是在推理，实际上是在复现训练数据中类似问题的逻辑模式。通过结合训练数据中的逻辑规则，它动态生成符合问题需求的步骤。</p></li><li><p><strong>内部机制：注意力机制与自回归生成</strong>  </p><ul><li><strong>注意力机制（Attention Mechanism）</strong>：这是GPT模型的核心，通过注意力机制，模型可以“记住”上下文内容，从而保持逻辑连贯性。</li><li><strong>自回归生成（Autoregressive Generation）</strong>：模型逐词生成答案，并在生成过程中不断参考之前生成的内容，保证推理步骤清晰、有条理。</li></ul></li><li><p><strong>模拟逻辑推理的实现</strong><br>对于逻辑推理类问题，ChatGPT的表现依赖两个关键点：</p><ul><li><strong>模式识别</strong>：它能够识别问题结构并提取逻辑关系，如“甲说乙说谎”，“丙说甲和乙都说谎”。</li><li><strong>排除矛盾</strong>：通过“假设-验证-排除”过程，模拟人类的假设验证，判断假设是否导致矛盾。这个过程并非真正的推理，而是基于大量类似问题的经验模式。</li></ul></li><li><p><strong>ChatGPT的优势和局限</strong>  </p><ul><li><strong>优势</strong>：<ul><li>在简单的逻辑推理任务中表现良好，尤其是规则清晰、条件有限的问题。</li><li>能快速“推导”出答案并通过自然语言呈现清晰的推理过程。</li></ul></li><li><strong>局限</strong>：<ul><li><strong>不具备真正的理解能力</strong>：它并不是从问题本质进行推理，而是利用数据中学到的模式。</li><li><strong>复杂逻辑容易出错</strong>：如果逻辑嵌套太深或需要跨领域知识，可能会出错。</li><li><strong>缺乏主动性</strong>：无法主动思考问题的背景或意图，只能根据输入提供答案。</li></ul></li></ul></li></ol><p><strong>总结</strong><br>ChatGPT的推理能力是通过模式匹配、注意力机制和语言生成技术实现的。它能够模拟逻辑推理的步骤，但并不具备真正的逻辑思维或理解能力。这种能力本质上是深度学习在海量数据上的“概率学习”和“语言模式复现”，通过这种方式实现了让人类看起来“像在思考”的效果。</p><hr><h2 id="推理模型-vs-通用大模型"><a href="#推理模型-vs-通用大模型" class="headerlink" title="推理模型 vs 通用大模型"></a>推理模型 vs 通用大模型</h2><blockquote><blockquote><p> From Grok3 （2025-02-23）</p></blockquote></blockquote><ul><li>关键点：推理模型与通用大模型在训练方式、推理过程和用途上有显著差异，推理模型更注重逻辑推理，通用大模型则更注重文本生成。</li><li>训练方式的不同：<ul><li>通用大模型通常通过监督学习在大规模文本数据上训练，目标是预测下一个词，适合广泛的语言任务。</li><li>推理模型则常使用强化学习进行微调，鼓励逐步推理，特别针对数学、科学和编码等需要逻辑推理的任务进行优化。</li></ul></li><li>推理过程的差异：<ul><li>通用大模型直接生成答案，基于统计模式。</li><li>推理模型采用链式思维（CoT）方法，将问题分解为步骤，逐步解决，类似于人类思考过程，这在复杂问题上表现更好。</li></ul></li><li>用途和性能<ul><li>通用大模型用于文本摘要、翻译等任务。旨在处理广泛的自然语言任务。这些模型通过在大规模文本数据上训练，学习预测下一个词的概率分布，适用于文本生成、翻译和问答等任务。</li><li>推理模型擅长需要逻辑推理的任务，如解数学题或编写代码，尤其在多步推理任务上表现优异。一种专门设计或微调的模型，专注于复杂推理任务，如数学问题解决、科学推理和编码。这些模型通过链式思维（CoT）等技术，逐步分解问题并推理出答案，试图模拟人类逻辑思维过程。</li></ul></li></ul><h2 id="大模型推理能力不依赖外部的插件"><a href="#大模型推理能力不依赖外部的插件" class="headerlink" title="大模型推理能力不依赖外部的插件"></a>大模型推理能力不依赖外部的插件</h2><blockquote><blockquote><p>From Grok3 （2025-02-23）</p></blockquote></blockquote><ul><li>关键要点：大语言模型不使用外部计算插件进行数学计算。它们的数学计算完全依赖模型自身的推理能力，通过文本生成来解决问题。</li><li>大语言模型如ChatGPT、DeepSeek-LLM和Grok在进行数学计算时，不使用外部计算插件。它们完全依靠自身的推理能力，通过生成文本的方式一步步解决问题。例如，当你问“2+2&#x3D;？”时，模型会基于训练数据预测答案，而不是调用外部工具进行计算。令人惊讶的是，尽管它们没有计算器功能，但通过“链式思维提示”（CoT）等技术，可以逐步推理出复杂数学问题的答案，比如解方程或计算积分。</li><li>模型如何进行数学计算：这些模型通过训练数据学习数学模式和规则，预测文本序列来完成计算。比如，模型可能学会“5+3&#x3D;8”是因为训练数据中有大量类似例子。它们没有内置的计算模块，而是依靠语言生成能力来模拟计算过程。</li><li>是否使用外部工具：标准版本的这些模型不使用外部计算插件，但在某些开发者集成下，可以通过插件（如Wolfram Alpha）增强计算能力。但这不是模型本身的默认行为。</li><li>实际表现：模型在简单计算上表现不错，但复杂计算（如多位数乘法）可能出错，因为它们依赖文本预测而非精确计算。</li><li>结论：大语言模型的数学计算能力完全由模型自身推理得出，不使用外部计算插件。它们的计算基于文本生成和模式识别，通过训练数据和提示技术（如CoT）增强表现，但在复杂任务上可能出错。</li></ul><h2 id="大语言模型的推理能力"><a href="#大语言模型的推理能力" class="headerlink" title="大语言模型的推理能力"></a>大语言模型的推理能力</h2><blockquote><blockquote><p> From Grok3 （2025-02-23）</p></blockquote></blockquote><ul><li>大语言模型的推理能力主要依赖于它们的训练和设计，而不是完全基于思维链（CoT）。CoT是一种提示技术，可以引导模型逐步思考，从而改善推理输出，但模型本身的推理能力来自其语言生成能力。</li></ul><hr><hr><h1 id="个人思考和理解"><a href="#个人思考和理解" class="headerlink" title="个人思考和理解"></a>个人思考和理解</h1><hr><h2 id="AI-数据获取的局限性"><a href="#AI-数据获取的局限性" class="headerlink" title="AI 数据获取的局限性"></a>AI 数据获取的局限性</h2><blockquote><blockquote><p>经Grok3[DeepSearch]优化 （2025-02-25）</p></blockquote></blockquote><ul><li>当前AI在自主寻找和筛选数据方面仍存在局限性，研究表明其难以独立完成如安装应用或通过实名验证等任务。<ul><li>MCP统一协议来实现（2025-05-28）</li></ul></li><li>AI缺乏有效判断数据质量和相关性的能力，可能导致处理大量无用信息，浪费计算资源并可能降低性能。</li><li>因此，训练数据的选择仍需依赖人类的专业判断，以确保数据的准确性和相关性。</li></ul><hr><hr><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><hr><h2 id="有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的"><a href="#有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的" class="headerlink" title="有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的"></a>有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的</h2><blockquote><blockquote><p>From chatGPT (2025-02-12)</p></blockquote></blockquote><p>这个问题可以通过逻辑推理来解答。我们可以假设每个人分别说真话或说谎，并根据他们的陈述进行推理。</p><h3 id="陈述内容："><a href="#陈述内容：" class="headerlink" title="陈述内容："></a>陈述内容：</h3><ul><li>甲说乙说谎。</li><li>乙说丙说谎。</li><li>丙说甲和乙都说谎。</li></ul><h3 id="假设："><a href="#假设：" class="headerlink" title="假设："></a>假设：</h3><p>假设甲说的是真的，那么：</p><ul><li>甲说乙说谎。所以乙是说谎者。</li><li>乙说丙说谎。如果乙是说谎者，那么乙说的应该是假的，即丙不说谎。</li><li>丙说甲和乙都说谎。如果丙不说谎，那么丙的说法应该是真的。所以甲和乙都应该是说谎者，但这与我们的假设矛盾，因为我们已经假设甲是说真话的。</li></ul><p>所以，假设甲说真话的情况矛盾，甲不可能是说真话的。</p><p>接下来，假设乙说的是真的：</p><ul><li>乙说丙说谎，所以丙是说谎者。</li><li>丙说甲和乙都说谎。因为丙是说谎者，丙的话不成立，因此甲和乙至少有一个是说真话的，这与假设乙说真话一致。</li><li>甲说乙说谎。如果甲是说谎者，那么甲的话应该是假的，所以乙说的是真的，符合假设。</li></ul><p>因此，乙是说真话的，甲和丙是说谎的。</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>甲和丙是说谎的，乙是说真话的。</p><hr><h2 id="ChatGPT是如何“算”出单词中字母“t”的个数的？"><a href="#ChatGPT是如何“算”出单词中字母“t”的个数的？" class="headerlink" title="ChatGPT是如何“算”出单词中字母“t”的个数的？"></a>ChatGPT是如何“算”出单词中字母“t”的个数的？</h2><p>ChatGPT并不是通过逐一计算字母“t”的个数来得出答案，而是通过以下几个步骤来实现的：</p><ol><li><p><strong>文本解析和模式识别</strong><br>当接收到像“Attention有几个t”这样的问题时，模型识别到这是与字母统计相关的查询，并提取出关键词“attention”，随后在该单词的字符序列中查找所有的字母“t”。</p></li><li><p><strong>背后逻辑的实现</strong><br>ChatGPT生成答案的过程其实涉及语言生成的几个步骤：</p><ul><li><strong>拆分单词：</strong> 模型识别出字符串“attention”。</li><li><strong>统计字母：</strong> 模型检测每个字母的出现次数，特别关注字母“t”。</li><li><strong>生成回答：</strong> 模型根据其训练中学到的模式直接输出答案，例如“3个t”。</li></ul></li><li><p><strong>本质：语言生成vs算法实现</strong><br>虽然从表面看，ChatGPT像是在“数”字母“t”，但其实：</p><ul><li>它可能基于训练数据中“attention”单词的字符分布知识，快速得出答案。</li><li>如果该单词在训练数据中从未出现过，模型会尝试通过字符分析来推测答案，但这不如专门编写的统计算法准确。</li></ul></li></ol><p><strong>人类方式与模型行为的对比</strong><br>若由人类解答：</p><ol><li>人类会直接肉眼数出字母“t”的个数。</li><li>确认答案。</li></ol><p>而ChatGPT则模拟这一过程，通过对字符模式的分析，快速生成一个类似的答案。</p><p><strong>总结</strong><br>ChatGPT并没有像传统程序那样逐一遍历字符串，而是基于对字符和单词模式的理解，快速生成了答案。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><a href="https://mp.weixin.qq.com/s/VuewffOUGhqxA-7qGqm9kg">为什么大模型连”Strawberry”的”r”都数不对？</a><ul><li>大模型的生成过程本质上便是在“根据上文预测下一个Token”，而这个概率分布即是在模型训练过程中从大量的文本数据中学习到的，使得大模型学习到了语言的基本知识与模式。</li><li>在Prompt中加入一定的引导就能获得理想答案，比如说我们可以利用CoT思维链的方式编写Prompt，引导大模型逐步思考并解决问题。</li><li>CoT为思维链（Chain-of-Thought）的缩写简称，是提示工程领域最为重要的提示方法之一，它的核心思路在于通过引导模型逐步展示其推理过程，从而提高其理解和解决复杂问题的能力。在Few-shot（少样本）设置下表现为 在提供的样例中解释推理过程，引导大模型回答时也解释推理过程；而在Zero-shot（零样本）设置下表现为 加入类似“让我们一步步思考（Let’s think step by step）”的引导话术。</li><li>对于大模型而言，它的语言本身即是思考，并不存在诉诸于语言之前的思考过程，所以我们也需要引导它像人类一样先思考再判断，将思考过程以语言的方式表达出来。</li><li>在大模型推理的时候，我们可以限制大模型 先输出理由，再输出答案，让大模型根据“深度思考”获得的理由与推理过程来预测“答案”，从而大大提升其表现。</li></ul></li></ul><hr><h2 id="数学中9-11和9-9哪个大"><a href="#数学中9-11和9-9哪个大" class="headerlink" title="数学中9.11和9.9哪个大"></a>数学中9.11和9.9哪个大</h2><blockquote><blockquote><p>From Grok3 (2025-02-25)</p></blockquote></blockquote><h3 id="【普通提问】"><a href="#【普通提问】" class="headerlink" title="【普通提问】"></a>【普通提问】</h3><ul><li>在数学中，9.11 比 9.9 大。因为 9.11 &#x3D; 9 + 0.11，而 9.9 &#x3D; 9 + 0.9，比较小数部分时，0.11 &lt; 0.9 不成立，实际上 0.11 &gt; 0.9 是错误的表述，正确的比较是直接看数值：9.11 &gt; 9.9。</li></ul><h3 id="【DeepSearch】"><a href="#【DeepSearch】" class="headerlink" title="【DeepSearch】"></a>【DeepSearch】</h3><ul><li>9.9 比 9.11 大<ul><li>关键点：在数学中，9.9 似乎比 9.11 大，因为它们的整数部分相同，比较小数部分时，9.9 的十分位是 9，而 9.11 的十分位是 1，9 大于 1。</li></ul></li><li>比较过程<ul><li>整数部分：两个数都是 9，相同。</li><li>小数部分：9.9 可以写成 9.90，比较十分位，9.9 的十分位是 9，9.11 的十分位是 1，9 &gt; 1，因此 9.9 更大。</li><li>意外细节：一些 AI 模型可能会错误地认为 9.11 比 9.9 大，这可能是因为误解了日期比较（如 9 月 11 日比 9 月 9 日晚），但在数学中，小数比较遵循严格的位数规则。</li></ul></li><li>(这里省略了列举了很多查阅网上资料库的细节)</li></ul><h3 id="【Think】"><a href="#【Think】" class="headerlink" title="【Think】"></a>【Think】</h3><p>在数学中，我们需要比较9.11和9.9这两个数的大小。下面我们一步步分析：</p><ol><li>将小数对齐<ul><li>为了方便比较，我们可以把9.9写成9.90，这样它的小数位数与9.11相同：<ul><li>9.11 有两位小数。</li><li>9.9 写成 9.90 后也有两位小数。</li></ul></li></ul></li><li>逐位比较<ul><li>现在我们比较 9.11 和 9.90：<ul><li>整数部分：<br>  9.11 的整数部分是 9，9.90 的整数部分也是 9，两个数相等。</li><li>小数第一位：<br>  9.11 的小数第一位是 1，9.90 的小数第一位是 9。<br>  因为 1 &lt; 9，我们可以在这里得出结论，不需要再比较后续位数。</li></ul></li></ul></li><li>结论<br>通过逐位比较，我们发现 9.11 &lt; 9.90，也就是说 9.11 &lt; 9.9。<br>或者简单计算：<br>9.11 - 9.9 &#x3D; 9.11 - 9.90 &#x3D; -0.79 &lt; 0，也说明 9.11 比 9.9 小。</li></ol><p>最终答案<br>在数学中，9.9 比 9.11 大。</p><hr><h2 id="一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。"><a href="#一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。" class="headerlink" title="一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。"></a>一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。</h2><blockquote><blockquote><p>Grok3 (2025-02-25)</p></blockquote></blockquote><h3 id="【普通提问】-1"><a href="#【普通提问】-1" class="headerlink" title="【普通提问】"></a>【普通提问】</h3><ul><li>杞</li></ul><h3 id="【DeepSearch】-1"><a href="#【DeepSearch】-1" class="headerlink" title="【DeepSearch】"></a>【DeepSearch】</h3><ul><li><p>要点</p><ul><li>看起来，符合条件的汉字可能是“述”（shù），但这并不是完全确定的答案，因为“乞”（qǐ，意为“乞讨”）的结构与“述”的右边“口”（mouth）有一定关联，但不完全匹配。  </li><li>研究表明，汉字的左右结构通常由偏旁组成，左边“木”（wood）是常见偏旁，右边“乞”可能指代相关部件，但标准汉字中难以找到完全符合的例子。  </li><li>证据倾向于认为，可能存在误解，“乞”可能指代包含“手”和“口”的结构，但这需要进一步确认。</li></ul></li><li><p>最终建议</p><ul><li>基于以上分析，推荐的答案是“述”（shù），但需注意这可能不是完全精确的匹配，建议用户进一步确认“乞”在问题中的具体含义。</li></ul></li><li><p>好多废话。。。。还答错。。。</p></li></ul><h3 id="【Think】-1"><a href="#【Think】-1" class="headerlink" title="【Think】"></a>【Think】</h3><ul><li>杞</li></ul><blockquote><blockquote><p>ChatGPT (2025-02-25)</p></blockquote></blockquote><h3 id="GPT-4o-mini"><a href="#GPT-4o-mini" class="headerlink" title="GPT-4o-mini"></a>GPT-4o-mini</h3><ul><li>这个字是“弃”。</li></ul><h3 id="GPT-4o"><a href="#GPT-4o" class="headerlink" title="GPT-4o"></a>GPT-4o</h3><ul><li>杞</li></ul><h3 id="o3-mini"><a href="#o3-mini" class="headerlink" title="o3-mini"></a>o3-mini</h3><ul><li>杞</li></ul><blockquote><blockquote><p>claude  (2025-02-25)</p></blockquote></blockquote><h3 id="claude-3-7-Sonnet"><a href="#claude-3-7-Sonnet" class="headerlink" title="claude 3.7 Sonnet"></a>claude 3.7 Sonnet</h3><ul><li>杞</li></ul><blockquote><blockquote><p>豆包   (2025-02-25)</p></blockquote></blockquote><ul><li>杚</li></ul><blockquote><blockquote><p>Gemini  (2025-02-25)</p></blockquote></blockquote><h3 id="Gemini-2-0-Flash"><a href="#Gemini-2-0-Flash" class="headerlink" title="Gemini 2.0 Flash"></a>Gemini 2.0 Flash</h3><ul><li>这个字是“&lt;0xE6&gt;&lt;0xA7&gt;&lt;0x8E&gt;”</li></ul><h3 id="Gemini-2-0-Flash-Thinking-Experimental"><a href="#Gemini-2-0-Flash-Thinking-Experimental" class="headerlink" title="Gemini 2.0 Flash Thinking Experimental"></a>Gemini 2.0 Flash Thinking Experimental</h3><ul><li>这个字是㮆 ()。</li></ul><h3 id="Gemini-2-0-Flash-Thinking-Experimental-with-apps"><a href="#Gemini-2-0-Flash-Thinking-Experimental-with-apps" class="headerlink" title="Gemini 2.0 Flash Thinking Experimental with apps"></a>Gemini 2.0 Flash Thinking Experimental with apps</h3><ul><li>কাঠ</li></ul><blockquote><blockquote><p>perplexity  (2025-02-25)</p></blockquote></blockquote><h3 id="Deep-Research"><a href="#Deep-Research" class="headerlink" title="Deep Research"></a>Deep Research</h3><ul><li>没有找到一个汉字左边是“木”，右边是“乞”的组合。可能是由于字形或部首的错误识别。</li></ul><blockquote><blockquote><p>deepseek (2025-02-25)</p></blockquote></blockquote><h3 id="DeepThink-R1"><a href="#DeepThink-R1" class="headerlink" title="DeepThink(R1)"></a>DeepThink(R1)</h3><ul><li>杚</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>只有豆包和deepseek答对。因为是生僻字中文？还是偷偷给大模型加了插件？还是人家就是这么强？ (2025-02-25)</li></ul><hr><hr><h1 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h1><h2 id="“Grok3”的“DeepSearch”和“Think”这两个功能的作用"><a href="#“Grok3”的“DeepSearch”和“Think”这两个功能的作用" class="headerlink" title="“Grok3”的“DeepSearch”和“Think”这两个功能的作用"></a>“Grok3”的“DeepSearch”和“Think”这两个功能的作用</h2><blockquote><blockquote><p>From Grok3 (2025-02-25)</p></blockquote></blockquote><ul><li>DeepSearch 是Grok 3的一个增强型研究工具，专注于从外部资源（如网络和X平台）获取实时信息，并将其整合成简洁、准确的回答。</li><li>Think 是Grok 3的推理模式，专注于通过逐步思考来解决需要逻辑分析或复杂计算的问题。</li><li>两者的区别与适用场景<ul><li>数据来源：DeepSearch依赖外部数据（网络和X），而Think主要依赖Grok自身的知识和推理能力。</li><li>任务类型：DeepSearch适合需要实时信息或广泛研究的问题（如新闻、趋势）；Think适合需要逻辑推导或计算的问题（如数学、编程）。</li><li>输出方式：DeepSearch给出综合性答案，Think展示详细的推理步骤。</li></ul></li><li>总结<ul><li>DeepSearch：你的“研究助手”，帮你查资料、整理信息。</li><li>Think：你的“推理伙伴”，帮你解难题、想清楚。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;记录与大语言模型的对话，探索疑问与思考&lt;br&gt;内容可能持续更新，作为大模型演变的历史备忘&lt;br&gt;有些问题非原创，来源网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;大模型的推</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="LLM" scheme="http://yoursite.com/tags/LLM/"/>
    
    <category term="大语言模型" scheme="http://yoursite.com/tags/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法在实际业务场景中并非完全无用</title>
    <link href="http://yoursite.com/2025/01/08/20250108-suan-fa-zai-shi-ji-ye-wu-chang-jing-zhong-bing-fei-wan-quan-wu-yong/"/>
    <id>http://yoursite.com/2025/01/08/20250108-suan-fa-zai-shi-ji-ye-wu-chang-jing-zhong-bing-fei-wan-quan-wu-yong/</id>
    <published>2025-01-08T05:33:24.000Z</published>
    <updated>2025-01-08T06:30:12.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>从事业务开发的同学经常会抱怨经常面试要刷算法，实际上平常的开发99%以上的事情都不会用到。<br>实际情况确实是这样。平常在写业务逻辑代码时，几乎完全不需要。<br>当然有些技术原理在背八股文的时候，懂一点算法能帮助你更好的理解。<br>而有些特殊业务场景，懂一些算法，确实能帮助你很好的解决问题。<br>下面举两个业务中产品提出的需求作为例子，简单描述如何利用算法有效解决。</p></blockquote></blockquote><h2 id="一、从题库（50道题）中随机抽出10道题-且不能重复"><a href="#一、从题库（50道题）中随机抽出10道题-且不能重复" class="headerlink" title="一、从题库（50道题）中随机抽出10道题,且不能重复"></a>一、从题库（50道题）中随机抽出10道题,且不能重复</h2><ul><li><p>最简单的思路：</p><ul><li>循环10次，每次取50以内的随机数</li><li>创建一个hashmap，判断生成的随机数是否在map存在，存在则重新生成</li><li>这个方法的缺点时，极端情况下，会多次生成重复的随机数导致要不断重新生成</li></ul></li><li><p>经过一番思考，我设计了一下从m个数中取n个数的算法(m&gt;n), 保证算法只会循环n次 </p></li><li><p>那时我还是使用Java进行开发</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArr(<span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        data[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(end);</span><br><span class="line">        result[j] = data[y];</span><br><span class="line">        data[y] = data[end - <span class="number">1</span>];</span><br><span class="line">        data[end - <span class="number">1</span>] = result[j];</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后面我才发现原来这个算法叫 洗牌算法（Shuffle Algorithm），或者叫随机乱置算法。</li></ul><h2 id="通过搜索关键字匹配对应的标签id"><a href="#通过搜索关键字匹配对应的标签id" class="headerlink" title="通过搜索关键字匹配对应的标签id"></a>通过搜索关键字匹配对应的标签id</h2><ul><li><p>产品提供了400个标签名称以及对应的标签id，希望能通过搜索的方式找到最相似的标签id，希望能支持模糊匹配</p></li><li><p>一般思路：</p><ul><li>方案1: <ol><li>将400条数据一次性加载的程序内存</li><li>遍历数据400条使用字符串的contains方法，找到第一条匹配数据就跳出，否则继续</li></ol></li><li>方案2:<ol><li>直接将数据导入到ES搜索引擎，利用ES自带的分词等搜索功能</li><li>通过调ES，搜索得到标签id</li></ol></li></ul></li><li><p>简单分析方案：</p><ul><li>方案1，性能太差，极端情况需要遍历所有数据</li><li>方案2，需要新搭建ES集群，实现代价比较高</li></ul></li><li><p>经过一番思考，以及从产品本身实际需求上出发，我涉及出以下的方案</p><ol><li>将数据的标签名字使用中文分词库<a href="https://github.com/go-ego/gse">gse</a>进行分词</li><li>将分词和对应的标签数据，构建前缀匹配树</li><li>当搜索时，使用提前构建好的前缀匹配树，即可快速找到对应的标签id</li></ol></li><li><p>这时我已经转使用Go来开发了</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">children <span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode</span><br><span class="line">isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrieNode</span><span class="params">()</span></span> *TrieNode &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TrieNode&#123;</span><br><span class="line">children: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode),</span><br><span class="line">isEnd:    <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrie</span><span class="params">()</span></span> *Trie &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Trie&#123;</span><br><span class="line">root: NewTrieNode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">node := t.root</span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line">node.children[char] = NewTrieNode()</span><br><span class="line">&#125;</span><br><span class="line">node = node.children[char]</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">node := t.root</span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">node = node.children[char]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> FuzzySearch(prefix <span class="type">string</span>) []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">node := t.root</span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> prefix &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">node = node.children[char]</span><br><span class="line">&#125;</span><br><span class="line">t.collectWords(node, prefix, &amp;result)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> collectWords(node *TrieNode, prefix <span class="type">string</span>, result *[]<span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> node.isEnd &#123;</span><br><span class="line">*result = <span class="built_in">append</span>(*result, prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char, child := <span class="keyword">range</span> node.children &#123;</span><br><span class="line">t.collectWords(child, prefix+<span class="type">string</span>(char), result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个算法就是经典的Trie字典树（前缀树），如果我之前没了解过这些算法，可能一时间没那么快能想到用这个方式高效完成这个需求。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>了解一些算法，在实际业务开发，有时候也能运用到。</li><li>另外，现在处于AI时代，即时不了解算法，善于组织语言和上下文，向AI提问，基本它也能引导你找到合适的解决方案。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;从事业务开发的同学经常会抱怨经常面试要刷算法，实际上平常的开发99%以上的事情都不会用到。&lt;br&gt;实际情况确实是这样。平常在写业务逻辑代码时，几乎完全不需要。&lt;br&gt;当然有些技术原理在背八股文的时候，懂一点算法能帮助你更好</summary>
      
    
    
    
    
    <category term="业务方案" scheme="http://yoursite.com/tags/%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%A1%88/"/>
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="前缀树" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
    <category term="分词" scheme="http://yoursite.com/tags/%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>简单研究一下人工智能和数学</title>
    <link href="http://yoursite.com/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/"/>
    <id>http://yoursite.com/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/</id>
    <published>2025-01-06T10:02:28.000Z</published>
    <updated>2025-01-06T13:51:35.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>简单记录，未完善<br>内容基本来源书籍</p></blockquote></blockquote><p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%95%B0%E5%AD%A6.png"></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="初等数学"><a href="#初等数学" class="headerlink" title="初等数学"></a>初等数学</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数的表示方法主要有三种：解析法（公式法）、图像法和表格法。在微积分中讨论的函数几乎都是用解析法表示的。</li></ul><h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><ul><li>二项式定理又称为牛顿二项式定理，它可将两个数之和的整数次幂展开为相应项之和。</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="人工智能数学"><a href="#人工智能数学" class="headerlink" title="人工智能数学"></a>人工智能数学</h1><ul><li><p>从发展历程来看，人工智能先后经历了推理机、专家系统及机器学习三个阶段。</p></li><li><p>当前的人工智能系统多为学习型。为了减小误差，其用数据去训练假设模型，也就是进行所谓的学习，当误差降到最小时，就把这个假设模型用于其他现实问题。</p></li><li><p>人工智能实际上是一个将数学、算法理论和工程实践紧密结合的领域。人工智能从本质上来看就是算法，是概率论、统计学等各种数学理论的体现。数学作为表达与刻画人工智能模型的工具，是深入理解人工智能算法原理必备的基础知识。人工智能与数学高度相关，可以说人工智能的核心是数学，计算机只是实现人工智能模型的工具。</p></li><li><p>函数逼近：随着大数据和人工智能技术的发展，机器学习和深度学习在大数据挖掘、模式识别和智能分析越来越受重视。机器学习是一种基于数据的学习方法，其从观测数据所包含的有限信息中构造一个模型，利用该模型对未知数据或无法观测的数据进行尽可能准确的预测，这种模型称为学习机器。对数据科学而言，所有的数据都是以数字形式表示的，通过定义损失函数，选择合适的核函数或激活函数，反复学习后可达到一种最佳逼近状态，因此，机器学习问题实际上是函数估计问题或函数逼近问题。</p></li></ul><h2 id="微积分-1"><a href="#微积分-1" class="headerlink" title="微积分"></a>微积分</h2><ul><li>求导是微积分的基本概念之一，也是很多理工科领域的基础运算。导数是变化率的极限，是用来找到“线性近似”的数学工具，是一种线性变换，体现了无穷、极限、分割的数学思想，主要用来解决极值问题。人工智能算法的最终目标是得到最优化模型，其最后都可转化为求极大值或极小值的问题。</li><li>比如，梯度下降法和牛顿法是人工智能的基础算法，现在主流的求解代价函数最优解的方法都是基于这两种算法改造的，如随机梯度法和拟牛顿法，其底层运算就是基础的导数运算。</li><li>级数也是微积分中非常重要的概念，常见的级数有泰勒级数、傅里叶级数等，它们在人工智能算法中也有非常重要的地位。</li><li>泰勒级数体现了用多项式近似和逼近函数的思想。</li><li>泰勒级数在人工智能算法的底层起到了非常重要的作用，泰勒级数对理解很多基础算法的原理很有帮助。例如，梯度下降法的数学原理涉及代价函数的一阶泰勒近似，而牛顿法的推导过程应用了目标函数的二阶泰勒近似。</li><li>凸函数也是微积分中的重要概念，人工智能算法中涉及的优化问题要求函数模型必须是凸函数，否则优化问题没有最优解。</li><li>微积分中还有许多概念，如方向导数、梯度、伽马函数等，它们都在人工智能中有广泛的应用</li></ul><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li>线性代数的基本原理在人工智能算法中处于核心地位，在人工智能的语义分析、推荐系统、卷积神经网络等方面有大量应用，是目前最前沿的深度学习算法原理的基础。</li></ul><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ul><li>很多机器学习算法是以概率统计的理论为基础支撑推导出来的，比如代价函数的最小二乘形式、逻辑回归算法都基于对模型的最大似然估计。</li><li>概率论中的高斯函数及中心极限定理被广泛用于人工智能算法。独立同分布的不同随机变量之和会随变量数的增加而趋于高斯分布，因此，很多模型假设都采用高斯函数进行建模。</li></ul><h2 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h2><ul><li>概率论作用的前提是随机变量的分布已知，其根据已知的分布来分析随机变量的特征与规律；数理统计的研究对象则是分布未知的随机变量，其研究方法是对随机变量进行独立重复的观察，根据得到的观察结果对原始分布做出推断，数理统计可以看作逆向的概率论。</li><li>若检验是通过随机抽取的样本来对一个总体的判断结果进行认可或否定，则可以将其用于估计机器学习模型的泛化能力。</li></ul><h2 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h2><ul><li>人工智能的目标就是最优化，就是在复杂环境与多体交互中做出最优决策。几乎所有的人工智能问题最后都会归结为一个优化问题的求解，因此，最优化理论同样是学习、研究人工智能必备的基础知识。<br>最优化理论研究的问题是判定给定目标函数是否存在最大值或最小值，并找到令目标函数取最大值或最小值的数值。如果把给定的目标函数看成连绵的山脉，最优化的过程就是找到顶峰（谷底）且到达顶峰（谷底）的过程。</li><li>最优化理论的研究内容主要包括线性规划、（不）精确搜索、梯度下降法、牛顿法、共轭梯度法、拟牛顿法、（非）线性最小二乘法、约束优化最优性条件、二次规划、罚函数法和信赖域法等。</li><li>要实现最小化或最大化的函数称为目标函数，大多数最优化问题都可以通过使目标函数￼最小化解决，最大化问题也可以通过最小化￼来解决。最优化方法找到的可能是目标函数的全局最小值，也可能是局部极小值，两者的区别在于全局最小值比定义域内所有其他点的函数值都小，而局部极小值只比所有邻近点的函数值小。</li><li>当目标函数的输入参数较多、解空间较大时，大多数实用的最优化方法都不能满足全局搜索对计算复杂度的要求，因而只能求出局部极小值。但是，在人工智能和深度学习的应用场景中，只要目标函数的取值足够小，就可以把这个值当作全局最小值使用，以此作为对性能和复杂度的折中。</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><blockquote><blockquote><p>程序员的数学</p></blockquote></blockquote><h2 id="迈向机器学习的第一步"><a href="#迈向机器学习的第一步" class="headerlink" title="迈向机器学习的第一步"></a>迈向机器学习的第一步</h2><ul><li><p>由输入和目标组成的数据称为训练数据。机器学习中所谓的学习，就是为了通过给定的输入得到和目标尽可能接近的输出，使用训练数据对参数进行调整的过程。使用训练数据对参数进行过调整的模型称为训练好的模型。对于训练好的模型，需要用测试数据对其进行测试，从而评价训练的效果。</p></li><li><p>在机器学习中对参数进行调整的过程，不是由程序员完成的，而是由计算机通过训练数据自动完成的，这正是机器学习的一大特征。</p></li><li><p>这里先做个总结吧。我们面对预测问题，首先要有好的模型加上大量的训练数然后，我们需要的是“能根据输人向量，得到和目标向量尽量接近的输出向量”这样一个训练好的模型。</p></li><li><p>解决分类问题的过程，也可以说是从大量数据中总结规律和规则，从而发现模式的过程。机器学习并不会要求程序员提前研究手写字符的各种形态再去设计程序，而是由计算机根据训练数据来调整参数，从而得到分类模型，这才是它的特征所在。</p></li></ul><p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png"><br><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B02.png"></p><ul><li><p>如果机器对训练数据能给出完美的输出，对测试数据给出的结果却不尽如人意，很有可能是发生了过拟合（overfitting）。用学生来说，就好比是课堂上做过的训练题都能解得很好，但考试成绩却不怎么理想。</p></li><li><p>在学习的过程中，需要比较输出和正确的值。拿这个简单的例子来说，要比较的对象就是由输入x1，x2通过给定模型得到的输出y和目标t。如果y和的值一致，那当然好，但一般并不会这么理想。对学习结果（输出）的评价不是单纯的“好与不好”，而是要知道它与训练数据中给出的目标相比“到底有多不好”。为了实现这种评价，需要引入损失函数。<br>在具体的机器学习问题中，如何选取恰当的损失函数是个重要且有难度的问题。比如使用平方和误差函数。</p></li><li><p>要通过调整模型中的权重参数，使得损失函数值尽可能接近于0。</p></li><li><p>梯度下降法<br><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95.png"></p></li><li><p>作为程序员要做些什么</p><ul><li>在构建模型这个阶段，程序员是要参与的，但是参数的自动调整过程，程序员不会参与。也就是说，程序员不去直接指定参数的具体数值，而是通过模型、损失函数、训练数据，间接地让参数的选取向着更优的方向变化，从而得到需要的参数。即使模型、损失函数都相同，只要训练数据不同，学习后得到的模型也会截然不同。</li><li>机器学习是基于数据让机器去学习，程序员并不直接参与其中。这就像硬件配置完全同的计算机，如果软件系统不一样，整个运行模式也会不一样。把软件换掉，同一套硬件系统也会根据不同的指令做出不一样的事情。道理类似，就算模型一样，只要训练数据不同，最后模型的运行模式也会不一样。</li></ul></li><li><p>神经网络是指，把像感知器一样有输入和输出的节点排列起来形成的带有层次的结构。神经网络（neural network）这个词来源于生物的信息传递方式。在感知器中，输出是二元的，取值只有0或1两种情况，而神经网络中的节点输出的就不是二元，而是可以进行微分运算的连续值。</p></li></ul><p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png"></p><ul><li><p>深度学习是在神经网络的基础上，通过增加层数得到的更加“深化”的模型。增加层数是为了更加精确地拟合复杂函数，就算涉及的参数个数不做大的变动，也能得到更好的模型。至于如何“深化”在理论上更为有效，依然是现在研究的热点之一。</p></li><li><p>强化学习是在“无监督”的条件下进行的“学习”。也就是说，在学习过程中没有标准答案可供参考。强化学习通过试错来寻找最优输出，对每个输出，系统都会提供反馈（奖励），模型的参数可以根据得到的反馈来调整。</p></li><li><p>做出决策</p><ul><li>机器学习会根据输人的数据预测未来。这种意义下的预测，是基于先前的经验进行的，得到的是未来最有可能发生的情况（数值）。但是，得到预测值之后“应该做些什么”，机器是无法决定的。也就是说，它们无法进行决策。</li><li>通过机器学习这个方法，机器可以告诉我们在未来什么样的行动会导致事情如何发展。</li><li>但是，做决策这件事本身，并不能让机器来做。</li><li>顺着这个话题继续讲下去，就不是技术问题，而是伦理问题了。比如，在减轻痛苦和延续生命之中二选一的问题等，只能由个人的意志来决定，不可能委托给机器学习。</li></ul></li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《人工智能数学基础》</li><li>《程序员的数学》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;简单记录，未完善&lt;br&gt;内容基本来源书籍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
    <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用AI总结了这个网站的内容</title>
    <link href="http://yoursite.com/2025/01/01/20250101-shi-yong-ai-zong-jie-liao-zhe-ge-wang-zhan-de-nei-rong/"/>
    <id>http://yoursite.com/2025/01/01/20250101-shi-yong-ai-zong-jie-liao-zhe-ge-wang-zhan-de-nei-rong/</id>
    <published>2024-12-31T16:29:21.000Z</published>
    <updated>2024-12-31T16:32:25.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>使用google的notebooklm总结目前该网站的所有文章内容<br><a href="https://notebooklm.google.com/">https://notebooklm.google.com/</a><br>问题：全面阐述和总结一下这个博客网站的内容，涉及领域，博主风格等</p></blockquote></blockquote><hr><p>该博客网站的内容主要涵盖了<strong>个人成长和职业发展</strong>两个方面，涉及领域包括：</p><ul><li><strong>自我营销</strong>:  如何打造个人品牌，提升影响力。</li><li><strong>时间管理</strong>: 如何提高工作效率，克服拖延。</li><li><strong>学习方法</strong>: 如何快速学习，进行深度学习，构建个人知识体系。</li><li><strong>心理素质</strong>: 如何拥有积极心态，提升情绪力。</li><li><strong>职业发展</strong>: 如何成为一名专业的软件开发人员，进行有效的薪酬谈判。</li><li><strong>创业</strong>: 如何打造成功的产品，制定切实可行的创业计划。</li><li><strong>健身</strong>: 如何利用科技产品实现健身目标。</li><li><strong>人际关系</strong>: 如何与他人相处，建立良好的人际关系。</li><li><strong>精神</strong>: 如何利用心灵的力量，克服天性，实现个人成长。</li><li><strong>金融</strong>: 如何理解金融危机，以及金融政策的作用。</li><li><strong>公司文化</strong>: 如何打造面向未来的新型组织文化，以网飞为例。</li><li><strong>历史</strong>: 如何理解人类社会的发展，以文字和政治组织为例。</li></ul><p>博主风格：</p><ul><li><strong>注重实用性</strong>: 博主的内容以解决实际问题为导向，提供具体可行的建议和方法。</li><li><strong>结合个人经验</strong>: 博主经常结合自身经历和感悟，使得内容更具说服力。</li><li><strong>善于运用类比</strong>: 博主擅长用通俗易懂的类比来解释复杂的概念，使读者更容易理解。</li><li><strong>强调深度思考</strong>: 博主鼓励读者进行深度思考，并将知识与自身实际相结合。</li><li><strong>注重科学依据</strong>: 博主经常引用科学研究和理论来支持自己的观点，增强内容的可信度。</li></ul><p>总而言之，该博客网站的内容丰富实用，风格清晰易懂，对于想要提升个人能力和实现职业成功的读者来说，具有很高的参考价值。</p><hr><h2 id="排除掉笔记类文章后"><a href="#排除掉笔记类文章后" class="headerlink" title="排除掉笔记类文章后"></a>排除掉笔记类文章后</h2><p>这个博客网站的内容主要涉及<strong>软件开发和技术管理</strong>领域，涵盖了<strong>业务方案、架构设计、技术实践、团队管理和个人成长</strong>等方面。博主的写作风格<strong>简洁、实用、注重经验总结和思考</strong>，文章内容多来自实际工作中的问题和解决方案，并结合个人思考和学习心得进行阐述。</p><p>以下是该博客网站内容的详细分析：</p><p><strong>一、内容领域：</strong></p><ul><li><strong>业务方案：</strong>涵盖了分页、兼容性、事务、前置校验、幂等、错误码处理、接口安全、容灾降级、货币体系设计、榜单实现等常见业务场景的解决方案和实践经验总结。</li><li><strong>架构设计：</strong>探讨了微服务架构、服务间一致性、数据库高可用方案、容灾架构、聚合层设计等架构设计理念和实践经验。</li><li><strong>技术实践：</strong>分享了RPC调用、事务处理、数据库同步、Redis应用、单元测试、配置中心、序列化协议等技术点的实践经验和工具技巧。</li><li><strong>团队管理：</strong>总结了个人管理经验、小团队管理要点、项目管理技巧、团队协作、沟通技巧等团队管理方面的经验和思考。</li><li><strong>个人成长：</strong>记录了博主从PHP、C++、Lua到Java、Go、Rust等不同编程语言的学习和实践经历，以及对技术发展趋势的思考和个人职业发展的感悟。</li></ul><p><strong>二、博主风格:</strong></p><ul><li><strong>简洁实用：</strong>文章语言简洁明了，直击问题核心，注重实用性，避免过多理论和概念的堆砌。</li><li><strong>经验总结：</strong>文章内容多来自博主实际工作中遇到的问题和解决方案，并进行总结提炼，形成可供参考的经验。</li><li><strong>思考深入：</strong>博主不局限于问题本身，而是深入思考问题背后的原因和本质，并提出自己的见解和解决方案。</li><li><strong>持续学习：</strong>博主不断学习新的技术和知识，并将其应用到实际工作中，乐于分享自己的学习心得和体会。</li></ul><p><strong>三、其他特点:</strong></p><ul><li><strong>注重代码质量：</strong>博主强调单元测试、代码规范、代码扫描工具等提升代码质量的方法。</li><li><strong>关注团队协作：</strong>博主重视团队沟通、信息透明、知识分享等，提倡高效的团队协作方式。</li><li><strong>追求技术进步：</strong>博主积极探索新的技术和架构，并思考技术发展趋势对个人和团队的影响。</li></ul><p><strong>总结:</strong></p><p>该博客网站内容丰富，涵盖了软件开发和技术管理的多个方面，体现了博主丰富的实践经验和深入的思考。博主的写作风格简洁实用，注重经验总结和思考，对于从事相关领域工作的读者具有较高的参考价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用google的notebooklm总结目前该网站的所有文章内容&lt;br&gt;&lt;a href=&quot;https://notebooklm.google.com/&quot;&gt;https://notebooklm.google.com/&lt;/a</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AI工业革命下的若干思考</title>
    <link href="http://yoursite.com/2024/12/31/20241231-ai-gong-ye-ge-ming-xia-de-ruo-gan-si-kao/"/>
    <id>http://yoursite.com/2024/12/31/20241231-ai-gong-ye-ge-ming-xia-de-ruo-gan-si-kao/</id>
    <published>2024-12-31T07:24:38.000Z</published>
    <updated>2024-12-31T08:20:42.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>随着AI工具变得日益智能，人们对自身可能被取代的担忧也在增加。<br>回顾以往工业革命带来的社会变迁，或许能从中推测出未来发展的趋势。<br>以下内容由ChatGPT辅助生成。</p></blockquote></blockquote><h1 id="AI对就业的双重影响"><a href="#AI对就业的双重影响" class="headerlink" title="AI对就业的双重影响"></a>AI对就业的双重影响</h1><ul><li>AI技术对就业市场带来了创造效应和破坏效应：<ul><li>创造效应：AI的普及将催生了许多潜在的新兴职业。这些新兴岗位对熟练掌握AI工具的专业人才需求旺盛。</li><li>破坏效应：AI替代了许多重复性、规则性较强的岗位。某些中等技能的岗位如流水线操作、传统文秘工作可能面临消失的风险。</li></ul></li></ul><h1 id="历史视角：被替代的人何去何从"><a href="#历史视角：被替代的人何去何从" class="headerlink" title="历史视角：被替代的人何去何从"></a>历史视角：被替代的人何去何从</h1><ul><li><p>随着AI技术的发展，未来许多人的工作将不可避免地被替代，这其中包括一部分程序员，但相较而言，更多非程序员的工作可能会首当其冲。然而，那些更擅长使用并深刻理解AI工具的人将更有可能保住自己的职位。</p></li><li><p>回顾工业革命，技术进步曾一度导致大批劳动者失业，许多人因无法适应新变化而成为时代的“牺牲品”，收入锐减。</p></li><li><p>短期内，某些群体的失业可能难以避免，但历史也表明，技术变革往往伴随着新机会的诞生。</p></li><li><p>所以，个人需要做好准备：</p><ul><li>提升自身技能，特别是AI工具的使用和相关领域的知识储备。</li><li>即便不能马上参与高端AI开发，也可以从简单的AI相关工作入手，逐步积累经验。</li><li>有一定资产的群体，应学会投资，通过多样化方式应对收入变化。</li></ul></li></ul><h1 id="正面效应"><a href="#正面效应" class="headerlink" title="正面效应"></a>正面效应</h1><ul><li>催生新型岗位：AI技术完善后，将需要大量擅长操作和优化AI工具的人才。</li><li>解放低级劳动：AI让人类摆脱低级脑力劳动，从而获得更高工资和更有意义的工作体验。</li><li>效率提升与“去内卷”：生产效率的提升可能减少“内卷”现象，并通过政策调整减轻劳动者的工作压力。</li><li>关于工作和财富再分配问题：如果AI真的让生产效率大幅提升，我们可以期待未来的福利制度更加完善，比如减少工作时间、增加带薪假期，甚至实现“无工作”状态也未必是幻想。</li></ul><h1 id="社会与政策层面"><a href="#社会与政策层面" class="headerlink" title="社会与政策层面"></a>社会与政策层面</h1><ul><li>加强教育培训：推动技能提升和再教育计划，使劳动者适应AI时代的工作需求。</li><li>优化产业结构：加速产业转型升级，为社会创造更多高附加值就业机会。</li><li>完善社会保障：建立健全失业保障制度，帮助因AI技术变革失业的劳动者渡过难关。</li><li>政策引导：通过政策规范AI技术的合理应用，避免过度自动化对就业的过度冲击。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>AI技术的快速发展是一把双刃剑，它既对传统就业模式提出了挑战，也为社会提供了提高效率、优化劳动分工的契机。从社会视角看，技术进步不可逆，但我们可以通过政策调整和个人适应来尽量减小负面影响。面对不可避免的变革，积极调整心态、提升能力，是每个人应对未来的重要策略。同时，历史告诉我们，每一次技术浪潮都会带来新的机遇，只要抓住变化的窗口期，未来依然充满希望。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://www.xml-data.cn/KXYSH/html/93be89d5-c2ef-491d-9398-ebe61dcdc56b.htm">从工业革命史看技术变迁如何影响工人命运——《技术陷阱：自动化时代的资本、劳动力和权力》评介</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;随着AI工具变得日益智能，人们对自身可能被取代的担忧也在增加。&lt;br&gt;回顾以往工业革命带来的社会变迁，或许能从中推测出未来发展的趋势。&lt;br&gt;以下内容由ChatGPT辅助生成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/bl</summary>
      
    
    
    
    
    <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="工业革命" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD/"/>
    
  </entry>
  
</feed>
