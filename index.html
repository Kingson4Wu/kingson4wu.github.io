<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="为啥不吃三文鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="为啥不吃三文鱼">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>拉巴力的纸皮箱</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/17/20250817-jia-ting-kuan-dai-zhong-de-gong-wang-yu-nei-wang-ip-fen-pei-ji-zhi-jie-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/17/20250817-jia-ting-kuan-dai-zhong-de-gong-wang-yu-nei-wang-ip-fen-pei-ji-zhi-jie-xi/" itemprop="url">家庭宽带中的公网与内网 IP 分配机制解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-17T13:10:04+08:00">
                2025-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>以下内容由AI生成</p>
</blockquote>
</blockquote>
<p>在日常使用家庭宽带时，很多人会遇到“到底我家有没有独立公网 IP”的问题。这不仅关系到能否顺利访问外网，更影响到是否可以在家中搭建服务器、使用 P2P 应用等。本文将系统梳理家庭宽带 IP 的分配方式、运营商 NAT 的机制以及其对用户的实际影响。</p>
<hr>
<h2 id="1-家庭宽带的几种典型-IP-分配方式"><a href="#1-家庭宽带的几种典型-IP-分配方式" class="headerlink" title="1. 家庭宽带的几种典型 IP 分配方式"></a>1. 家庭宽带的几种典型 IP 分配方式</h2><h3 id="（1）独立公网-IP"><a href="#（1）独立公网-IP" class="headerlink" title="（1）独立公网 IP"></a>（1）独立公网 IP</h3><ul>
<li>家庭路由器的 <strong>WAN 口直接获取公网 IPv4 地址</strong>（或独立 IPv6 前缀）。</li>
<li>此时家庭就是一个独立的外网节点，可直接与互联网通信（除非被防火墙限制）。</li>
<li><strong>典型场景</strong>：早期 ADSL 宽带、当前部分电信&#x2F;联通&#x2F;移动的 IPv6 分配。</li>
</ul>
<p><strong>优势</strong>：可开放端口、搭建服务器，外网可直接访问家庭设备。</p>
<hr>
<h3 id="（2）共享公网-IP（运营商-NAT-x2F-CGNAT）"><a href="#（2）共享公网-IP（运营商-NAT-x2F-CGNAT）" class="headerlink" title="（2）共享公网 IP（运营商 NAT &#x2F; CGNAT）"></a>（2）共享公网 IP（运营商 NAT &#x2F; CGNAT）</h3><ul>
<li><p>由于 IPv4 地址紧张，很多家庭宽带 WAN 口拿到的并不是公网地址，而是内网地址：</p>
<ul>
<li><code>100.64.x.x</code>（CGNAT 专用）、<code>10.x.x.x</code>、<code>172.16–31.x.x</code>、<code>192.168.x.x</code> 等。</li>
</ul>
</li>
<li><p>运营商在核心网部署 NAT，把成百上千家庭流量映射到同一个公网 IP 上。</p>
</li>
</ul>
<p><strong>特点与问题</strong>：</p>
<ul>
<li>家庭没有独立公网出口，而是和他人“拼”一个公网 IP。</li>
<li><strong>限制</strong>：端口映射困难甚至不可能 → 无法轻易搭建对外服务。</li>
</ul>
<hr>
<h3 id="（3）混合模式（IPv6-公网-IPv4-NAT）"><a href="#（3）混合模式（IPv6-公网-IPv4-NAT）" class="headerlink" title="（3）混合模式（IPv6 公网 + IPv4 NAT）"></a>（3）混合模式（IPv6 公网 + IPv4 NAT）</h3><ul>
<li>家庭可获得独立的 <strong>IPv6 前缀</strong>（相当于独立公网地址）。</li>
<li>IPv4 依旧通过 NAT，共享公网 IP。</li>
<li>这种情况在目前逐渐普及，算是“半独立外网”。</li>
</ul>
<hr>
<h2 id="2-内网与外网的关系"><a href="#2-内网与外网的关系" class="headerlink" title="2. 内网与外网的关系"></a>2. 内网与外网的关系</h2><ul>
<li><strong>LAN 内网 IP</strong>：路由器分配给家庭设备的地址（如 192.168.x.x），可支持上百台设备。</li>
<li><strong>WAN IP</strong>：路由器外网口的地址，可能是真公网，也可能是运营商 NAT 内网（如 100.64.x.x）。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li><p>家庭可分配的内网 IP 数量不受共享公网限制，理论上仍可支持数百设备。</p>
</li>
<li><p>共享公网真正的限制在于：</p>
<ul>
<li>端口映射受阻</li>
<li>P2P 软件连接困难</li>
<li>搭建家庭服务器几乎不可能</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-CGNAT-的工作机制"><a href="#3-CGNAT-的工作机制" class="headerlink" title="3. CGNAT 的工作机制"></a>3. CGNAT 的工作机制</h2><p>CGNAT 的核心是 <strong>端口映射表</strong>。</p>
<ol>
<li>家庭路由器将内网设备请求 NAT 成 <strong>WAN IP + 端口</strong>。</li>
<li>运营商 CGNAT 再将 WAN IP + 端口转换为 <strong>公网 IP + 唯一端口</strong>。</li>
<li>返回数据时，CGNAT 通过映射表查找，精准把数据包发回正确的家庭。</li>
</ol>
<p><strong>要点</strong>：</p>
<ul>
<li>即使不同家庭设备端口相同，CGNAT 会分配不同的公网端口 → 不会冲突。</li>
<li>每个家庭必须有唯一的 WAN IP（即便是私有地址），否则映射表无法区分连接。</li>
</ul>
<hr>
<h2 id="4-特殊地址段：100-64-x-x"><a href="#4-特殊地址段：100-64-x-x" class="headerlink" title="4. 特殊地址段：100.64.x.x"></a>4. 特殊地址段：100.64.x.x</h2><ul>
<li><p><strong>定义</strong>：RFC 6598 规定 <code>100.64.0.0/10</code> 专用于 <strong>运营商级 NAT</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>不是公网 IP（外网无法直达）。</li>
<li>不是家庭 LAN 内网（192.168&#x2F;10.x&#x2F;172.16–31），而是运营商内部“二级内网”。</li>
</ul>
</li>
<li><p><strong>工作方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">家庭设备 192.168.1.2</span><br><span class="line">    ↓ 家庭路由器 NAT</span><br><span class="line">WAN: 100.64.1.2  ← 运营商私有地址</span><br><span class="line">    ↓ 运营商 CGNAT</span><br><span class="line">公网 IP: 1.2.3.4</span><br><span class="line">    ↓ Internet</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>：家庭网络不应使用 100.64.x.x 作为 LAN 地址，否则会和运营商 CGNAT 冲突，导致公网无法访问。</p>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol>
<li><strong>独立公网 IP</strong>：可直接对外通信，最自由。</li>
<li><strong>共享公网 IP（CGNAT）</strong>：常见于 IPv4，无法轻易开放端口，但家庭内网不受影响。</li>
<li><strong>IPv6 普及下的混合模式</strong>：IPv6 独立公网，IPv4 仍共享。</li>
<li><strong>100.64.x.x 是运营商内网地址</strong>，不是公网 IP。</li>
<li><strong>核心差异</strong>：家庭内网数量不受限制，但共享公网时外网访问受阻。</li>
</ol>
<hr>
<p>📌 <strong>一句话总结</strong>：<br>大多数家庭宽带并没有独立公网 IPv4，而是通过 CGNAT 与他人共享出口。要想获得真正独立的公网地址，需要向运营商申请“公网 IP 服务”或使用企业宽带。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/17/20250817-vpn-yu-zheng-xiang-dai-li-de-yuan-li-yu-chai-yi-fen-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/17/20250817-vpn-yu-zheng-xiang-dai-li-de-yuan-li-yu-chai-yi-fen-xi/" itemprop="url">VPN 与正向代理的原理与差异分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-17T12:59:59+08:00">
                2025-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>以下内容由AI生成，本人审阅</p>
</blockquote>
</blockquote>
<h2 id="一、VPN-的基本原理"><a href="#一、VPN-的基本原理" class="headerlink" title="一、VPN 的基本原理"></a>一、VPN 的基本原理</h2><p>**VPN（Virtual Private Network，虚拟专用网络）**的核心思想是在 <strong>公网上（Internet）</strong> 建立一条 <strong>加密隧道</strong>，使用户的数据能够像在同一局域网中一样安全传输。其关键机制包括：</p>
<ol>
<li><p><strong>隧道封装（Tunneling）</strong></p>
<ul>
<li>将原始 IP 包或 TCP&#x2F;UDP 流量再次封装后发送至 VPN 服务器。</li>
<li>VPN 服务器解封装后再转发至目标网站或服务。</li>
<li>常见协议包括 PPTP、L2TP、IPSec、OpenVPN（基于 TLS&#x2F;SSL）、WireGuard 等。</li>
</ul>
</li>
<li><p><strong>数据加密（Encryption）</strong></p>
<ul>
<li>VPN 的核心能力之一就是加密，例如 AES、ChaCha20。</li>
<li>运营商或中间路由器看到的只是加密数据流，而无法识别内容。</li>
</ul>
</li>
<li><p><strong>虚拟网卡（Virtual NIC）</strong></p>
<ul>
<li>客户端安装 VPN 时会创建虚拟网卡。</li>
<li>系统将原始流量交给虚拟网卡，由 VPN 客户端进行加密与封装，再传输至服务器。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="二、正向代理的基本原理"><a href="#二、正向代理的基本原理" class="headerlink" title="二、正向代理的基本原理"></a>二、正向代理的基本原理</h2><p><strong>正向代理（Forward Proxy）</strong> 是一种由客户端主动指定的代理模式：</p>
<ul>
<li>客户端 → <strong>代理服务器</strong> → 目标网站</li>
<li>代理服务器替代客户端访问网站。</li>
</ul>
<p>常见类型包括：</p>
<ul>
<li><strong>HTTP Proxy</strong>：仅代理网页流量。</li>
<li><strong>SOCKS5 Proxy</strong>：支持 TCP&#x2F;UDP，更通用。</li>
</ul>
<p>👉 如果在正向代理的基础上增加加密，就得到 <strong>加密正向代理</strong>，例如：</p>
<ul>
<li><strong>Shadowsocks</strong>（基于 SOCKS5 + 加密）</li>
<li><strong>V2Ray、Trojan</strong>（自定义协议 + 加密）</li>
</ul>
<hr>
<h2 id="三、VPN-与正向代理的关系"><a href="#三、VPN-与正向代理的关系" class="headerlink" title="三、VPN 与正向代理的关系"></a>三、VPN 与正向代理的关系</h2><ol>
<li><p><strong>共性</strong></p>
<ul>
<li>都是正向代理的广义形式，用户请求最终都由中间服务器转发。</li>
<li>都可以实现数据加密、突破访问限制、保护隐私。</li>
</ul>
</li>
<li><p><strong>差异</strong></p>
<ul>
<li><strong>VPN</strong>：工作在 <strong>网络层</strong>，接管整个系统的所有流量，不需要应用单独配置。</li>
<li><strong>加密代理（Shadowsocks&#x2F;V2Ray&#x2F;Trojan 等）</strong>：工作在 <strong>传输层&#x2F;应用层</strong>，更灵活，可以选择性分流。</li>
</ul>
</li>
</ol>
<p>✅ 准确的表述是：</p>
<blockquote>
<p><strong>VPN 是一种在网络层实现的“全流量加密隧道代理”；而机场协议（如 Shadowsocks&#x2F;V2Ray&#x2F;Trojan）是工作在传输层或应用层的“加密正向代理”。</strong></p>
</blockquote>
<hr>
<h2 id="四、为什么“机场代理”常被叫做-VPN"><a href="#四、为什么“机场代理”常被叫做-VPN" class="headerlink" title="四、为什么“机场代理”常被叫做 VPN"></a>四、为什么“机场代理”常被叫做 VPN</h2><ul>
<li>手机或电脑端的 Shadowsocks&#x2F;V2Ray 客户端通常会申请系统的 <strong>VPN 权限（VPNService）</strong>，创建虚拟网卡，将流量导入代理。</li>
<li>在用户体验上，表现为“一键开启，所有流量都出国”，与 VPN 相似。</li>
<li>但协议层面，它们并非传统 VPN，而是 <strong>加密正向代理 + VPN 伪装</strong> 的结合体。</li>
</ul>
<hr>
<h2 id="五、效果、效率与使用体验差异"><a href="#五、效果、效率与使用体验差异" class="headerlink" title="五、效果、效率与使用体验差异"></a>五、效果、效率与使用体验差异</h2><h3 id="1-效果层面"><a href="#1-效果层面" class="headerlink" title="1. 效果层面"></a>1. 效果层面</h3><ul>
<li><strong>VPN</strong>：全流量隧道，统一加密转发。</li>
<li><strong>机场代理</strong>：通过加密代理转发流量，用户体验上几乎无差别。</li>
</ul>
<h3 id="2-效率与性能"><a href="#2-效率与性能" class="headerlink" title="2. 效率与性能"></a>2. 效率与性能</h3><ul>
<li><strong>VPN</strong>：底层封装，效率较高（WireGuard 延迟小、速度快）。</li>
<li><strong>代理</strong>：协议转换可能增加开销，但现代实现已高度优化。</li>
</ul>
<h3 id="3-使用体验"><a href="#3-使用体验" class="headerlink" title="3. 使用体验"></a>3. 使用体验</h3><ul>
<li><strong>VPN</strong>：系统级全局接管，适合企业远程办公、统一管控。</li>
<li><strong>机场代理</strong>：支持灵活分流（国际流量走代理、国内直连），更适合个人日常使用。</li>
</ul>
<hr>
<h2 id="六、典型场景对比"><a href="#六、典型场景对比" class="headerlink" title="六、典型场景对比"></a>六、典型场景对比</h2><ol>
<li><p><strong>公司 VPN</strong></p>
<ul>
<li>常见模式是 <strong>全隧道（Full Tunnel）</strong>，所有流量经由公司出口，安全统一但效率偏低。</li>
<li>有些公司支持 <strong>分隧道（Split Tunnel）</strong>，仅内网走 VPN，外网直连，但安全性存在隐患。</li>
</ul>
</li>
<li><p><strong>机场代理</strong></p>
<ul>
<li>可选择 <strong>全局代理</strong>，模拟 VPN 效果。</li>
<li>或使用 <strong>规则分流</strong>（PAC 模式），国际流量走代理，国内直连，更高效。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul>
<li><strong>VPN</strong>：本质是 <strong>网络层的加密隧道代理</strong>，接管系统所有流量。</li>
<li><strong>机场协议（Shadowsocks、V2Ray、Trojan）</strong>：本质是 <strong>传输层&#x2F;应用层的加密正向代理</strong>，通过虚拟网卡实现“伪装成 VPN”的体验。</li>
<li><strong>共同点</strong>：都加密、都代理、都能突破限制。</li>
<li><strong>差异点</strong>：VPN 更底层、统一接管；机场代理更灵活、支持分流。</li>
</ul>
<p>👉 一句话概括：<br><strong>VPN 与机场协议都是“加密正向代理”，区别只在于工作层级和使用方式。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/17/20250817-shen-ru-li-jie-socks5-zheng-xiang-dai-li-yuan-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/17/20250817-shen-ru-li-jie-socks5-zheng-xiang-dai-li-yuan-li/" itemprop="url">深入理解 SOCKS5 正向代理原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-17T12:54:40+08:00">
                2025-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>以下内容由AI生成，本人审阅</p>
</blockquote>
</blockquote>
<p>在网络代理领域，<strong>SOCKS5</strong> 是一种常用的正向代理协议。它不同于传统的 HTTP 代理，能够为各种应用层协议提供通用的转发支持。本文将从概念、协议机制、工作流程和应用场景几个层次，系统梳理 SOCKS5 的技术原理。</p>
<hr>
<h2 id="1-正向代理的基本概念"><a href="#1-正向代理的基本概念" class="headerlink" title="1. 正向代理的基本概念"></a>1. 正向代理的基本概念</h2><p><strong>正向代理</strong>是指客户端主动使用代理服务器，把请求先发给代理，再由代理去访问目标服务器，并把结果返回客户端。</p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>隐藏客户端真实 IP</li>
<li>绕过访问限制（如内网封锁、跨境访问）</li>
<li>统一出口流量，便于管理和审计</li>
</ul>
<hr>
<h2 id="2-SOCKS-协议简介"><a href="#2-SOCKS-协议简介" class="headerlink" title="2. SOCKS 协议简介"></a>2. SOCKS 协议简介</h2><p><strong>SOCKS (Socket Secure)</strong> 是一种通用的代理协议，不依赖特定的应用层协议。</p>
<ul>
<li><p><strong>SOCKS5</strong> 是该协议的第 5 版，支持更多功能：</p>
<ul>
<li>TCP 与 UDP 转发</li>
<li>用户认证（无认证、用户名&#x2F;密码等）</li>
<li>IPv4 &#x2F; IPv6 &#x2F; 域名解析</li>
</ul>
</li>
</ul>
<p>👉 与 HTTP 代理相比，SOCKS5 并不解析上层应用协议，只做数据字节的透明转发，因此适用范围更广。</p>
<hr>
<h2 id="3-SOCKS5-的工作流程"><a href="#3-SOCKS5-的工作流程" class="headerlink" title="3. SOCKS5 的工作流程"></a>3. SOCKS5 的工作流程</h2><p>假设客户端配置了一个 SOCKS5 代理，整个交互过程如下：</p>
<h3 id="1）客户端与代理握手"><a href="#1）客户端与代理握手" class="headerlink" title="1）客户端与代理握手"></a>1）客户端与代理握手</h3><ul>
<li>客户端告知代理：“我支持哪些认证方式（无认证 &#x2F; 用户名密码 &#x2F; …）”</li>
<li>代理回应：“我要求用某种认证方式”</li>
<li>若需认证，客户端提交凭证，通过后进入下一阶段</li>
</ul>
<h3 id="2）客户端请求目标地址"><a href="#2）客户端请求目标地址" class="headerlink" title="2）客户端请求目标地址"></a>2）客户端请求目标地址</h3><ul>
<li>客户端通过代理的 TCP 连接，发送目标地址和端口，例如：<code>example.com:80</code></li>
<li>代理尝试与目标服务器建立连接</li>
</ul>
<h3 id="3）代理回应结果"><a href="#3）代理回应结果" class="headerlink" title="3）代理回应结果"></a>3）代理回应结果</h3><ul>
<li>连接成功：返回成功报文，允许数据传输</li>
<li>连接失败：返回错误码（如目标不可达、连接被拒绝等）</li>
</ul>
<h3 id="4）数据转发"><a href="#4）数据转发" class="headerlink" title="4）数据转发"></a>4）数据转发</h3><ul>
<li>客户端与目标服务器的所有数据均通过代理中转</li>
<li>代理只做字节转发，不理解应用层协议内容</li>
<li>这使得 SOCKS5 成为一种非常通用的代理机制</li>
</ul>
<hr>
<h2 id="4-TCP-与-UDP-的支持"><a href="#4-TCP-与-UDP-的支持" class="headerlink" title="4. TCP 与 UDP 的支持"></a>4. TCP 与 UDP 的支持</h2><p>SOCKS5 协议既能代理 <strong>TCP</strong>，也能代理 <strong>UDP</strong>：</p>
<ul>
<li><p><strong>TCP CONNECT</strong></p>
<ul>
<li>客户端请求代理建立到目标服务器的 TCP 连接</li>
<li>数据传输过程中，代理双向转发 TCP 流量</li>
<li>应用场景：网页浏览、SSH、邮件收发等</li>
</ul>
</li>
<li><p><strong>UDP ASSOCIATE</strong></p>
<ul>
<li>客户端先通过 TCP 控制通道告诉代理要进行 UDP 转发</li>
<li>代理返回一个专用的 UDP 端口</li>
<li>客户端将 UDP 数据包（带 SOCKS5 UDP 头）发送到该端口，代理再转发到目标服务器</li>
<li>应用场景：DNS 查询、在线游戏、视频流</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-TCP-与-UDP-的关系"><a href="#5-TCP-与-UDP-的关系" class="headerlink" title="5. TCP 与 UDP 的关系"></a>5. TCP 与 UDP 的关系</h2><p>需要特别注意：</p>
<ol>
<li><p><strong>控制信道：必然是 TCP</strong></p>
<ul>
<li>无论最终转发 TCP 还是 UDP，客户端和代理之间都要先建立一条 TCP 连接</li>
<li>握手、认证、UDP 转发上下文都依赖该 TCP 控制信道</li>
</ul>
</li>
<li><p><strong>数据通道：因请求而异</strong></p>
<ul>
<li><strong>CONNECT 命令</strong> → 代理 TCP 流量</li>
<li><strong>UDP ASSOCIATE 命令</strong> → 代理 UDP 数据包</li>
</ul>
</li>
</ol>
<p>👉 简单比喻：</p>
<ul>
<li>TCP 就像一条“电话线”，你先打电话告诉代理你要去哪</li>
<li>如果是 TCP 业务，代理帮你中继对话</li>
<li>如果是 UDP 业务，代理给你一个“邮局地址”，你把信件（UDP 包）寄过去，它帮你转发</li>
</ul>
<hr>
<h2 id="6-为什么-SOCKS5-常用"><a href="#6-为什么-SOCKS5-常用" class="headerlink" title="6. 为什么 SOCKS5 常用"></a>6. 为什么 SOCKS5 常用</h2><p>SOCKS5 在现代网络应用中被广泛使用，原因在于：</p>
<ul>
<li><strong>协议层次低</strong>：位于 TCP&#x2F;UDP 之上，应用层之下，对上层协议透明</li>
<li><strong>适用性广</strong>：能代理任意应用层协议，不仅限于 HTTP</li>
<li><strong>支持 UDP 转发</strong>：满足实时性要求高的业务场景</li>
<li><strong>支持身份认证与 IPv6</strong>：更安全，适应新网络环境</li>
<li><strong>比 HTTP 代理更灵活</strong>：不做解析，只做转发</li>
</ul>
<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>一句话概括：<br><strong>SOCKS5 正向代理的原理是——客户端和代理建立 TCP 会话，告诉代理要访问的目标地址，代理再代表客户端发起连接，并负责转发所有 TCP&#x2F;UDP 数据。代理本身不理解应用层协议，只是透明转发。</strong></p>
<hr>
<p>⚡关键点回顾：</p>
<ul>
<li>SOCKS5 协议本身基于 TCP</li>
<li>可代理 TCP 与 UDP 流量</li>
<li>UDP 转发依赖 TCP 控制信道维持会话</li>
<li>对应用层协议透明，通用性极强</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/17/20250817-shen-ru-li-jie-zheng-xiang-dai-li-yu-fan-xiang-dai-li-http-bao-wen-yu-tcp-lian-jie-de-qu-bie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/17/20250817-shen-ru-li-jie-zheng-xiang-dai-li-yu-fan-xiang-dai-li-http-bao-wen-yu-tcp-lian-jie-de-qu-bie/" itemprop="url">深入理解正向代理与反向代理：HTTP 报文与 TCP 连接的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-17T00:41:19+08:00">
                2025-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>发现之前的理解有一点小偏差，重新整理一下<br>以下内容由AI生成，本人审阅</p>
</blockquote>
</blockquote>
<p>在日常开发和运维中，“正向代理（Forward Proxy）”和“反向代理（Reverse Proxy）”是两个高频概念。但很多人容易混淆两者的请求格式和工作机制。本文将从 <strong>HTTP 报文格式、TCP 连接目标、历史规范</strong> 等角度，系统梳理这两种代理的差别与本质。</p>
<hr>
<h2 id="1-正向代理（Forward-Proxy）"><a href="#1-正向代理（Forward-Proxy）" class="headerlink" title="1. 正向代理（Forward Proxy）"></a>1. 正向代理（Forward Proxy）</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>客户端无法直接访问目标网站（如跨境访问、内网限制），于是先把请求交给代理服务器，由代理转发给目标站点。</p>
<h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><p>客户端请求发送给代理时，<strong>请求行必须带完整 URL</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://www.example.com/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP 连接目标：代理服务器（如 <code>proxy.mycorp.com:8080</code>）</li>
<li>请求行：完整 URL（<code>http://host/path</code>）</li>
<li>Host：目标站点域名（<code>www.example.com</code>）</li>
</ul>
<p>👉 代理根据 URL 或 Host，建立新连接去访问目标网站，再返回结果。</p>
<hr>
<h2 id="2-反向代理（Reverse-Proxy）"><a href="#2-反向代理（Reverse-Proxy）" class="headerlink" title="2. 反向代理（Reverse Proxy）"></a>2. 反向代理（Reverse Proxy）</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>客户端以为自己访问的是目标站点，其实连到的是反向代理（常见如 Nginx、Apache）。代理再根据配置，把请求分发给后端不同的服务。</p>
<h3 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h3><p>客户端对代理并不知情，请求格式与直连一致：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP 连接目标：反向代理（如 <code>nginx</code>）</li>
<li>请求行：相对路径 <code>/path</code></li>
<li>Host：目标站点域名（用于路由转发）</li>
</ul>
<p>👉 对客户端而言，看起来就是访问了目标站点。</p>
<hr>
<h2 id="3-请求报文差异总结"><a href="#3-请求报文差异总结" class="headerlink" title="3. 请求报文差异总结"></a>3. 请求报文差异总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>正向代理</th>
<th>反向代理 &#x2F; 直连</th>
</tr>
</thead>
<tbody><tr>
<td>TCP 连接目标</td>
<td>代理服务器</td>
<td>目标服务器 &#x2F; 反向代理</td>
</tr>
<tr>
<td>请求行</td>
<td><strong>完整 URL</strong> (<code>http://host/path</code>)</td>
<td><strong>相对路径</strong> (<code>/path</code>)</td>
</tr>
<tr>
<td>Host 头</td>
<td>目标域名（如 <code>www.example.com</code>）</td>
<td>目标域名（同上）</td>
</tr>
<tr>
<td>客户端感知</td>
<td><strong>知道在用代理</strong></td>
<td><strong>不知道有代理</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-为什么正向代理要写完整-URL？"><a href="#4-为什么正向代理要写完整-URL？" class="headerlink" title="4. 为什么正向代理要写完整 URL？"></a>4. 为什么正向代理要写完整 URL？</h2><p>这源于 <strong>HTTP&#x2F;1.0 的历史限制</strong>：</p>
<ul>
<li><p><strong>早期（HTTP&#x2F;1.0）</strong>：请求行只有路径，如 <code>GET /index.html HTTP/1.0</code>。<br>当时一个 IP 对应一个网站，直连场景没问题；但如果连的是代理，代理无法得知目标域名。<br>👉 解决方案：<strong>在代理模式下，强制请求行写完整 URL</strong>。</p>
</li>
<li><p><strong>HTTP&#x2F;1.1</strong>：引入 <code>Host</code> 头，直连时可区分虚拟主机。<br>但 <strong>代理模式依旧保留完整 URL 规则</strong>，原因有两点：</p>
<ol>
<li>向后兼容旧代理。</li>
<li>代理可直接用 URL 做缓存键、写日志，逻辑更清晰。</li>
</ol>
</li>
</ul>
<p>因此，虽然代理理论上可以只靠 <code>Host</code> 判断目标，但规范要求写完整 URL。</p>
<hr>
<h2 id="5-TCP-连接层与应用层的分工"><a href="#5-TCP-连接层与应用层的分工" class="headerlink" title="5. TCP 连接层与应用层的分工"></a>5. TCP 连接层与应用层的分工</h2><p>这里的核心区别在于 <strong>TCP 与 HTTP 的分工</strong>：</p>
<ul>
<li><p><strong>TCP 层</strong>：只管“连哪个 IP:Port”。</p>
<ul>
<li>直连：连 <code>www.example.com:80</code></li>
<li>正向代理：连 <code>proxy.mycorp.com:8080</code></li>
</ul>
</li>
<li><p><strong>HTTP 层</strong>：报文里体现目标站点信息。</p>
<ul>
<li>直连&#x2F;反向代理：请求行 <code>/path</code> + Host</li>
<li>正向代理：请求行 <code>http://host/path</code> + Host</li>
</ul>
</li>
</ul>
<p>👉 换句话说，<strong>TCP 根本不知道什么是代理</strong>，它只负责传字节流；代理语义完全由 HTTP 层和客户端实现决定。</p>
<hr>
<h2 id="6-为什么客户端在代理模式下，TCP-连接建到代理服务器？"><a href="#6-为什么客户端在代理模式下，TCP-连接建到代理服务器？" class="headerlink" title="6. 为什么客户端在代理模式下，TCP 连接建到代理服务器？"></a>6. 为什么客户端在代理模式下，TCP 连接建到代理服务器？</h2><p>👉 因为这是 <strong>客户端实现决定的</strong>，不是 HTTP 协议强制的。</p>
<h3 id="1-普通直连模式"><a href="#1-普通直连模式" class="headerlink" title="1. 普通直连模式"></a>1. 普通直连模式</h3><p>浏览器要访问 <code>http://www.example.com/index.html</code>：</p>
<ul>
<li><p>DNS 解析 <code>www.example.com</code> → 得到 IP</p>
</li>
<li><p>建立 TCP 连接 <code>www.example.com:80</code></p>
</li>
<li><p>发请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-配置了正向代理模式"><a href="#2-配置了正向代理模式" class="headerlink" title="2. 配置了正向代理模式"></a>2. 配置了正向代理模式</h3><p>当浏览器或系统配置了代理地址，例如：</p>
<ul>
<li>代理地址：<code>proxy.mycorp.com</code></li>
<li>端口：<code>8080</code></li>
</ul>
<p>此时客户端行为改变：</p>
<ul>
<li><p>DNS 不再解析 <code>www.example.com</code></p>
</li>
<li><p>TCP 连接目标改为 <code>proxy.mycorp.com:8080</code></p>
</li>
<li><p>发请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://www.example.com/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure></li>
</ul>
<p>👉 代理收到报文后，根据 Host 或 URL 确定目标网站，再去转发。</p>
<hr>
<h3 id="3-为什么这是客户端逻辑？"><a href="#3-为什么这是客户端逻辑？" class="headerlink" title="3. 为什么这是客户端逻辑？"></a>3. 为什么这是客户端逻辑？</h3><ul>
<li><p>HTTP 协议只规定“请求报文格式”</p>
</li>
<li><p>TCP 连接目标是由客户端实现决定的</p>
</li>
<li><p>浏览器配置代理的含义就是：</p>
<blockquote>
<p>“以后别直连目标网站，把请求先交给代理。”</p>
</blockquote>
</li>
</ul>
<p>因此：<br>✔ 直连模式 → TCP 连目标站点<br>✔ 代理模式 → TCP 连代理服务器<br>✔ 完全是客户端的选择和实现逻辑</p>
<hr>
<h3 id="4-特别注意：HTTPS-代理"><a href="#4-特别注意：HTTPS-代理" class="headerlink" title="4. 特别注意：HTTPS + 代理"></a>4. 特别注意：HTTPS + 代理</h3><p>当访问 HTTPS 时，客户端会先向代理发送 <strong>CONNECT 方法</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">www.example.com:443</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com:443</span><br></pre></td></tr></table></figure>

<p>代理收到后，建立一条 TCP 隧道；TLS 握手和加密流量在隧道中传输，代理无法解密。<br>👉 这同样完全是客户端的实现逻辑。</p>
<hr>
<p>✅ <strong>结论</strong><br>正向代理模式下，客户端确实是 <strong>主动选择连代理服务器</strong>，而不是目标站点。<br>这是因为客户端知道自己在用代理，所以构造了“特殊的请求行 + 代理 TCP 目标”。</p>
<p>其实从客户端角度看，即使请求行写得像直连模式，效果也常常一样，因为多数代理会兼容：</p>
<ul>
<li>如果请求行缺少完整 URL</li>
<li>代理也能 fallback 到用 Host 提取目标域名</li>
</ul>
<p>因此对用户体验影响不大，差别更多是 <strong>规范要求 vs 代理实现的便利性</strong>。</p>
<hr>
<h2 id="7-正向代理的本质"><a href="#7-正向代理的本质" class="headerlink" title="7. 正向代理的本质"></a>7. 正向代理的本质</h2><p>从不同角度来看，正向代理的核心本质可以归纳为三层：</p>
<ul>
<li><p><strong>从 TCP 角度</strong><br>客户端只是在“建 TCP 连接”这一步，选择连代理服务器的 IP:Port，而不是目标服务器的 IP:Port。<br>👉 对 TCP 来说，这没有什么“特殊”，就是连了另一台机器而已。</p>
</li>
<li><p><strong>从 HTTP 角度</strong><br>客户端在请求报文里写的是绝对 URI（<code>http://host/path</code>），这样代理才能知道目标是谁。<br>👉 这就是“请求行会有完整路径”的原因。</p>
</li>
<li><p><strong>从代理实现角度</strong><br>代理要支持解析这种“带绝对 URI 的请求行”，并根据 Host&#x2F;URI 再去发起一个新的 TCP 连接转发给目标。<br>👉 这就是“代理服务器要有支持转发的逻辑”。</p>
</li>
</ul>
<hr>
<h2 id="8-实际实现-vs-规范要求"><a href="#8-实际实现-vs-规范要求" class="headerlink" title="8. 实际实现 vs 规范要求"></a>8. 实际实现 vs 规范要求</h2><table>
<thead>
<tr>
<th>维度</th>
<th>规范要求</th>
<th>实际实现兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>正向代理请求行</td>
<td>必须写完整 URL</td>
<td>大部分代理也容忍只写 <code>/path</code>，会用 Host 拼接</td>
</tr>
<tr>
<td>Host 头</td>
<td>必须携带</td>
<td>必须携带</td>
</tr>
<tr>
<td>缓存&#x2F;日志</td>
<td>直接用 URL 做键，简单高效</td>
<td>如果缺 URL，代理需额外拼接 Host</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-HTTPS-与正向代理的特殊性"><a href="#9-HTTPS-与正向代理的特殊性" class="headerlink" title="9. HTTPS 与正向代理的特殊性"></a>9. HTTPS 与正向代理的特殊性</h2><p>当通过正向代理访问 HTTPS 站点时，客户端先发起 <strong>CONNECT 隧道请求</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">www.example.com:443</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com:443</span><br></pre></td></tr></table></figure>

<p>代理建立 TCP 隧道后，客户端在隧道内直接跑 TLS 握手，代理无法看到明文。<br>👉 这同样由客户端的代理配置决定，TCP 本身并不区分。</p>
<hr>
<h2 id="10-结论"><a href="#10-结论" class="headerlink" title="10. 结论"></a>10. 结论</h2><ol>
<li><p><strong>正向代理</strong>：</p>
<ul>
<li>TCP 连代理服务器</li>
<li>HTTP 请求行写完整 URL</li>
<li>客户端知道自己在用代理</li>
</ul>
</li>
<li><p><strong>反向代理</strong>：</p>
<ul>
<li>TCP 连反向代理（表面看似目标站点）</li>
<li>HTTP 请求行写路径，Host 提供目标域名</li>
<li>客户端无感知</li>
</ul>
</li>
<li><p><strong>核心差别</strong>：</p>
<ul>
<li>正向代理：服务于客户端，帮助突破访问限制</li>
<li>反向代理：服务于服务器，做负载均衡、缓存、安全隔离</li>
</ul>
</li>
</ol>
<hr>
<p>📌 总结一句话：<br><strong>正向代理是客户端主动配置的中转站，反向代理是服务端架构中的门面。区别的本质在于 TCP 建链目标和 HTTP 请求行格式。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/07/20250807-duo-yu-yan-da-mo-xing-ru-he-chu-li-bu-tong-yu-yan-shi-fan-yi-cheng-ying-yu-hou-zai-tui-li-de-ma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/07/20250807-duo-yu-yan-da-mo-xing-ru-he-chu-li-bu-tong-yu-yan-shi-fan-yi-cheng-ying-yu-hou-zai-tui-li-de-ma/" itemprop="url">多语言大模型如何处理不同语言？是翻译成英语后再推理的吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-07T12:14:48+08:00">
                2025-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>以下文章有ChatGPT生成</p>
</blockquote>
</blockquote>
<p>多语言大模型（Multilingual LLM）越来越普及，但一个常见的问题是：<strong>模型处理非英语语言时，是直接在原语言上推理，还是先翻译成英语再处理？</strong></p>
<p>简短回答：<strong>大多数主流模型并不会将输入翻译为英语后再推理，而是直接在原语言上进行理解与生成。</strong></p>
<p>以下是详细解释。</p>
<hr>
<h2 id="1-训练方式：直接多语言训练"><a href="#1-训练方式：直接多语言训练" class="headerlink" title="1. 训练方式：直接多语言训练"></a>1. 训练方式：直接多语言训练</h2><p>当前主流大模型（如 GPT、Claude、Gemini、Mistral、LLaMA、BLOOM 等）在训练时使用了多语种语料，模型在训练阶段就学会了多语言的语法、词汇和语义表达：</p>
<ul>
<li>不会将所有语料翻译成英语；</li>
<li>而是在训练过程中构建出一个“跨语言的共享语义空间”，在这个空间中不同语言的同义句会靠得很近；</li>
<li>因此，模型具备了直接理解和生成多语言的能力。</li>
</ul>
<hr>
<h2 id="2-英语的优势与“隐性中心化”"><a href="#2-英语的优势与“隐性中心化”" class="headerlink" title="2. 英语的优势与“隐性中心化”"></a>2. 英语的优势与“隐性中心化”</h2><p>虽然模型支持多语言，但英语仍然是“最强语言”，原因包括：</p>
<ul>
<li>英语在训练数据中占比通常高达 60%~90%；</li>
<li>模型参数对英语有更强的优化效果；</li>
<li>英语可能隐性地作为“锚点”来对齐其他语言的语义表示。</li>
</ul>
<p>这种语义对齐并不是翻译行为，而是一种深层语义空间的统一。</p>
<hr>
<h2 id="3-推理流程：不会翻译成英语再处理"><a href="#3-推理流程：不会翻译成英语再处理" class="headerlink" title="3. 推理流程：不会翻译成英语再处理"></a>3. 推理流程：不会翻译成英语再处理</h2><p>当你用中文或其他语言提问时，模型不会走「中文 → 英文 → 推理 → 翻译成中文」这一路径，而是：</p>
<ul>
<li>直接在中文语境中理解问题；</li>
<li>在语义空间中执行推理；</li>
<li>直接生成中文结果。</li>
</ul>
<p>当然，部分三方插件可能人为引入翻译步骤，但这不是模型本身的机制。</p>
<hr>
<h2 id="4-支持机制的实验证据"><a href="#4-支持机制的实验证据" class="headerlink" title="4. 支持机制的实验证据"></a>4. 支持机制的实验证据</h2><ul>
<li><strong>对比实验</strong>：模型处理法语、德语等非英语输入时，直接完成推理与生成，无中转行为。</li>
<li><strong>语义嵌入对齐</strong>：多语言句子在语义空间中具有高度重合性。</li>
<li><strong>激活层分析</strong>：输入非英语语言时，中间激活状态未显示出“语言切换”迹象。</li>
</ul>
<hr>
<h2 id="5-用英语输入表现是否更好？"><a href="#5-用英语输入表现是否更好？" class="headerlink" title="5. 用英语输入表现是否更好？"></a>5. 用英语输入表现是否更好？</h2><p>是的。虽然模型支持多语言，但用英语输入通常效果最佳，尤其体现在知识完整性、表达清晰度、推理深度等方面：</p>
<h3 id="为什么英语效果更好："><a href="#为什么英语效果更好：" class="headerlink" title="为什么英语效果更好："></a>为什么英语效果更好：</h3><table>
<thead>
<tr>
<th>因素</th>
<th>原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据占比高</td>
<td>英语语料远多于其他语言，覆盖面更广，细节更丰富</td>
</tr>
<tr>
<td>表达优化充分</td>
<td>模型在英语上训练迭代次数更多，结构化表达能力更强</td>
</tr>
<tr>
<td>知识密度高</td>
<td>很多细节知识只出现在英文语料（如 Reddit、Wikipedia、新闻、论文等）中</td>
</tr>
<tr>
<td>推理能力领先</td>
<td>英文任务训练量大，模型更善于处理多步推理、复杂逻辑问题</td>
</tr>
</tbody></table>
<hr>
<h3 id="对比示例："><a href="#对比示例：" class="headerlink" title="对比示例："></a>对比示例：</h3><table>
<thead>
<tr>
<th>输入语言</th>
<th>问题</th>
<th>模型响应风格与质量</th>
</tr>
</thead>
<tbody><tr>
<td>英语</td>
<td>Why did the Roman Empire fall?</td>
<td>内容结构清晰，信息丰富，逻辑严密</td>
</tr>
<tr>
<td>中文</td>
<td>罗马帝国为何衰亡？</td>
<td>内容相似，但用词偏模板化，论证略显单薄</td>
</tr>
<tr>
<td>阿拉伯语</td>
<td>لماذا سقطت الإمبراطورية الرومانية؟</td>
<td>回答趋于泛泛，具体细节缺失</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-Prompt-编写建议"><a href="#6-Prompt-编写建议" class="headerlink" title="6. Prompt 编写建议"></a>6. Prompt 编写建议</h2><table>
<thead>
<tr>
<th>使用场景</th>
<th>推荐策略</th>
</tr>
</thead>
<tbody><tr>
<td>复杂推理&#x2F;创作</td>
<td>使用英文 Prompt，提升准确性和内容质量</td>
</tr>
<tr>
<td>中文对话&#x2F;问答</td>
<td>可直接用中文，响应速度快，语义易控</td>
</tr>
<tr>
<td>翻译任务</td>
<td>直接使用目标语言作为输入&#x2F;输出，模型对翻译任务表现良好</td>
</tr>
<tr>
<td>多语言兼容输出</td>
<td>英文 Prompt + 指令 <code>Please answer in Chinese.</code> 等，结果可控</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-实用技巧：英文-Prompt-中文输出"><a href="#7-实用技巧：英文-Prompt-中文输出" class="headerlink" title="7. 实用技巧：英文 Prompt + 中文输出"></a>7. 实用技巧：英文 Prompt + 中文输出</h2><h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Your task in English]</span><br><span class="line">Please answer in Chinese.</span><br></pre></td></tr></table></figure>

<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Write a short argumentative essay about how artificial intelligence is impacting the future of employment. Focus on both the opportunities and challenges it presents. Use logical reasoning and real-world examples.</span><br><span class="line">Please answer in Chinese.</span><br></pre></td></tr></table></figure>

<h3 id="输出（模型生成中文）："><a href="#输出（模型生成中文）：" class="headerlink" title="输出（模型生成中文）："></a>输出（模型生成中文）：</h3><blockquote>
<p>人工智能正在以惊人的速度改变就业的未来……（略）</p>
</blockquote>
<hr>
<h2 id="8-进阶策略：先生成英文，再翻译"><a href="#8-进阶策略：先生成英文，再翻译" class="headerlink" title="8. 进阶策略：先生成英文，再翻译"></a>8. 进阶策略：先生成英文，再翻译</h2><p>对于需要最大限度保持内容质量的应用，可以：</p>
<ol>
<li>使用英文 Prompt；</li>
<li>得到英文结果后，用模型翻译为中文；</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Translate the following text into Chinese:</span><br><span class="line">[英文生成内容]</span><br></pre></td></tr></table></figure>

<p>适合精细控制内容质量的生产环境。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>大模型是否将非英语输入翻译为英语再推理？</td>
<td>否，直接在原语言上推理</td>
</tr>
<tr>
<td>英语输入是否效果更好？</td>
<td>是，表现更强、内容更准确、表达更自然</td>
</tr>
<tr>
<td>多语言之间是否共享知识？</td>
<td>共享语义空间，但知识覆盖仍取决于训练数据分布</td>
</tr>
<tr>
<td>推荐的 Prompt 编写方式？</td>
<td>英文 Prompt + 中文输出 或 英文生成 + 翻译为中文</td>
</tr>
</tbody></table>
<hr>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.11934">Massively Multilingual Models (mT5)</a></li>
<li><a target="_blank" rel="noopener" href="https://huggingface.co/bigscience/bloom">BLOOM: a 176B Multilingual LLM</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2201.10005">XGLM: Multilingual Autoregressive Language Model</a></li>
<li><a target="_blank" rel="noopener" href="https://openai.com/research/multilingual">OpenAI: Language models as multilingual translators</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/08/04/20250804-san-chong-xue-xi-fa-he-xin-jing-sui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/08/04/20250804-san-chong-xue-xi-fa-he-xin-jing-sui/" itemprop="url">三种学习法核心精髓</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-08-04T13:55:52+08:00">
                2025-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="🧠-一、费曼学习法（Feynman-Technique）"><a href="#🧠-一、费曼学习法（Feynman-Technique）" class="headerlink" title="🧠 一、费曼学习法（Feynman Technique）"></a>🧠 一、费曼学习法（Feynman Technique）</h2><p><strong>核心理念：用教别人的方式来教自己。</strong></p>
<h3 id="📌-关键步骤："><a href="#📌-关键步骤：" class="headerlink" title="📌 关键步骤："></a>📌 关键步骤：</h3><ol>
<li><strong>选择概念</strong>：挑选你想学的知识点。  </li>
<li><strong>解释给小白听</strong>：用简单、口语化的语言讲解，好像在教一个完全不懂的人（比如小学生）。  </li>
<li><strong>找出盲点</strong>：当你卡住或讲不清楚，说明你还没真正理解。  </li>
<li><strong>回顾补全</strong>：回到原材料查漏补缺，搞清楚所有细节。  </li>
<li><strong>重新讲解 &amp; 简化</strong>：再次讲解，并尽量用更简单的语言表达。</li>
</ol>
<p>✅ <strong>核心关键：</strong>  </p>
<blockquote>
<p>“能讲清楚，才算真正学懂。”</p>
</blockquote>
<hr>
<h2 id="🧩-二、西蒙学习法（Herbert-Simon-Learning-Strategy）"><a href="#🧩-二、西蒙学习法（Herbert-Simon-Learning-Strategy）" class="headerlink" title="🧩 二、西蒙学习法（Herbert Simon Learning Strategy）"></a>🧩 二、西蒙学习法（Herbert Simon Learning Strategy）</h2><p>（又称“问题解决导向学习”Problem-Solving Learning）</p>
<h3 id="📌-关键特点："><a href="#📌-关键特点：" class="headerlink" title="📌 关键特点："></a>📌 关键特点：</h3><ol>
<li><strong>以问题为驱动</strong>：学习过程围绕真实问题展开，而不是被动接收知识。  </li>
<li><strong>建立知识结构</strong>：通过已有的知识和逻辑推理解决新问题。  </li>
<li><strong>重视反思与优化</strong>：每一次问题解决都伴随着策略的反思和迭代。</li>
</ol>
<p>✅ <strong>核心关键：</strong>  </p>
<blockquote>
<p>“用解决问题的方式构建知识体系。”</p>
</blockquote>
<hr>
<h2 id="📝-三、康奈尔学习法（Cornell-Note-taking-System）"><a href="#📝-三、康奈尔学习法（Cornell-Note-taking-System）" class="headerlink" title="📝 三、康奈尔学习法（Cornell Note-taking System）"></a>📝 三、康奈尔学习法（Cornell Note-taking System）</h2><p><strong>核心理念：结构化笔记提升理解与记忆。</strong></p>
<h3 id="📌-五大步骤："><a href="#📌-五大步骤：" class="headerlink" title="📌 五大步骤："></a>📌 五大步骤：</h3><ol>
<li><strong>笔记区（右侧大块）</strong>：上课或阅读时记下主要内容。  </li>
<li><strong>提问区（左侧小块）</strong>：课后写下问题、关键词或提示语，用于复习时自测。  </li>
<li><strong>总结区（底部）</strong>：用自己的话总结整页笔记的核心。  </li>
<li><strong>回顾复习</strong>：定期回看并测试自己，强化记忆。  </li>
<li><strong>联结思考</strong>：不断将新知识与旧知识联系起来。</li>
</ol>
<p>✅ <strong>核心关键：</strong>  </p>
<blockquote>
<p>“记笔记不是为了记录，而是为了思考和复习。”</p>
</blockquote>
<hr>
<h2 id="🔍-总结对比表"><a href="#🔍-总结对比表" class="headerlink" title="🔍 总结对比表"></a>🔍 总结对比表</h2><table>
<thead>
<tr>
<th>学习法</th>
<th>核心关键</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>费曼学习法</td>
<td>教别人来检验理解深度</td>
<td>理论知识、概念型内容</td>
</tr>
<tr>
<td>西蒙学习法</td>
<td>以解决问题构建知识结构</td>
<td>数理逻辑、编程、工程类内容</td>
</tr>
<tr>
<td>康奈尔学习法</td>
<td>结构化笔记促进理解与回顾</td>
<td>听课、读书、考试复习</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/07/17/20250717-quick-worker-xiang-mu-fen-xi-ji-yu-channel-de-gao-xiao-yi-bu-pi-chu-li-yu-cpu-kong-zhuan-wen-ti-jie-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/07/17/20250717-quick-worker-xiang-mu-fen-xi-ji-yu-channel-de-gao-xiao-yi-bu-pi-chu-li-yu-cpu-kong-zhuan-wen-ti-jie-xi/" itemprop="url">quick_worker 项目分析：基于 Channel 的高效异步批处理与 CPU 空转问题解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-07-17T00:20:44+08:00">
                2025-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a target="_blank" rel="noopener" href="https://github.com/Kingson4Wu/quick_worker"><code>quick_worker</code></a> 是一个用 Go 实现的轻量级异步批处理框架。它通过 channel 和 goroutine 构建了一个高效的生产者-消费者模型，支持按批量大小或超时触发数据处理，适合高并发、吞吐敏感的场景。</p>
<p>本文将围绕其核心并发模型进行分析，重点讨论：</p>
<ul>
<li>是否存在 CPU 空转（Busy Waiting）问题</li>
<li><code>select</code> 和 channel 的阻塞特性</li>
<li>在什么情况下应考虑使用 <code>sync.Cond</code> 替代主动轮询</li>
</ul>
<hr>
<h3 id="一、项目核心架构概览"><a href="#一、项目核心架构概览" class="headerlink" title="一、项目核心架构概览"></a>一、项目核心架构概览</h3><p><code>quick_worker</code> 的核心工作流程：</p>
<ol>
<li><strong>数据投递</strong>：调用方通过 <code>Produce</code> 方法投递任务数据。</li>
<li><strong>缓冲通道</strong>：数据进入内部 <code>dataChan</code> 缓冲通道。</li>
<li><strong>消费者循环</strong>：独立的消费者 goroutine 执行 <code>consume</code> 方法，负责从通道中取出数据并批量处理。</li>
<li><strong>触发机制</strong>：处理可以由达到最大批量（maxBatchSize）或等待超时（maxWaitDuration）触发。</li>
<li><strong>退出控制</strong>：通过 <code>doneChan</code> 通知消费者优雅退出。</li>
</ol>
<p>这一模型兼具性能与可靠性，典型用于日志聚合、异步队列、延迟任务聚合等场景。</p>
<hr>
<h3 id="二、关于-CPU-空转（Busy-Waiting）问题的分析"><a href="#二、关于-CPU-空转（Busy-Waiting）问题的分析" class="headerlink" title="二、关于 CPU 空转（Busy Waiting）问题的分析"></a>二、关于 CPU 空转（Busy Waiting）问题的分析</h3><h4 id="1-消费者循环是否会导致空转？"><a href="#1-消费者循环是否会导致空转？" class="headerlink" title="1. 消费者循环是否会导致空转？"></a>1. 消费者循环是否会导致空转？</h4><p><code>core/worker.go</code> 中的主循环如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, ok := &lt;-w.dataChan:</span><br><span class="line">        <span class="comment">// 接收并处理数据</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">        <span class="comment">// 超时触发处理</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-w.doneChan:</span><br><span class="line">        <span class="comment">// 接收到退出信号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该循环具有以下特性：</p>
<ul>
<li><strong>select 是阻塞式的</strong>：当所有分支都不满足时，<code>select</code> 会自动挂起，不占用 CPU。</li>
<li>只要 <code>dataChan</code> 中没有数据、<code>timer</code> 没有到期、<code>doneChan</code> 没有信号，该 goroutine 会自然休眠。</li>
<li><strong>结论：这段代码不会导致 CPU 空转，是标准的 Go 并发写法。</strong></li>
</ul>
<h4 id="2-生产者逻辑是否安全？"><a href="#2-生产者逻辑是否安全？" class="headerlink" title="2. 生产者逻辑是否安全？"></a>2. 生产者逻辑是否安全？</h4><p>生产者调用 <code>Produce</code> 方法将数据投递进通道时，使用了非阻塞的 <code>select</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> w.dataChan &lt;- data:</span><br><span class="line">    <span class="comment">// 投递成功</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 通道已满，放弃投递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这避免了阻塞与死循环，也没有任何 busy loop 行为。</p>
<h4 id="3-可能导致空转的场景分析"><a href="#3-可能导致空转的场景分析" class="headerlink" title="3. 可能导致空转的场景分析"></a>3. 可能导致空转的场景分析</h4><table>
<thead>
<tr>
<th>场景</th>
<th>quick_worker 中是否存在</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>for &#123;&#125;</code> 死循环</td>
<td>❌</td>
<td>无此代码</td>
</tr>
<tr>
<td><code>for &#123; select &#123;&#125; &#125;</code> 且无阻塞分支</td>
<td>❌</td>
<td>每个 select 都含有阻塞通道</td>
</tr>
<tr>
<td>定时器设置过小，频繁唤醒</td>
<td>⚠️</td>
<td>频繁 wakeup 但不构成空转</td>
</tr>
<tr>
<td>通道满后生产者死循环 retry</td>
<td>❌</td>
<td>当前实现非阻塞，未重试</td>
</tr>
</tbody></table>
<h4 id="✅-总结结论："><a href="#✅-总结结论：" class="headerlink" title="✅ 总结结论："></a>✅ 总结结论：</h4><ul>
<li><code>quick_worker</code> 中的核心并发逻辑是以阻塞式 channel + timer 驱动的。</li>
<li>消费者 goroutine 不存在任何 busy waiting。</li>
<li>项目天然避免了 CPU 空转问题，性能开销可控。</li>
</ul>
<hr>
<h3 id="三、sync-Cond：在什么情况下必须使用它来避免-CPU-空转？"><a href="#三、sync-Cond：在什么情况下必须使用它来避免-CPU-空转？" class="headerlink" title="三、sync.Cond：在什么情况下必须使用它来避免 CPU 空转？"></a>三、sync.Cond：在什么情况下必须使用它来避免 CPU 空转？</h3><p>虽然 <code>quick_worker</code> 本身没有使用 <code>sync.Cond</code>，但了解它的用途对于设计其他复杂同步场景非常重要。</p>
<h4 id="1-什么是-CPU-空转？"><a href="#1-什么是-CPU-空转？" class="headerlink" title="1. 什么是 CPU 空转？"></a>1. 什么是 CPU 空转？</h4><p>CPU 空转（Busy Waiting）是指：<strong>线程在等待某个条件成立时，不阻塞、不 sleep，而是反复检查条件的状态，导致 CPU 被无意义地占用</strong>。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ready &#123;</span><br><span class="line">    <span class="comment">// 空转：一直检查条件，浪费 CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码没有任何阻塞操作，会让 CPU 持续忙碌。</p>
<h4 id="2-如何使用-sync-Cond-避免空转？"><a href="#2-如何使用-sync-Cond-避免空转？" class="headerlink" title="2. 如何使用 sync.Cond 避免空转？"></a>2. 如何使用 sync.Cond 避免空转？</h4><p><code>sync.Cond</code> 提供了条件变量机制，允许我们在等待某个条件时挂起 goroutine，直到条件成立被显式唤醒。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(&amp;mu)</span><br><span class="line"><span class="keyword">var</span> ready <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待方（消费者）</span></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> !ready &#123;</span><br><span class="line">    cond.Wait() <span class="comment">// 阻塞等待，自动释放锁，避免空转</span></span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知方（生产者）</span></span><br><span class="line">mu.Lock()</span><br><span class="line">ready = <span class="literal">true</span></span><br><span class="line">cond.Signal() <span class="comment">// 或 cond.Broadcast()</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><code>Wait()</code> 会阻塞 goroutine，而不是让它空转。</li>
<li><code>Signal()</code> 只唤醒一个等待者，<code>Broadcast()</code> 唤醒所有等待者。</li>
</ul>
<h4 id="3-使用-sync-Cond-的典型场景"><a href="#3-使用-sync-Cond-的典型场景" class="headerlink" title="3. 使用 sync.Cond 的典型场景"></a>3. 使用 sync.Cond 的典型场景</h4><table>
<thead>
<tr>
<th>适用场景</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>缓存读取等待写入</td>
<td>等待数据可用，不适合用 channel 表达</td>
</tr>
<tr>
<td>对象池等待资源释放</td>
<td>条件复杂或需共享状态，channel 难以表达</td>
</tr>
<tr>
<td>多线程 barrier 同步</td>
<td>等待多个条件成立后同时唤醒</td>
</tr>
<tr>
<td>控制 goroutine 启停</td>
<td>管理状态而不是数据流</td>
</tr>
</tbody></table>
<h4 id="4-channel-和-sync-Cond-的选择建议"><a href="#4-channel-和-sync-Cond-的选择建议" class="headerlink" title="4. channel 和 sync.Cond 的选择建议"></a>4. channel 和 sync.Cond 的选择建议</h4><table>
<thead>
<tr>
<th>特性</th>
<th>channel</th>
<th>sync.Cond</th>
</tr>
</thead>
<tbody><tr>
<td>数据流驱动</td>
<td>✅（首选）</td>
<td>❌（不适合）</td>
</tr>
<tr>
<td>条件状态驱动</td>
<td>❌（难表达）</td>
<td>✅（适合表达条件判断）</td>
</tr>
<tr>
<td>是否易用</td>
<td>简单直观</td>
<td>需要配合锁、小心竞态</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>✅（天然阻塞）</td>
<td>✅（Wait 手动阻塞）</td>
</tr>
</tbody></table>
<p><strong>结论：</strong></p>
<blockquote>
<p>如果你在等待某个“条件”而非“数据”，又无法用 channel 表达，那么使用 <code>sync.Cond</code> 可以有效避免 busy loop。</p>
</blockquote>
<hr>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul>
<li><code>quick_worker</code> 项目使用阻塞式 select 循环，无 busy loop 行为，不存在 CPU 空转问题。</li>
<li>Go 的 channel 和 timer 本身就是高效的阻塞机制，只要 select 内有阻塞分支，goroutine 就不会占用 CPU。</li>
<li>只有在使用 <code>for + 条件判断</code> 等原始自旋方式等待状态时，才需要引入 <code>sync.Cond</code>。</li>
<li><code>sync.Cond</code> 更适合资源池、复杂状态条件协作等无法使用 channel 描述的场景。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/07/16/20250716-quickit-gao-xiao-bing-fa-ren-wu-guan-li-gong-ju-ku-xiang-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/07/16/20250716-quickit-gao-xiao-bing-fa-ren-wu-guan-li-gong-ju-ku-xiang-jie/" itemprop="url">QuicKit：高效并发任务管理工具库详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-07-16T22:50:57+08:00">
                2025-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在现代软件开发中，高效的任务管理与并发处理是提升系统性能的关键。<strong>QuicKit</strong> 是一个基于 Java 的工具库，专注于并发任务调度、执行控制、重试机制等通用能力的封装。本文将深入介绍 QuicKit 的核心功能及其实现原理。</p>
<hr>
<h2 id="1-延迟任务调度：DelayQueueUtils"><a href="#1-延迟任务调度：DelayQueueUtils" class="headerlink" title="1. 延迟任务调度：DelayQueueUtils"></a>1. 延迟任务调度：<code>DelayQueueUtils</code></h2><p><code>DelayQueueUtils</code> 使用 <strong>HashedWheelTimer</strong> 实现延迟任务的高效调度。</p>
<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><ul>
<li><strong>时间轮机制</strong>：将时间划分为多个槽（slots），类似时钟的刻度。</li>
<li><strong>任务分配</strong>：任务根据设定的延迟时间分配至对应槽中。</li>
<li><strong>槽激活</strong>：时间轮旋转，当指针指向某个槽时，执行该槽内的所有任务。</li>
</ul>
<blockquote>
<p>✅ 优势：极大减少内存消耗和调度开销，适合高频延迟任务场景。</p>
</blockquote>
<hr>
<h2 id="2-执行频率控制：ExecutionFrequencyUtils"><a href="#2-执行频率控制：ExecutionFrequencyUtils" class="headerlink" title="2. 执行频率控制：ExecutionFrequencyUtils"></a>2. 执行频率控制：<code>ExecutionFrequencyUtils</code></h2><p>用于<strong>控制任务执行频率</strong>，防止系统被大量任务压垮。</p>
<h3 id="实现原理：-1"><a href="#实现原理：-1" class="headerlink" title="实现原理："></a>实现原理：</h3><ul>
<li><strong>任务分片</strong>：将任务列表切分为多个子任务，每批任务在一定时间间隔内执行。</li>
<li><strong>频率限制</strong>：可配置每秒允许执行的任务数量，避免突发任务过载系统。</li>
</ul>
<blockquote>
<p>✅ 应用场景：接口限流、批量处理限速、系统保护。</p>
</blockquote>
<hr>
<h2 id="3-并行任务处理：ParallelTask"><a href="#3-并行任务处理：ParallelTask" class="headerlink" title="3. 并行任务处理：ParallelTask"></a>3. 并行任务处理：<code>ParallelTask</code></h2><p>提供简洁高效的<strong>并行处理能力</strong>，充分利用多核 CPU 性能。</p>
<h3 id="实现原理：-2"><a href="#实现原理：-2" class="headerlink" title="实现原理："></a>实现原理：</h3><ul>
<li><strong>并行流</strong>：基于 Java 8 的 <code>parallelStream()</code> 并行处理任务。</li>
<li><strong>线程池管理</strong>：使用 <code>ExecutorService</code> 管理线程，降低线程创建销毁开销。</li>
</ul>
<blockquote>
<p>✅ 适用场景：批量任务处理、并发计算、数据转换等。</p>
</blockquote>
<hr>
<h2 id="4-重试机制：RetryUtils"><a href="#4-重试机制：RetryUtils" class="headerlink" title="4. 重试机制：RetryUtils"></a>4. 重试机制：<code>RetryUtils</code></h2><p>内置灵活的<strong>重试机制</strong>，应对任务失败后的自动恢复。</p>
<h3 id="实现原理：-3"><a href="#实现原理：-3" class="headerlink" title="实现原理："></a>实现原理：</h3><ul>
<li><strong>重试策略配置</strong>：通过 <code>RetryerBuilder</code> 设置重试次数、间隔、终止条件等。</li>
<li><strong>异常捕获与处理</strong>：根据异常类型与策略自动判断是否重试。</li>
</ul>
<blockquote>
<p>✅ 典型用途：数据库重试、远程服务调用、临时异常容忍。</p>
</blockquote>
<hr>
<h2 id="5-读写锁封装：ReadWriteLockWrapper"><a href="#5-读写锁封装：ReadWriteLockWrapper" class="headerlink" title="5. 读写锁封装：ReadWriteLockWrapper"></a>5. 读写锁封装：<code>ReadWriteLockWrapper</code></h2><p>封装 Java 原生 <code>ReentrantReadWriteLock</code>，简化并发数据访问控制。</p>
<h3 id="实现原理：-4"><a href="#实现原理：-4" class="headerlink" title="实现原理："></a>实现原理：</h3><ul>
<li><strong>读写分离</strong>：多个线程可同时读，写需独占。</li>
<li><strong>锁降级支持</strong>：支持写锁降级为读锁，提升吞吐性能。</li>
</ul>
<blockquote>
<p>✅ 适用场景：缓存读取、配置中心、共享资源管理等。</p>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>QuicKit</strong> 通过提供一系列高性能并发工具，极大简化了任务调度、线程管理与错误恢复的复杂性。无论你在构建分布式系统、服务中间件，还是日常业务逻辑开发，QuicKit 都是一个值得使用的并发基础组件库。</p>
<hr>
<p>📦 <strong>项目地址</strong>：<br>👉 <a target="_blank" rel="noopener" href="https://github.com/Kingson4Wu/QuicKit">https://github.com/Kingson4Wu/QuicKit</a></p>
<p>📚 <strong>文档地址</strong>：<br>👉 <a target="_blank" rel="noopener" href="https://deepwiki.com/Kingson4Wu/QuicKit">https://deepwiki.com/Kingson4Wu/QuicKit</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/07/09/20250709-shua-leetcode-zong-jie-de-suan-fa-ji-chu-he-tao-lu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/07/09/20250709-shua-leetcode-zong-jie-de-suan-fa-ji-chu-he-tao-lu/" itemprop="url">刷LeetCode总结的算法基础和套路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-07-09T15:20:22+08:00">
                2025-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>最近重新刷LeetCode，对一些算法基础和套路做下总结，以做备忘</p>
</blockquote>
</blockquote>
<hr>
<h1 id="简要分类总结"><a href="#简要分类总结" class="headerlink" title="简要分类总结"></a>简要分类总结</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>数组（Array）</li>
<li>链表（Linked List） </li>
<li>哈希表（HashMap &#x2F; HashSet）</li>
<li>堆（Heap）<ul>
<li>最大堆 &#x2F; 最小堆</li>
<li>常用于：优先队列、Top K、调度排序</li>
</ul>
</li>
<li>栈 &#x2F; 队列（Stack &#x2F; Queue）<ul>
<li>DFS 通常借助栈实现，BFS 借助队列</li>
</ul>
</li>
<li>树（Tree）<ul>
<li>普通二叉树</li>
<li>二叉搜索树（BST）</li>
<li>平衡二叉树（AVL &#x2F; 红黑树）</li>
<li>字典树（Trie）</li>
<li>线段树（Segment Tree）</li>
<li>树状数组（Fenwick Tree）</li>
<li>并查集</li>
</ul>
</li>
<li>图（Graph）<ul>
<li>表示方式：邻接表、邻接矩阵</li>
<li>有向图 &#x2F; 无向图，带权图 &#x2F; 无权图</li>
<li>拓扑排序<ul>
<li>Kahn 算法（BFS 实现）</li>
<li>DFS 逆后序（递归 + 回退）</li>
<li>用于检测有向图中是否存在环、任务调度等</li>
</ul>
</li>
<li>最短路径算法：Dijkstra、Floyd、Bellman-Ford（带权图最短路径）</li>
<li>最小生成树算法：Kruskal &#x2F; Prim</li>
<li>稠密图和稀疏图<ul>
<li>稠密图：边很多，接近“完全图”</li>
<li>稀疏图：边很少，大多数节点之间没有直接连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>遍历算法<ul>
<li>深度优先搜索（DFS）<ul>
<li>栈结构实现（递归或手动栈）</li>
<li>回溯 （&#x3D; DFS + 剪枝 + 状态恢复（回退））<ul>
<li>常用于：组合、排列、子集、数独、八皇后等问题</li>
</ul>
</li>
</ul>
</li>
<li>广度优先搜索（BFS）<ul>
<li>队列结构实现，逐层遍历</li>
</ul>
</li>
</ul>
</li>
<li>排序（冒泡、快速、堆）</li>
<li>快慢指针&#x2F; 双指针</li>
<li>滑动窗口</li>
<li>单调栈 &#x2F; 单调队列</li>
<li>二分查找</li>
<li>分治算法（Divide &amp; Conquer）</li>
<li>贪心算法（Greedy）</li>
<li>动态规划（DP）<ul>
<li>背包问题（0-1 背包、子集背包、完全背包）</li>
<li>子序列问题（LIS 最长递增子序列、LCS 最长公共子序列）</li>
<li>区间 DP &#x2F; 状态压缩 &#x2F; 滚动数组</li>
</ul>
</li>
<li>回溯算法（Backtracking）<ul>
<li>用于枚举所有可能解，如全排列、组合 &#x2F; 子集</li>
</ul>
</li>
</ul>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li><p>与数组不同，链表在构建子链时不会增加额外的空间复杂度。因此可以放心地构造子链，无需考虑节点交换的问题，也不必执着于“原地交换”的思路。</p>
</li>
<li><p>使用哨兵节点是一种常见技巧，它可以避免处理头指针等特殊情况，在代码实现上更加简洁。</p>
<ul>
<li><strong>链表内指定区间反转：</strong><br>给定一个单链表的头指针 <code>head</code>，以及两个整数 <code>left</code> 和 <code>right</code>（其中 <code>left &lt;= right</code>），请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> m == n || head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哨兵节点，避免处理头指针的特殊情况</span></span><br><span class="line">    dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 找到第 m-1 个节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转 m 到 n 之间的节点，采用头插法</span></span><br><span class="line">    start := pre.Next      <span class="comment">// 第 m 个节点</span></span><br><span class="line">    then := start.Next     <span class="comment">// 第 m+1 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n-m; i++ &#123;</span><br><span class="line">        start.Next = then.Next</span><br><span class="line">        then.Next = pre.Next</span><br><span class="line">        pre.Next = then</span><br><span class="line">        then = start.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li><p><strong>二叉树遍历（先序、中序、后序）</strong></p>
<ul>
<li>先序（中左右）、中序（左中右）、后序（左右中）</li>
<li>包含递归与非递归两种实现方式</li>
<li><strong>DFS</strong>：先序 &#x2F; 中序 &#x2F; 后序（递归 &#x2F; 栈实现）</li>
<li><strong>BFS</strong>：层序遍历（借助队列实现）</li>
</ul>
</li>
<li><p><strong>二叉查找树（Binary Search Tree，简称 BST）</strong></p>
<ul>
<li>左子树所有节点的值均小于根节点，右子树所有节点的值均大于根节点（<strong>不允许等于</strong>）</li>
<li><strong>中序遍历结果是升序序列</strong></li>
</ul>
</li>
<li><p><strong>完全二叉树</strong></p>
<ul>
<li>如果一棵深度为 <code>h</code> 的二叉树，除了第 <code>h</code> 层，其它每一层的节点数都达到最大值，并且第 <code>h</code> 层的节点都尽量靠左排列，则该树是完全二叉树</li>
<li>第 <code>h</code> 层可能包含 <code>1 ~ 2^h</code> 个节点</li>
<li><strong>堆</strong>（大顶堆 &#x2F; 小顶堆）是一种基于完全二叉树的结构</li>
</ul>
</li>
<li><p><strong>平衡二叉树（Balanced Binary Tree）</strong></p>
<ul>
<li>要么是空树，要么满足以下条件：左右子树的高度差的绝对值不超过 1，且左右子树也分别是平衡二叉树</li>
</ul>
</li>
</ul>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ul>
<li><p>树的遍历主要分为两类：</p>
<ul>
<li><p><strong>广度优先遍历（BFS）</strong>：也称层序遍历，使用队列实现</p>
</li>
<li><p><strong>深度优先遍历（DFS）</strong>：包括先序、中序、后序三种形式，可使用递归或栈实现</p>
<ul>
<li>递归</li>
<li>栈</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>深度优先遍历（DFS）说明</strong></p>
<ul>
<li>使用递归实现 DFS 时，虽然代码中未显式使用栈，但其实是借助系统的 <strong>调用栈（Call Stack）</strong> 来进行函数的递归与回溯</li>
</ul>
</li>
</ul>
<h3 id="先序遍历（前序）"><a href="#先序遍历（前序）" class="headerlink" title="先序遍历（前序）"></a>先序遍历（前序）</h3><ul>
<li><p>栈实现流程：</p>
<ol>
<li>循环条件：<code>root != nil || len(stack) &gt; 0</code></li>
<li>若 <code>root != nil</code>，访问节点、入栈、转向左子树</li>
<li>否则出栈、转向右子树</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> preorder() []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	stack := []*TreeNode&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, root.data)      <span class="comment">// 访问当前节点</span></span><br><span class="line">			stack = <span class="built_in">append</span>(stack, root)       <span class="comment">// 入栈</span></span><br><span class="line">			root = root.Lchild                <span class="comment">// 向左子树移动</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]        <span class="comment">// 出栈</span></span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			root = root.Rchild                <span class="comment">// 转向右子树</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li><p>栈实现流程：</p>
<ol>
<li>循环条件：<code>root != nil || len(stack) &gt; 0</code></li>
<li>若 <code>root != nil</code>，将当前节点入栈并转向左子树</li>
<li>否则出栈并访问节点</li>
<li>然后转向右子树</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> inorder() []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	stack := []*TreeNode&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, root)       <span class="comment">// 入栈，等待回溯</span></span><br><span class="line">			root = root.Lchild                <span class="comment">// 向左走</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]        <span class="comment">// 出栈</span></span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			res = <span class="built_in">append</span>(res, root.data)      <span class="comment">// 访问节点</span></span><br><span class="line">			root = root.Rchild                <span class="comment">// 转向右子树</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例题目：判断一棵二叉树是否为二叉搜索树</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    inorder := math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> || root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt;= inorder &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder = root.Val</span><br><span class="line">        root = root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>非递归实现关键：访问节点需保证其左右子树均已访问或为空</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> Postorder() []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	stack := []*TreeNode&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> pre *TreeNode = <span class="literal">nil</span></span><br><span class="line">	stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		<span class="comment">// 如果是叶子节点，或子节点已访问，则访问当前节点</span></span><br><span class="line">		<span class="keyword">if</span> (cur.Lchild == <span class="literal">nil</span> &amp;&amp; cur.Rchild == <span class="literal">nil</span>) || (pre != <span class="literal">nil</span> &amp;&amp; (pre == cur.Lchild || pre == cur.Rchild)) &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, cur.data)</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			pre = cur <span class="comment">// 标记当前已访问</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cur.Rchild != <span class="literal">nil</span> &#123;</span><br><span class="line">				stack = <span class="built_in">append</span>(stack, cur.Rchild)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur.Lchild != <span class="literal">nil</span> &#123;</span><br><span class="line">				stack = <span class="built_in">append</span>(stack, cur.Lchild)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><ul>
<li><p>删除节点的四种情况：</p>
<ol>
<li><p><strong>叶子节点（无子节点）</strong></p>
<ul>
<li>直接删除，返回 <code>nil</code>。</li>
</ul>
</li>
<li><p><strong>只有左子树</strong></p>
<ul>
<li>用左子节点替代当前节点，返回 <code>root.Left</code>。</li>
</ul>
</li>
<li><p><strong>只有右子树</strong></p>
<ul>
<li>用右子节点替代当前节点，返回 <code>root.Right</code>。</li>
</ul>
</li>
<li><p><strong>左右子树都有</strong></p>
<ul>
<li>找右子树中最小的节点（即<strong>后继 successor</strong>），</li>
<li>用 successor 的值替代当前节点的值，</li>
<li>然后在右子树中递归删除该 successor 节点。</li>
</ul>
</li>
</ol>
</li>
<li><p>情况 4 的说明：</p>
<ul>
<li>**右子树的最小节点（successor）**不一定是叶子节点；</li>
<li>它一定没有左子节点，但<strong>可能有右子节点</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  10                        11        </span><br><span class="line"> /  \                      /  \</span><br><span class="line">5    15                   5   15</span><br><span class="line">    /                         /  </span><br><span class="line">   11       --&gt;             13</span><br><span class="line">     \                     /  \  </span><br><span class="line">     13                   12  14</span><br><span class="line">    /  \</span><br><span class="line">   12   14</span><br></pre></td></tr></table></figure>

<ul>
<li><p>什么是“递归删除 successor 节点”？</p>
<ul>
<li>当我们删除一个节点（设为 <code>root</code>）且其有左右子树时，选择右子树中最小节点（successor）作为替代；</li>
<li>但此时右子树中仍存在原来的 successor 节点，因此需在右子树中递归删除该节点；</li>
<li>这样才能确保整棵树依然符合**二叉搜索树（BST）**的性质。</li>
</ul>
</li>
</ul>
<h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key &lt; root.Val &#123;</span><br><span class="line">		root.Left = deleteNode(root.Left, key)</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> key &gt; root.Val &#123;</span><br><span class="line">		root.Right = deleteNode(root.Right, key)</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找到要删除的结点</span></span><br><span class="line">	<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root.Right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root.Left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 情况4：左右子树都有</span></span><br><span class="line">	<span class="comment">//需要找右子树的最小值的结点, 最小的一定在最左边</span></span><br><span class="line">	successor := root.Right</span><br><span class="line">	<span class="keyword">for</span> successor.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">		successor = successor.Left</span><br><span class="line">	&#125;</span><br><span class="line">	successor.Right = deleteNode(root.Right, successor.Val)</span><br><span class="line">	successor.Left = root.Left</span><br><span class="line">	<span class="keyword">return</span> successor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状数组（Fenwick-Tree-x2F-Binary-Indexed-Tree）"><a href="#树状数组（Fenwick-Tree-x2F-Binary-Indexed-Tree）" class="headerlink" title="树状数组（Fenwick Tree &#x2F; Binary Indexed Tree）"></a>树状数组（Fenwick Tree &#x2F; Binary Indexed Tree）</h2><ul>
<li><p><strong>适用场景</strong>：一维前缀和问题（如区间求和、频率统计等）</p>
</li>
<li><p><strong>核心思想</strong>：</p>
<ul>
<li>利用二进制的最低位（lowbit）来定位负责某段区间的节点</li>
<li>是一种空间压缩形式的前缀树结构</li>
</ul>
</li>
<li><p>一种可动态维护序列前缀和的数据结构，支持以下操作：</p>
<ul>
<li>**单点更新 <code>update(i, v)</code>**：将第 <code>i</code> 个位置的值增加 <code>v</code>（如本题中 <code>v = 1</code>）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(i <span class="type">int</span>, v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i &lt;= n &#123;  <span class="comment">// n 是树状数组的长度</span></span><br><span class="line">        bit[i] += v</span><br><span class="line">        i += i &amp; -i  <span class="comment">// 跳到下一个负责这个区间的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>**区间查询 <code>query(i)</code>**：查询区间 <code>[1..i]</code> 的前缀和</p>
<ul>
<li>通过跳跃式回溯累加，效率高</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 bit[1] 到 bit[i] 的前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res += bit[i]</span><br><span class="line">        i -= i &amp; -i  <span class="comment">// i &amp; -i 取最低位的 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="query-p-的跳跃计算示意"><a href="#query-p-的跳跃计算示意" class="headerlink" title="query(p) 的跳跃计算示意"></a>query(p) 的跳跃计算示意</h3><ul>
<li>树状数组 <code>bit[]</code> 示意如下：</li>
</ul>
<table>
<thead>
<tr>
<th>下标（i）</th>
<th>bit[i]</th>
<th>表示的区间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>sum(1)</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>sum(1..2)</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>sum(3)</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>sum(1..4)</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>sum(5)</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>sum(5..6)</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>sum(7)</td>
</tr>
<tr>
<td>8</td>
<td>?</td>
<td>sum(1..8)</td>
</tr>
</tbody></table>
<ul>
<li><p>查询 <code>query(5)</code> 实际执行过程如下：</p>
<ul>
<li>第一次：<code>p = 5</code> → <code>sum += bit[5] = 0</code> → <code>p = 5 - 1 = 4</code></li>
<li>第二次：<code>p = 4</code> → <code>sum += bit[4] = 3</code> → <code>p = 4 - 4 = 0</code></li>
<li>退出循环，结果为 <code>sum = 3</code></li>
</ul>
</li>
<li><p>实际加了哪些区间：</p>
<ul>
<li><code>bit[5]</code> → 表示 <code>[5]</code></li>
<li><code>bit[4]</code> → 表示 <code>[1..4]</code></li>
<li>所以 <code>sum[1..5] = bit[5] + bit[4]</code></li>
</ul>
</li>
</ul>
<h3 id="为什么-x-amp-x-能取得-x-的最低位-1？"><a href="#为什么-x-amp-x-能取得-x-的最低位-1？" class="headerlink" title="为什么 x &amp; (-x) 能取得 x 的最低位 1？"></a>为什么 <code>x &amp; (-x)</code> 能取得 <code>x</code> 的最低位 1？</h3><ul>
<li><p>原理：使用补码</p>
<ul>
<li><code>-x = ^x + 1</code>（按位取反再加 1）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x     = <span class="number">00001100</span></span><br><span class="line">-x    = <span class="number">11110100</span></span><br><span class="line">----------------</span><br><span class="line">x &amp; -x = <span class="number">00000100</span>  <span class="comment">// 取出最低位的 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>补码运算确保 <code>x &amp; -x</code> 恰好保留最低位的 1，其它位互斥</li>
</ul>
<h3 id="树状数组的安全构造方式"><a href="#树状数组的安全构造方式" class="headerlink" title="树状数组的安全构造方式"></a>树状数组的安全构造方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算最小安全长度（为离散化后的数组保留空间）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSafeFenwickArraySize</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    nextPowerOf2 := <span class="number">1</span> &lt;&lt; bits.Len(<span class="type">uint</span>(n))</span><br><span class="line">    <span class="keyword">return</span> nextPowerOf2 + <span class="number">1</span> <span class="comment">// +1 处理边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题：315-计算右侧小于当前元素的个数"><a href="#例题：315-计算右侧小于当前元素的个数" class="headerlink" title="例题：315. 计算右侧小于当前元素的个数"></a>例题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/">315. 计算右侧小于当前元素的个数</a></h2><ul>
<li><strong>题意</strong>：返回数组 <code>counts</code>，其中 <code>counts[i]</code> 表示 <code>nums[i]</code> 右侧比它小的元素数量</li>
<li><strong>解法</strong>：树状数组 + 离散化优化空间</li>
</ul>
<h3 id="解题流程："><a href="#解题流程：" class="headerlink" title="解题流程："></a>解题流程：</h3><ol>
<li><p><strong>离散化</strong>：将原数组值映射到连续整数范围（防止值域过大）</p>
</li>
<li><p><strong>从后向前遍历</strong>：</p>
<ul>
<li>查询当前数 <strong>前面比它小</strong> 的数的出现次数 → <code>query(id - 1)</code></li>
<li>更新当前数出现次数 → <code>update(id)</code></li>
</ul>
</li>
<li><p><strong>树状数组操作时间复杂度：O(log n)</strong></p>
</li>
</ol>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 离散化映射：数值 -&gt; 索引</span></span><br><span class="line">    numToId := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> &#123;</span><br><span class="line">        set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            set[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(set))</span><br><span class="line">        <span class="keyword">for</span> num := <span class="keyword">range</span> set &#123;</span><br><span class="line">            a = <span class="built_in">append</span>(a, num)</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Ints(a)</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num := <span class="keyword">range</span> a &#123;</span><br><span class="line">            m[num] = i + <span class="number">1</span>  <span class="comment">// 从 1 开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;(nums)</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums)+<span class="number">5</span>)</span><br><span class="line">    lowBit := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    &#125;</span><br><span class="line">    query := <span class="function"><span class="keyword">func</span><span class="params">(pos <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        ret := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pos &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ret += c[pos]</span><br><span class="line">            pos -= lowBit(pos)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    update := <span class="function"><span class="keyword">func</span><span class="params">(pos <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> pos &lt; <span class="built_in">len</span>(c) &#123;</span><br><span class="line">            c[pos]++</span><br><span class="line">            pos += lowBit(pos)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        id := numToId[nums[i]]</span><br><span class="line">        ans[i] = query(id - <span class="number">1</span>)</span><br><span class="line">        update(id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><ul>
<li><p><strong>适用场景</strong>：支持区间查询 + 单点或区间修改等</p>
</li>
<li><p><strong>典型用途</strong>：</p>
<ul>
<li>区间最大值、最小值、区间和</li>
<li>区间赋值、区间加法（懒标记 &#x2F; Lazy Propagation）</li>
</ul>
</li>
<li><p><strong>结构特征</strong>：</p>
<ul>
<li>完全二叉树结构</li>
<li>每个节点维护一个区间的信息</li>
<li>父节点信息由左右子树合并而来</li>
</ul>
</li>
</ul>
<h2 id="例题：699-掉落的方块"><a href="#例题：699-掉落的方块" class="headerlink" title="例题：699. 掉落的方块"></a>例题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/description/">699. 掉落的方块</a></h2><ul>
<li>问题：模拟落方块过程，返回每一步的最高高度</li>
<li>典型的线段树区间最大值更新与查询问题</li>
</ul>
<h3 id="解题流程：-1"><a href="#解题流程：-1" class="headerlink" title="解题流程："></a>解题流程：</h3><ol>
<li><p><strong>离散化所有坐标</strong>：防止空间浪费（坐标最大值可达 10^9）</p>
</li>
<li><p><strong>使用线段树</strong>维护每个区间的最大高度</p>
</li>
<li><p><strong>每次插入一个方块</strong>：</p>
<ul>
<li>查询当前 <code>[left, right]</code> 区间的最大高度 <code>h</code></li>
<li>更新该区间的值为 <code>h + sideLength</code></li>
<li>记录全局最大高度</li>
</ul>
</li>
</ol>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="例题：684-冗余连接"><a href="#例题：684-冗余连接" class="headerlink" title="例题：684. 冗余连接"></a>例题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/description">684. 冗余连接</a></h2><ul>
<li>在含有一个环的无向图中找出一条可删边使其变为树</li>
</ul>
<h3 id="解题流程：-2"><a href="#解题流程：-2" class="headerlink" title="解题流程："></a>解题流程：</h3><ul>
<li>使用并查集判断边是否构成环：<ul>
<li>初始化每个节点为不同集合；<ul>
<li>遍历 edges 中每条边 (u, v)：<ul>
<li>如果 u 与 v 已在同一集合中，说明这条边构成环 → 返回它；</li>
<li>否则合并 u 和 v；</li>
</ul>
</li>
</ul>
</li>
<li>因为题目要求返回「最后构成环的边」，只需从前往后遍历一次即可。</li>
</ul>
</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRedundantConnection</span><span class="params">(edges [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    parent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(edges)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> parent &#123;</span><br><span class="line">        parent[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> find <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    find = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent[x] != x &#123;</span><br><span class="line">            parent[x] = find(parent[x])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    union := <span class="function"><span class="keyword">func</span><span class="params">(from, to <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x, y := find(from), find(to)</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent[x] = y</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> edges &#123;</span><br><span class="line">        <span class="keyword">if</span> !union(e[<span class="number">0</span>], e[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h3 id="基本性质与操作（以最大堆为例）"><a href="#基本性质与操作（以最大堆为例）" class="headerlink" title="基本性质与操作（以最大堆为例）"></a>基本性质与操作（以最大堆为例）</h3><ol>
<li><p>最大堆的性质</p>
<ul>
<li>最大堆是一种<strong>完全二叉树</strong>，满足每个父节点的值都<strong>大于或等于</strong>其左右子节点的值。</li>
<li>虽然逻辑结构为树，实际通常使用<strong>数组</strong>来实现。</li>
</ul>
</li>
<li><p>元素的插入与删除方式</p>
<ul>
<li><p><strong>插入新节点</strong>：将元素追加到数组末尾，然后进行<strong>向上调整（Sift-Up）</strong>，直到堆序性恢复。</p>
</li>
<li><p><strong>删除任意节点</strong>：将目标节点与数组最后一个元素交换，然后删除最后一个元素：</p>
<ul>
<li>若新值<strong>大于父节点</strong> → 进行<strong>向上调整</strong>；</li>
<li>若新值<strong>小于任一子节点</strong> → 进行<strong>向下调整</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊操作：删除堆顶（最大值）</p>
<ul>
<li>删除堆顶（即数组第一个元素）时，将最后一个元素移至根节点位置，再进行<strong>向下调整（Sift-Down）</strong>，以恢复堆的结构。</li>
</ul>
</li>
<li><p>时间复杂度分析</p>
<ul>
<li><p><strong>插入</strong>或<strong>删除</strong>操作中，最多需要调整一条从叶节点到根节点或从根节点到叶节点的路径，因此时间复杂度均为：</p>
<blockquote>
<p>✅ <strong>O(log n)</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>与二分查找的比较</p>
<ul>
<li><p><strong>二分查找</strong>的时间复杂度也是：</p>
<blockquote>
<p>✅ <strong>O(log n)</strong></p>
</blockquote>
</li>
<li><p>不过它依赖于<strong>有序数组</strong>，而最大堆只维护<strong>局部有序结构</strong>（即每个父节点大于子节点）。两者在原理和应用场景上存在本质区别。</p>
</li>
</ul>
</li>
</ol>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><ul>
<li><p>由两个部分组成：</p>
<ul>
<li><strong>顶点（Vertices）</strong>：图中的节点。</li>
<li><strong>边（Edges）</strong>：连接两个顶点的线段。</li>
</ul>
</li>
<li><p><strong>边用集合表示</strong>：一条边连接两个顶点，用 <code>&#123;A, B&#125;</code> 表示（不区分方向），区别于有向图中的 <code>(A, B)</code>。<br><strong>度（Degree）</strong>：一个顶点的度是连接它的边的数量（不考虑方向）。</p>
</li>
<li><p>无向图可以表示为：</p>
<ul>
<li>顶点：<code>&#123;A, B, C&#125;</code></li>
<li>边：<code>&#123;&#123;A, B&#125;, &#123;B, C&#125;&#125;</code></li>
</ul>
</li>
<li><p>图形示意：</p>
<ul>
<li><code>A —— B —— C</code></li>
</ul>
</li>
<li><p><strong>无向图的深度优先搜索（DFS）</strong></p>
<ul>
<li>从某个顶点开始；</li>
<li>标记为“已访问”；</li>
<li>遍历它的邻居；</li>
<li>对每一个未访问的邻居递归执行 DFS；</li>
<li>如果遇到没有未访问邻居的死胡同，则回退。</li>
</ul>
</li>
<li><p><strong>递归实现 DFS</strong>：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, start, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="built_in">print</span>(start)  <span class="comment"># 访问当前节点</span></span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[start]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(graph, neighbor, visited)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">dfs(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非递归实现（使用栈）</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_iterative</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    stack = [start]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 为了保持访问顺序，反转邻居顺序</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> <span class="built_in">reversed</span>(graph[node]):</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    stack.append(neighbor)</span><br><span class="line"></span><br><span class="line">dfs_iterative(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>无向图 DFS 的注意事项</strong>：</p>
<ul>
<li><strong>防止死循环</strong>：必须使用 <code>visited</code> 集合记录已访问节点，因为无向图的边是双向的，若不记录，会在 A-B-A-B 间无限循环。</li>
<li><strong>图不连通的情况</strong>：只对一个起点 DFS 无法遍历所有节点。可对所有节点进行一次 DFS。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_all</span>(<span class="params">graph</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(graph, node, visited)</span><br></pre></td></tr></table></figure>


<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="有向图的拓扑排序"><a href="#有向图的拓扑排序" class="headerlink" title="有向图的拓扑排序"></a>有向图的拓扑排序</h3><ul>
<li><p>拓扑排序（Topological Sorting）适用于 <strong>有向无环图（DAG，Directed Acyclic Graph）</strong>。其目标是将所有顶点排成一个线性序列，使得每条边 <code>u → v</code> 中，顶点 <code>u</code> 排在 <code>v</code> 的前面。</p>
</li>
<li><p>举例说明：</p>
<ul>
<li><strong>学习顺序</strong>：先学 A，再学 B，最后学 C。</li>
<li><strong>任务依赖</strong>：任务 B 必须在任务 A 完成后执行。</li>
<li>将任务抽象为节点，依赖关系为边，则问题转化为 DAG 的拓扑排序。</li>
</ul>
</li>
<li><p><strong>适用范围</strong>：</p>
<ul>
<li>必须是有向无环图（DAG）。</li>
<li>若图中存在环，则无法进行拓扑排序。</li>
</ul>
</li>
<li><p><strong>拓扑排序的两种常用算法</strong>：</p>
<ul>
<li><p><strong>方法一：Kahn 算法（入度表 + 队列）</strong></p>
<ul>
<li>统计所有顶点的入度。</li>
<li>将入度为 0 的顶点加入队列。</li>
<li>从队列中取出顶点 <code>u</code> 加入结果序列。</li>
<li>删除 <code>u</code> 指向的边（使相邻顶点 <code>v</code> 入度减 1）。</li>
<li>若 <code>v</code> 入度变为 0，加入队列。</li>
<li>重复以上过程直至队列为空。</li>
<li>若最终结果序列包含所有节点，则拓扑排序成功；否则图中存在环。</li>
</ul>
</li>
<li><p><strong>方法二：DFS 法（后序入栈）</strong></p>
<ul>
<li>从未访问的节点开始 DFS。</li>
<li>递归访问其所有后继节点。</li>
<li>当前节点所有后继访问完成后，将其压入栈中。</li>
<li>所有节点访问完成后，从栈顶依次弹出即为拓扑序列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>常见应用场景</strong>：</p>
<ul>
<li>编译器模块依赖分析</li>
<li>项目任务调度</li>
<li>数据处理管道排序</li>
<li>课程安排问题（Leetcode 207、210）</li>
</ul>
</li>
</ul>
<h3 id="Kahn-算法（Golang-实现）："><a href="#Kahn-算法（Golang-实现）：" class="headerlink" title="Kahn 算法（Golang 实现）："></a>Kahn 算法（Golang 实现）：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序（Kahn 算法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topologicalSort</span><span class="params">(graph <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">  inDegree := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化入度表</span></span><br><span class="line">  <span class="keyword">for</span> u := <span class="keyword">range</span> graph &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := inDegree[u]; !ok &#123;</span><br><span class="line">      inDegree[u] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> graph[u] &#123;</span><br><span class="line">      inDegree[v]++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入度为 0 的节点入队</span></span><br><span class="line">  <span class="keyword">var</span> queue []<span class="type">string</span></span><br><span class="line">  <span class="keyword">for</span> node, deg := <span class="keyword">range</span> inDegree &#123;</span><br><span class="line">    <span class="keyword">if</span> deg == <span class="number">0</span> &#123;</span><br><span class="line">      queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拓扑排序</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    node := queue[<span class="number">0</span>]</span><br><span class="line">    queue = queue[<span class="number">1</span>:]</span><br><span class="line">    result = <span class="built_in">append</span>(result, node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[node] &#123;</span><br><span class="line">      inDegree[neighbor]--</span><br><span class="line">      <span class="keyword">if</span> inDegree[neighbor] == <span class="number">0</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否存在环</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="built_in">len</span>(inDegree) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  graph := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;C&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;D&quot;</span>: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  order, ok := topologicalSort(graph)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;图中存在环，无法拓扑排序&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;拓扑排序结果：&quot;</span>, order)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Kahn 算法的核心逻辑</strong>：</p>
<ul>
<li>每次只处理入度为 0 的节点，即“无依赖”的任务。</li>
<li>处理后从图中移除该节点影响（即更新其邻接节点的入度）。</li>
<li>保证每个节点的依赖都先被处理。</li>
</ul>
</li>
<li><p><strong>为什么 Kahn 算法只适用于 DAG？</strong></p>
<ul>
<li>如果存在环，某些节点将永远无法变为入度 0，导致无法完成排序。</li>
<li>若排序结果节点数 &lt; 总节点数，说明图中存在环。</li>
</ul>
</li>
</ul>
<p>✅ <strong>因此：Kahn 算法不仅能进行拓扑排序，还能用于判断图中是否存在环。</strong></p>
<ul>
<li><strong>Kahn 算法实质上是 BFS 的变种</strong>，关注“入度为 0”的节点而不是“邻接点”。</li>
</ul>
<h3 id="Kahn-算法-vs-广度优先搜索（BFS）"><a href="#Kahn-算法-vs-广度优先搜索（BFS）" class="headerlink" title="Kahn 算法 vs 广度优先搜索（BFS）"></a>Kahn 算法 vs 广度优先搜索（BFS）</h3><table>
<thead>
<tr>
<th>项目</th>
<th>Kahn 算法（拓扑排序）</th>
<th>广度优先搜索（BFS）</th>
</tr>
</thead>
<tbody><tr>
<td>遍历方式</td>
<td>一层一层，按入度为 0 的点</td>
<td>一层一层，按邻接点</td>
</tr>
<tr>
<td>使用数据结构</td>
<td>队列（Queue）</td>
<td>队列（Queue）</td>
</tr>
<tr>
<td>访问顺序</td>
<td>所有无依赖的点先访问</td>
<td>当前点的所有邻居先访问</td>
</tr>
<tr>
<td>主要用途</td>
<td>拓扑排序 &#x2F; 检测环</td>
<td>遍历所有可达节点</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Kahn 算法 &#x3D; BFS 的拓扑排序版本</strong>，核心是基于“入度为 0”的节点层层推进，保证拓扑顺序合法。</p>
</blockquote>
<hr>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol>
<li><p><code>for lower &lt;= upper</code> —— <strong>闭区间版本 <code>[lower, upper]</code></strong></p>
<ul>
<li><p><code>mid = (lower + upper) / 2</code>（向下取整）</p>
<ul>
<li>如果 <code>mid</code> 满足条件（要往左找更小或更左的）：<code>upper = mid - 1</code></li>
<li>如果不满足条件（要往右找）：<code>lower = mid + 1</code></li>
</ul>
</li>
<li><p><strong>是否跳过了 mid？</strong></p>
<ul>
<li>表面上看，<code>upper = mid - 1</code> 似乎跳过了 <code>mid</code></li>
<li>实际上，<code>mid</code> 已经被判断过，<code>lower</code> 没变，下一轮中 <code>lower == mid</code></li>
<li>循环仍会继续执行，直到 <code>lower &gt; upper</code> 时退出</li>
</ul>
</li>
<li><p><strong>示例分析：</strong></p>
<ul>
<li>在数组 <code>[3, 4, 5]</code> 中查找“第一个大于等于 4 的数”</li>
<li>初始区间为 <code>[3, 5]</code>，<code>mid = 4</code></li>
<li><code>mid = 4</code> 满足条件 → <code>upper = 3</code></li>
<li>下一轮区间为 <code>[3, 3]</code>，<code>mid = 3</code></li>
<li><code>mid = 3</code> 不满足条件 → <code>lower = 4</code></li>
<li>区间变为 <code>[4, 3]</code>，循环结束</li>
<li>返回 <code>lower = 4</code>，即最小满足条件的值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>for lower &lt; upper</code> —— <strong>半开区间版本 <code>[lower, upper)</code></strong></p>
<ul>
<li>如果 <code>mid</code> 满足条件（要往左找）：<code>upper = mid</code></li>
<li>如果不满足条件：<code>lower = mid + 1</code></li>
<li>循环结束时 <code>lower == upper</code>，即为最小满足条件的位置</li>
</ul>
</li>
</ol>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>相邻元素两两比较并交换，使用双重循环；</li>
<li>若某次遍历中未发生任何交换，说明数组已有序，可提前结束；</li>
<li>代码示例：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        unChanged := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                unChanged = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> unChanged &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><p>通过一趟排序将序列划分为左右两个子区间，其中左边的元素都小于右边的元素，再分别对左右区间递归排序，从而实现整体有序。</p>
</li>
<li><p>分区逻辑说明（采用首元素为基准）：</p>
<ul>
<li>交替比较并交换元素值，最终确定基准值的位置；</li>
<li>每步都需判断 <code>low &lt; high</code>，不要遗漏；</li>
<li><code>high--</code> 与 <code>low++</code> 的条件是与 <code>temp</code>（基准值）进行比较。</li>
</ul>
</li>
<li><p>TopK 剪枝优化（用于只需前K个元素的场景）：</p>
<ul>
<li>若 <code>mid &gt; k</code>，递归处理左边；</li>
<li>若 <code>mid &lt; k</code>，递归处理右边。</li>
</ul>
</li>
<li><p>分区函数定义模板：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 首先从 high 开始比较，循环 high--，跳出后赋值；</span></span><br><span class="line">    <span class="comment">// 然后从 low 开始比较，同理；</span></span><br><span class="line">    <span class="comment">// 每步都要判断 low &lt; high；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>快速排序递归模板：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span></span><br><span class="line">quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span></span><br><span class="line">    quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid := partition(arr, start, end)</span><br><span class="line">        quick(arr, start, mid)</span><br><span class="line">        quick(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">    quick(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，low &lt; high 判断不要漏！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    temp := arr[low]</span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        <span class="keyword">for</span> low &lt; high &amp;&amp; arr[high] &gt;= temp &#123;</span><br><span class="line">            high--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">            arr[low] = arr[high]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> low &lt; high &amp;&amp; arr[low] &lt; temp &#123;</span><br><span class="line">            low++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">            arr[high] = arr[low]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = temp</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前K个最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSortTopK</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end, k <span class="type">int</span>)</span></span></span><br><span class="line">    quick = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>, start, end, k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid := partition(arr, start, end)</span><br><span class="line">        <span class="keyword">if</span> mid &gt; k &#123;</span><br><span class="line">            quick(arr, start, mid, k)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid &lt; k &#123;</span><br><span class="line">            quick(arr, mid+<span class="number">1</span>, end, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quick(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol>
<li>堆是一种<strong>完全二叉树结构</strong>；</li>
<li><strong>最大堆</strong>：父节点 ≥ 子节点；<strong>最小堆</strong>：父节点 ≤ 子节点；</li>
</ol>
<ul>
<li><p><strong>实现步骤</strong>：</p>
<ol>
<li><p><strong>调整堆（自上而下）</strong>：</p>
<ul>
<li>函数签名：<code>adjust(nums []int, root int, length int)</code></li>
<li>从当前根节点开始，比较左右子节点，找出较大者与根交换，递归向下直到无需调整。</li>
</ul>
</li>
<li><p><strong>初始化堆</strong>：</p>
<ul>
<li>从最后一个非叶子节点（<code>length/2</code>）开始，依次向上调整；</li>
</ul>
</li>
<li><p><strong>堆排序过程</strong>：</p>
<ul>
<li>每次将堆顶元素与末尾交换，再对堆顶进行调整；</li>
<li>排序范围逐步缩小，直到全部有序。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>最大堆调整函数</strong>：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">(nums []<span class="type">int</span>, root, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    child := root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child &lt; length &#123;</span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; length &amp;&amp; nums[child+<span class="number">1</span>] &gt; nums[child] &#123;</span><br><span class="line">            child++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[child] &lt;= nums[root] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[child], nums[root] = nums[root], nums[child]</span><br><span class="line">        root = child</span><br><span class="line">        child = root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化堆（自底向上）</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序过程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">        adjust(nums, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大堆取 TopK（前K大）且有序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSortTopK</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前K大元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="built_in">len</span>(nums)<span class="number">-1</span>-k; i-- &#123;</span><br><span class="line">        nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">        adjust(nums, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-k:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️注意事项：</p>
<ul>
<li>初始化堆：自底向上遍历构建，但每个节点的调整是自上而下；</li>
<li>排序时：堆顶与尾部交换，再调整堆顶；</li>
<li><code>adjust</code> 函数中需确保越界处理、优先选择较大子节点交换；</li>
</ul>
</blockquote>
<h1 id="贪心算法（Greedy）"><a href="#贪心算法（Greedy）" class="headerlink" title="贪心算法（Greedy）"></a>贪心算法（Greedy）</h1><ul>
<li><p><strong>贪心算法：通过局部最优解实现全局最优</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p>
<ul>
<li>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</li>
<li>判断你是否能够到达最后一个下标</li>
</ul>
</li>
<li><p>遍历数组，并实时维护「最远可以到达的位置」</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mostIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt;= mostIndex &#123;</span><br><span class="line">            mostIndex = max(mostIndex, i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> mostIndex &gt;= <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/">45. 跳跃游戏 II</a></p>
<ul>
<li>计算到达最后一个位置的最小跳跃次数</li>
</ul>
</li>
<li><p><strong>贪心 + 正向查找「可达的最远位置」</strong></p>
<ul>
<li>每次在当前跳跃的范围内，选择可以跳得最远的位置，作为下一跳的终点</li>
</ul>
</li>
<li><p><strong>贪心策略的正确性：</strong></p>
<ul>
<li>在当前跳跃范围内尽量跳得远，可以最大化下一跳的「选择空间」</li>
<li>避免走回头路或多跳一次的情况</li>
</ul>
</li>
<li><p><strong>为什么不遍历到最后一个元素？</strong></p>
<ul>
<li><p>跳到最后一个位置时，必然是在前一步完成跳跃</p>
</li>
<li><p>如果访问 <code>i == len(nums) - 1</code>，可能导致「多跳一步」</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    end, farthest := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    steps := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;</span><br><span class="line">            steps++</span><br><span class="line">            end = farthest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h1><ul>
<li><p><strong>动态规划的本质</strong>：通过<strong>穷举所有可能解法</strong>来寻找最优解。</p>
<ul>
<li>常见的穷举方式有两种：<strong>回溯算法</strong>和<strong>动态规划</strong>。回溯是暴力尝试每种可能，动态规划则利用<strong>状态转移方程</strong>推导各个状态。</li>
<li>动态规划相比暴力穷举更高效，其核心优势在于：<strong>利用状态转移 + 记忆</strong>，<strong>消除重复计算的子问题（重叠子问题）</strong>。</li>
</ul>
</li>
<li><p>动态规划问题通常具有大量<strong>重叠子问题</strong>，直接穷举效率极低，因此需借助以下两种优化方式：</p>
<ul>
<li>使用 <strong>备忘录（记忆化递归）</strong> 或 <strong>DP table（递推表格）</strong> 来<strong>避免重复计算</strong>；</li>
<li>其中，<strong>记忆化递归为自顶向下</strong>，<strong>DP table 为自底向上</strong>。</li>
</ul>
</li>
<li><p><strong>动态规划 &#x3D; 穷举 + 剪枝</strong></p>
</li>
<li><p>动态规划的标准解题流程：</p>
<ol>
<li>明确“<strong>状态</strong>”和“<strong>选择</strong>”；</li>
<li>定义 <code>dp</code> 数组或函数的含义；</li>
<li>写出<strong>状态转移方程（递推关系）</strong>。</li>
</ol>
</li>
<li><p>常通过<strong>状态压缩</strong>优化空间复杂度，例如将 <code>O(N^2)</code> 降为 <code>O(N)</code>。</p>
</li>
</ul>
<h2 id="背包问题（Knapsack）"><a href="#背包问题（Knapsack）" class="headerlink" title="背包问题（Knapsack）"></a>背包问题（Knapsack）</h2><h3 id="✅-分类依据：每个物品的使用次数是否受限"><a href="#✅-分类依据：每个物品的使用次数是否受限" class="headerlink" title="✅ 分类依据：每个物品的使用次数是否受限"></a>✅ 分类依据：<strong>每个物品的使用次数是否受限</strong></h3><table>
<thead>
<tr>
<th>问题类型</th>
<th>每种物品使用次数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0-1 背包问题</strong></td>
<td>最多使用一次</td>
<td>每件物品要么选，要么不选，不能重复使用。</td>
</tr>
<tr>
<td><strong>子集和问题</strong></td>
<td>最多使用一次</td>
<td>0-1 背包的特例：目标是恰好凑出某个和，而非最大价值。</td>
</tr>
<tr>
<td><strong>完全背包问题</strong></td>
<td>可无限次使用</td>
<td>每种物品可选多次，适用于硬币兑换、无限供给的资源选择等场景。</td>
</tr>
</tbody></table>
<h3 id="🎯-拓展理解："><a href="#🎯-拓展理解：" class="headerlink" title="🎯 拓展理解："></a>🎯 拓展理解：</h3><ul>
<li><strong>0-1 背包</strong> &#x3D; 最经典模型，用于资源受限问题。</li>
<li><strong>子集和问题</strong> &#x3D; 判断“是否可以凑出某个值”，不关心价值。</li>
<li><strong>完全背包</strong> &#x3D; 每种物品无限可选，常见于无限物品、找零等问题。</li>
</ul>
<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><ul>
<li><p><strong>题目描述</strong></p>
<ul>
<li>给定一个容量为 <code>W</code> 的背包，以及 <code>N</code> 个物品，每个物品有：重量 <code>wt[i]</code> 和价值 <code>val[i]</code></li>
<li>每种物品只能选择一次，求在不超过总容量 <code>W</code> 的前提下，最大可获得的总价值。</li>
</ul>
</li>
<li><p><strong>解题思路</strong></p>
<ul>
<li><p>状态定义：<code>dp[i][w]</code> 表示前 <code>i</code> 个物品中，容量为 <code>w</code> 的背包所能达到的最大价值。</p>
</li>
<li><p>状态转移：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w &lt; wt[i<span class="number">-1</span>]:</span><br><span class="line">    dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>初始化：</p>
<ul>
<li><code>dp[0][..] = 0</code>：没有物品可选，价值为 0；</li>
<li><code>dp[..][0] = 0</code>：背包容量为 0，价值也为 0。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(W <span class="type">int</span>, wt, val []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    N := <span class="built_in">len</span>(wt)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, N+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, W+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= N; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= W; w++ &#123;</span><br><span class="line">            <span class="keyword">if</span> w &lt; wt[i<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="子集背包问题（Subset-Sum）"><a href="#子集背包问题（Subset-Sum）" class="headerlink" title="子集背包问题（Subset Sum）"></a>子集背包问题（Subset Sum）</h3><ul>
<li><p><strong>Leetcode 416. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">分割等和子集</a></strong></p>
<ul>
<li>给定一个只包含正整数的非空数组 <code>nums</code>，判断是否可以将其分割为两个子集，且两个子集的元素和相等。</li>
<li>转换为背包问题：给一个容量为 <code>sum / 2</code> 的背包，判断是否可以从数组中选出若干数字恰好装满它。</li>
</ul>
</li>
<li><p><strong>解题思路</strong></p>
<ul>
<li>状态定义：<code>dp[i][j]</code> 表示前 <code>i</code> 个数中，是否存在子集和为 <code>j</code>。</li>
<li>状态转移：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i]]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>初始化：</p>
<ul>
<li><code>dp[..][0] = true</code>：背包容量为 0，总能装满；</li>
<li><code>dp[0][nums[0]] = true</code>：只有一个数且恰好等于容量；</li>
</ul>
</li>
<li><p>剪枝条件：</p>
<ul>
<li>若 <code>sum</code> 为奇数，直接返回 <code>false</code>；</li>
<li>若某元素大于 <code>sum / 2</code>，可提前跳过。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二维数组实现</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    N := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &#123;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; N; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= target; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; nums[i] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j - nums[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N<span class="number">-1</span>][target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>状态压缩：一维优化版本（倒序）</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j - num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包问题（Unbounded-Knapsack）"><a href="#完全背包问题（Unbounded-Knapsack）" class="headerlink" title="完全背包问题（Unbounded Knapsack）"></a>完全背包问题（Unbounded Knapsack）</h3><ul>
<li><p><strong>Leetcode 518. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">零钱兑换 II</a></strong></p>
<ul>
<li>给定一个背包容量为 <code>amount</code>，以及一个物品数组 <code>coins</code>（可重复使用），求有多少种不同的方法可以凑出该金额。</li>
</ul>
</li>
<li><p><strong>解题思路</strong></p>
<ul>
<li><p>状态定义：<code>dp[i][j]</code> 表示使用前 <code>i</code> 种硬币，凑出金额 <code>j</code> 的方法数。</p>
</li>
<li><p>状态转移：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j &lt; coins[i<span class="number">-1</span>]:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>初始化：</p>
<ul>
<li><code>dp[0][..] = 0</code>：没有硬币无法组成正金额；</li>
<li><code>dp[..][0] = 1</code>：金额为 0，只有 1 种凑法（什么都不选）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二维数组实现</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(coins)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; coins[i<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>一维数组优化（正序遍历）</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="keyword">for</span> j := coin; j &lt;= amount; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - coin]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li>适用于排列、组合、子集等构造类枚举问题</li>
</ul>
<h3 id="通用回溯模板总结"><a href="#通用回溯模板总结" class="headerlink" title="通用回溯模板总结"></a>通用回溯模板总结</h3><table>
<thead>
<tr>
<th>题型</th>
<th>递归参数</th>
<th>关键点</th>
<th>重复处理策略</th>
<th>代码模板示例（Go 伪码简化）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>排列（Permutation）</strong></td>
<td>无需起点</td>
<td>需要标记已使用元素 <code>used[]</code></td>
<td>排序 + <code>used</code> + 跳过相邻重复元素</td>
<td>见 <em>排列 II</em> 模板</td>
</tr>
<tr>
<td><strong>组合 &#x2F; 子集（Combination &#x2F; Subset）</strong></td>
<td>需要起点</td>
<td>控制遍历起点，防止重复使用前面元素</td>
<td>排序 + 跳过同层相邻重复元素</td>
<td>见 <em>组合 II &#x2F; 子集 II</em> 模板</td>
</tr>
</tbody></table>
<h2 id="1-排列（Permutation）"><a href="#1-排列（Permutation）" class="headerlink" title="1. 排列（Permutation）"></a>1. 排列（Permutation）</h2><h3 id="1-1-无重复元素-—-基础排列（46-全排列）"><a href="#1-1-无重复元素-—-基础排列（46-全排列）" class="headerlink" title="1.1 无重复元素 — 基础排列（46. 全排列）"></a>1.1 无重复元素 — 基础排列（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-有重复元素-—-排列-II（47-全排列-II）"><a href="#1-2-有重复元素-—-排列-II（47-全排列-II）" class="headerlink" title="1.2 有重复元素 — 排列 II（47. 全排列 II）"></a>1.2 有重复元素 — 排列 II（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a>）</h3><ul>
<li><p>相较于 46，需增加：</p>
<ul>
<li>排序以便判断相邻重复</li>
<li>重复剪枝：跳过已访问前一个相同元素</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只能先用同一组重复数字的“第一个”，不能先用后面的。</span></span><br><span class="line">			<span class="comment">//如果现在选择了后一个重复元素，就会导致重复排列。</span></span><br><span class="line">			<span class="comment">//!used[i-1]表明前一个相同的还没用，所以你这边就别先用了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !used[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-组合-x2F-子集（Combination-x2F-Subset）"><a href="#2-组合-x2F-子集（Combination-x2F-Subset）" class="headerlink" title="2. 组合 &#x2F; 子集（Combination &#x2F; Subset）"></a>2. 组合 &#x2F; 子集（Combination &#x2F; Subset）</h2><blockquote>
<p>本质都是选取元素的子集，区别主要在题意和输出要求。</p>
</blockquote>
<h3 id="2-1-无重复元素-—-子集-I（78-子集）"><a href="#2-1-无重复元素-—-子集-I（78-子集）" class="headerlink" title="2.1 无重复元素 — 子集 I（78. 子集）"></a>2.1 无重复元素 — 子集 I（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-有重复元素-—-子集-II（90-子集-II）"><a href="#2-2-有重复元素-—-子集-II（90-子集-II）" class="headerlink" title="2.2 有重复元素 — 子集 II（90. 子集 II）"></a>2.2 有重复元素 — 子集 II（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a>）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集的另一种方式：不使用-for-循环（显式选与不选）"><a href="#子集的另一种方式：不使用-for-循环（显式选与不选）" class="headerlink" title="子集的另一种方式：不使用 for 循环（显式选与不选）"></a>子集的另一种方式：不使用 for 循环（显式选与不选）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsDfs</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> set []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(cur <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), set...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择当前</span></span><br><span class="line">        set = <span class="built_in">append</span>(set, nums[cur])</span><br><span class="line">        dfs(cur + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        set = set[:<span class="built_in">len</span>(set)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 不选择当前</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><table>
<thead>
<tr>
<th>特征</th>
<th>排列（Permutation）</th>
<th>组合 &#x2F; 子集（Combination &#x2F; Subset）</th>
</tr>
</thead>
<tbody><tr>
<td>是否用 <code>used</code></td>
<td>是</td>
<td>否（一般）</td>
</tr>
<tr>
<td>是否排序</td>
<td>有重复元素时必须排序</td>
<td>同左</td>
</tr>
<tr>
<td>是否有起点参数</td>
<td>无需（但可选）</td>
<td>必须有，通常为 <code>start</code></td>
</tr>
<tr>
<td>去重策略</td>
<td><code>i &gt; 0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1]</code></td>
<td><code>i &gt; start &amp;&amp; nums[i]==nums[i-1]</code> 跳过</td>
</tr>
<tr>
<td>递归形式</td>
<td><code>dfs()</code> &#x2F; <code>dfs(index)</code></td>
<td><code>dfs(start int)</code></td>
</tr>
</tbody></table>
<h2 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h2><ul>
<li><p><strong>全局变量 vs 参数传递：</strong></p>
<ul>
<li>全局变量：书写更简洁，多个函数共享更方便。</li>
<li>参数传递：封装更清晰，递归状态更独立，减少副作用。</li>
</ul>
</li>
<li><p><strong>for 循环的角色：</strong></p>
<ul>
<li>回溯中 for 循环用于枚举“选项”。</li>
<li>不要在 for 中处理“不选”的逻辑，不然会重复或乱序。</li>
</ul>
</li>
</ul>
<h2 id="举例：组合总和（39-Combination-Sum）"><a href="#举例：组合总和（39-Combination-Sum）" class="headerlink" title="举例：组合总和（39. Combination Sum）"></a>举例：组合总和（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a>）</h2><ul>
<li>元素可重复使用，需遍历所有可行组合</li>
</ul>
<h4 id="✅-推荐写法：for-中只做“选”的动作"><a href="#✅-推荐写法：for-中只做“选”的动作" class="headerlink" title="✅ 推荐写法：for 中只做“选”的动作"></a>✅ 推荐写法：for 中只做“选”的动作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, target <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> target &gt;= candidates[i] &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">                dfs(i, target - candidates[i])</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="🚫-不推荐写法：用“选-x2F-不选”逻辑递归（逻辑复杂，易错）"><a href="#🚫-不推荐写法：用“选-x2F-不选”逻辑递归（逻辑复杂，易错）" class="headerlink" title="🚫 不推荐写法：用“选&#x2F;不选”逻辑递归（逻辑复杂，易错）"></a>🚫 不推荐写法：用“选&#x2F;不选”逻辑递归（逻辑复杂，易错）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index, target <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(candidates) || target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选当前</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, candidates[index])</span><br><span class="line">        dfs(index, target - candidates[index])</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 不选当前</span></span><br><span class="line">        dfs(index + <span class="number">1</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS-模板的两种核心模式"><a href="#DFS-模板的两种核心模式" class="headerlink" title="DFS 模板的两种核心模式"></a>DFS 模板的两种核心模式</h2><h3 id="模式一：组合型问题（需-for-循环）"><a href="#模式一：组合型问题（需-for-循环）" class="headerlink" title="模式一：组合型问题（需 for 循环）"></a>模式一：<strong>组合型问题（需 for 循环）</strong></h3><ul>
<li>子集、组合、排列等</li>
<li>每一步从当前位置开始向后枚举选项</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">    dfs(i + <span class="number">1</span>)</span><br><span class="line">    path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式二：构造型问题（不需-for-循环）"><a href="#模式二：构造型问题（不需-for-循环）" class="headerlink" title="模式二：构造型问题（不需 for 循环）"></a>模式二：<strong>构造型问题（不需 for 循环）</strong></h3><ul>
<li>例如：电话号码字母组合、迷宫路径、树遍历等</li>
<li>每层只能处理一个“位置”的合法选项，当前层不枚举后面</li>
</ul>
<h4 id="示例：17-电话号码的字母组合"><a href="#示例：17-电话号码的字母组合" class="headerlink" title="示例：17. 电话号码的字母组合"></a>示例：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    phoneMap := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&#x27;2&#x27;</span>: <span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&quot;def&quot;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&quot;ghi&quot;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>: <span class="string">&quot;mno&quot;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&quot;pqrs&quot;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&quot;tuv&quot;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>, str <span class="type">string</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>, str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, ch := <span class="keyword">range</span> phoneMap[<span class="type">rune</span>(digits[index])] &#123;</span><br><span class="line">            dfs(index + <span class="number">1</span>, str + <span class="type">string</span>(ch))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结结构图"><a href="#总结结构图" class="headerlink" title="总结结构图"></a>总结结构图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回溯问题分类</span><br><span class="line">├── 排列类：顺序重要，used + path</span><br><span class="line">├── 组合类：顺序不重要，start 起点控制，元素不可重复</span><br><span class="line">├── 子集类：所有组合（选 or 不选）</span><br><span class="line">└── 构造类：必须填满所有位置，如数字组合/字符串构造等</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ 判断是否需要 for：是否在当前层“枚举选项”</p>
<ul>
<li>有枚举（子集&#x2F;组合&#x2F;排列）：需要 <code>for</code></li>
<li>无枚举（构造型）：不需要 <code>for</code></li>
</ul>
</blockquote>
<hr>
<h1 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h1><h2 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h2><ul>
<li><p><strong>不要求有序</strong>：使用快速选择算法（基于快速排序思想）；也可以使用堆结构</p>
</li>
<li><p><strong>要求有序</strong>：使用堆</p>
<ul>
<li>最大堆：用于求前 K 个最大值</li>
<li>最小堆：用于求前 K 个最小值</li>
</ul>
</li>
</ul>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><ul>
<li><strong>19. 删除链表的倒数第 N 个节点</strong><br>快指针先走 N 步，然后快慢指针一起前进，快指针到达末尾时，慢指针刚好指向待删除节点的前一个节点</li>
<li><strong>141. 环形链表</strong><br>快慢指针，快指针每次走两步，慢指针每次走一步；若存在环，两者最终会相遇</li>
<li><strong>142. 环形链表 II</strong><br>快慢指针相遇后，快指针从头开始，慢指针继续前进；再次相遇点即为入环点</li>
<li><strong>234. 回文链表</strong><br>快慢指针找到链表中点，同时将前半部分链表原地反转；再从中点与反转后的链表逐一比较，判断是否回文</li>
<li><strong>287. 寻找重复数</strong><br>使用 Floyd 判圈算法，将数组视为链表结构；第一次快慢指针相遇后，将其中一个指针重新指向起点，两个指针再次相遇时即为重复数字（环的入口）</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li><strong>160. 相交链表</strong><br>两指针分别从两个链表头出发，走到末尾后切换至对方链表头继续走；若相交，则最终会在交点相遇；若无交点，则会同时为 <code>null</code> 结束</li>
</ul>
<hr>
<h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><p><strong>146. LRU 缓存</strong>（<code>HashMap + 双向链表</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    data     <span class="keyword">map</span>[<span class="type">int</span>]*LinkedNode</span><br><span class="line">    head     *LinkedNode</span><br><span class="line">    tail     *LinkedNode</span><br><span class="line">    count    <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="type">int</span></span><br><span class="line">    val  <span class="type">int</span></span><br><span class="line">    pre  *LinkedNode</span><br><span class="line">    next *LinkedNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>data</code>: 使用 HashMap 存储 key 与节点指针的映射</li>
<li><code>双向链表</code>: 头部表示最近访问节点，新加入或访问的节点会被移动到头部，尾部为最久未使用节点，便于淘汰</li>
</ul>
</li>
<li><p><strong>460. LFU 缓存</strong>（<code>双 Hash + 双向链表</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToValFreq   <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    freqToKeysHead <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    freqToKeysTail <span class="keyword">map</span>[<span class="type">int</span>]*LFUNode</span><br><span class="line">    minFreq        <span class="type">int</span></span><br><span class="line">    capacity       <span class="type">int</span></span><br><span class="line">    size           <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="type">int</span></span><br><span class="line">    val  <span class="type">int</span></span><br><span class="line">    freq <span class="type">int</span></span><br><span class="line">    pre  *LFUNode</span><br><span class="line">    next *LFUNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>keyToValFreq</code>: 记录每个 key 的值和频率</li>
<li><code>freqToKeys</code>: 按照频率映射到对应频率的链表（内部按 LRU 顺序）</li>
<li><code>minFreq</code>: 当前缓存中的最小访问频率</li>
<li>注意 <code>put</code> 操作中若 key 已存在，需要更新其值和频率！</li>
</ul>
</li>
</ul>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><ul>
<li><p><strong>198. 打家劫舍</strong>（相邻房屋不能偷）</p>
<ul>
<li>动态规划</li>
<li><code>dp[i]</code> 表示前 <code>i</code> 间房屋能偷到的最大金额</li>
<li>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></li>
</ul>
</li>
<li><p><strong>213. 打家劫舍 II</strong>（房屋围成一圈）</p>
<ul>
<li>环状结构，首尾不能同时选择</li>
<li>拆分为两种情况：<code>(0, n-2)</code> 和 <code>(1, n-1)</code>，分别计算最大值，取较大者</li>
</ul>
</li>
<li><p><strong>2560. 打家劫舍 IV</strong>（给定偷 <code>k</code> 间房的条件，求最小窃取能力）</p>
<ul>
<li>题考的是：在不能偷相邻房子的条件下，选择至少 k 个房子，求所有方案中「最大金额最小」的那种偷法的最大单间金额（即窃取能力）的最小值。  </li>
<li>二分 + 贪心</li>
<li>在 <code>[min(nums), max(nums)]</code> 范围内二分 <code>x</code>，判断是否存在方案在不相邻的前提下偷到 <code>k</code> 间房且每间 ≤ <code>x</code></li>
<li>最小可行的 <code>x</code> 即为答案</li>
</ul>
</li>
<li><p><strong>337. 打家劫舍 III</strong>（树形结构）</p>
<ul>
<li>二叉树结构，不能偷父子节点</li>
<li>返回两个值：偷当前节点与不偷当前节点的最大值</li>
<li>后序遍历递归实现</li>
</ul>
</li>
</ul>
<h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><ul>
<li><p><strong>207. 课程表</strong></p>
<ul>
<li>判断有向图是否存在环</li>
<li>使用拓扑排序（Kahn 算法）</li>
<li>若排序后的节点数 <code>== numCourses</code>，说明可完成全部课程</li>
</ul>
</li>
</ul>
<h2 id="会议室"><a href="#会议室" class="headerlink" title="会议室"></a>会议室</h2><ul>
<li><p><strong>253. 会议室 II</strong>（计算最少需要多少间会议室）</p>
<ul>
<li>将所有会议按开始时间排序</li>
<li>使用最小堆记录正在进行的会议的结束时间</li>
<li>遇到新的会议时，检查是否能复用已结束的会议室</li>
<li>最后堆的大小即为最少会议室数</li>
</ul>
</li>
<li><p><strong>2402. 会议室 III</strong>（找出被安排次数最多的会议室编号）（如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 相同 ）</p>
<ul>
<li><p>所有会议按开始时间排序</p>
</li>
<li><p>构造两个最小堆：</p>
<ul>
<li>空闲会议室（按编号）</li>
<li>占用会议室（按结束时间 + 编号）</li>
</ul>
</li>
<li><p>每轮会议安排时：</p>
<ul>
<li>如果无空闲会议室，则延期</li>
<li>记录每个会议室的使用次数</li>
</ul>
</li>
<li><p>最终返回使用次数最多的会议室中编号最小者</p>
</li>
</ul>
</li>
</ul>
<h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><ul>
<li><strong>309. 最佳买卖股票时机含冷冻期</strong><ul>
<li><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
</li>
<li><p>三种状态转移：</p>
<ul>
<li><code>f[i][0]</code>: 第 i 天持有股票</li>
<li><code>f[i][1]</code>: 第 i 天卖出股票（进入冷冻期）</li>
<li><code>f[i][2]</code>: 第 i 天未持股（非冷冻期）</li>
</ul>
</li>
<li><p>状态转移方程：</p>
<ul>
<li><code>f[i][0] = max(f[i-1][0], f[i-1][2] - prices[i])</code></li>
<li><code>f[i][1] = f[i-1][0] + prices[i]</code></li>
<li><code>f[i][2] = max(f[i-1][1], f[i-1][2])</code></li>
</ul>
</li>
<li><p>最终答案：<code>max(f[n-1][1], f[n-1][2])</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h2><ul>
<li><p><strong>887. 鸡蛋掉落</strong></p>
<ul>
<li><p>给定 <code>k</code> 个鸡蛋和 <code>n</code> 层楼，找出确定临界楼层所需的最少操作次数（最坏情况下）</p>
</li>
<li><p>定义：<code>f(t, k)</code> 表示在最多尝试 <code>t</code> 次、拥有 <code>k</code> 个鸡蛋的情况下，最多能测试的楼层数</p>
<ul>
<li>转移方程：<code>f(t, k) = 1 + f(t-1, k-1) + f(t-1, k)</code></li>
</ul>
</li>
<li><p>最终寻找最小的 <code>t</code>，使得 <code>f(t, k) &gt;= n</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superEggDrop</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j++ &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j++ &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[i][k] &gt;= n &#123;</span><br><span class="line">            ans = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>学习总被寄予理解的希望，现实却常逼我们回归重复与记忆的路径。掌握技巧、熟悉模板，也许并不光鲜，却是应对复杂世界最有效的方式之一。</li>
<li>然而熟练，何尝不是另一种形式的“背”呢。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/05/31/20250531-ren-gong-zhi-neng-yi-ci-shi-fou-zhun-que-yi-ci-guan-yu-ai-ben-zhi-de-fan-si/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/31/20250531-ren-gong-zhi-neng-yi-ci-shi-fou-zhun-que-yi-ci-guan-yu-ai-ben-zhi-de-fan-si/" itemprop="url">“人工智能”一词是否准确？一次关于AI本质的反思</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-31T00:22:28+08:00">
                2025-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>AI – “基于数据的规律发现系统”</p>
</blockquote>
</blockquote>
<ul>
<li>“人工智能（AI）”这个名字，其实是一种历史性命名，也是一种拟人化的表达。它给人一种错觉，仿佛机器在模仿或复制人类的智能。然而，从技术本质上看，今天的人工智能主要依赖于数据驱动的模式识别和规律学习，更准确地说，它是一种“基于数据的规律发现系统”。无论是人类还是机器，学习的对象都是客观存在的规律，只是各自的方法不同。规律本身并不依赖于学习者，它们存在于自然和社会系统之中，等待被发现。机器学习的意义，不在于赋予机器“像人一样的智能”，而在于它可以在极大规模和复杂度下识别人类难以企及的模式，这种能力甚至在某些领域已经超越了人类。然而，AI虽能拟合规律，却不具备理解、动机和意识，因此我们说它“智能”仍属工程性描述，而非哲学意义上的智能。从这个角度看，“人工智能”这一术语在一定程度上是误导性的，如果要更准确地描述其本质，也许“规律学习系统”或“模式发现机器”更贴切，但这类表述在传播和产业化上显然不如“AI”简洁有力。因此，当前的术语是一种权衡：技术准确性让位于传播效率。我们需要清醒地认识到，AI不是在“思考”，它只是以统计和优化的方式，从数据中提取规律，并按特定目标进行预测或生成。</li>
</ul>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><pre>
AI这个名字其实并不准确
人工智能
其实是通过数据来学习规律
跟人没有关系
只是人或机器用他们的方式去学习，
不管你人类或机器学不学习
规律就在那里，只是表现形式不一样，但规律的本质是一样的，
而且有些规律人类也学不会，超过人的能力
所以叫人工智能是片面的表达
应该叫智能规律，或规律学习？


——

当然，以下是对原文的整理和简要总结：

⸻

整理后的表达：

“人工智能（AI）”这个名称其实并不准确。所谓人工智能，本质上只是通过数据来学习和提取规律的过程，与人类的思维或意识没有直接关系。无论是人还是机器，学习的只是客观存在的规律，而这些规律本身独立于学习主体，始终存在，只是表现形式不同而已。

机器和人只是用不同的方式去接近这些规律，有些规律甚至超出了人类的认知能力，只有机器才能捕捉到。因此，用“人工智能”来命名这种技术是片面的，更准确的表达也许应该是“智能规律”或“规律学习”。

⸻

简要总结观点：

这段文字认为，“人工智能”这一术语带有误导性，因为它强调了“人”而忽略了技术的本质：对客观规律的学习和拟合。作者主张，AI其实是一种“规律学习”系统，不应被简单等同于模仿人类智能。

</pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>





          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">180</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
