<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="为啥不吃三文鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="为啥不吃三文鱼">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/"/>





  <title>拉巴力的纸皮箱</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/12/20200912-fen-bu-shi-yi-zhi-xing-xie-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/12/20200912-fen-bu-shi-yi-zhi-xing-xie-yi/" itemprop="url">分布式一致性协议概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-12T21:30:00+08:00">
                2020-09-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/12/20200912-fen-bu-shi-yi-zhi-xing-xie-yi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/12/20200912-fen-bu-shi-yi-zhi-xing-xie-yi/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>本文内容基本来源：网上资料总结</li>
</ul>
<h2 id="共识（Consensus）-和-一致性（Consistency）"><a href="#共识（Consensus）-和-一致性（Consistency）" class="headerlink" title="共识（Consensus） 和 一致性（Consistency）"></a>共识（Consensus） 和 一致性（Consistency）</h2><ul>
<li>分布式一致性（共识）协议 (consensus protocol)</li>
<li>Consensus !&#x3D; Consistency</li>
<li>CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题</li>
<li>在早些的文献中，共识（consensus）也叫做协商（agreement）</li>
<li>共识（Consensus），很多时候会见到与一致性（Consistency）术语放在一起讨论。严谨地讲，两者的含义并不完全相同。</li>
<li>一致性的含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。具体到分布式系统场景下，一致性指的是多个副本对外呈现的状态。如前面提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。而共识，则特指在分布式系统中多个节点之间对某个事情（例如多个事务请求，先执行谁？）达成一致意见的过程。因此，达成某种共识并不意味着就保障了一致性。</li>
<li>实践中，要保证系统满足不同程度的一致性，往往需要通过共识算法来达成。</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KKrxuVCrjlXXWMPTXQ-fvA">分布式之系统底层原理</a></li>
</ul>
<h2 id="共识问题"><a href="#共识问题" class="headerlink" title="共识问题"></a>共识问题</h2><ul>
<li>在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,…, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：<ul>
<li>终止性（Termination）：所有正确的进程最终都会认同某一个值。</li>
<li>协定性（Agreement）：所有正确的进程认同的值都是同一个值。</li>
<li>完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。</li>
</ul>
</li>
<li>完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。</li>
<li>算法共识&#x2F;一致性算法有两个最核心的约束：1) 安全性（Safety），2) 存活性（Liveness）：<ul>
<li>Safety：保证决议（Value）结果是对的，无歧义的，不会出现错误情况。<ul>
<li>只有是被提案者提出的提案才可能被最终批准；</li>
<li>在一次执行中，只批准（chosen）一个最终决议。被多数接受（accept）的结果成为决议；</li>
</ul>
</li>
<li>Liveness：保证决议过程能在有限时间内完成。<ul>
<li>决议总会产生，并且学习者最终能获得被批准的决议。</li>
</ul>
</li>
</ul>
</li>
<li>根据解决的场景是否允许拜占庭（Byzantine）错误，共识算法可以分为 Crash Fault Tolerance (CFT) 和 Byzantine Fault Tolerance（BFT）两类。<ul>
<li>对于非拜占庭错误的情况，已经存在不少经典的算法，包括 Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</li>
<li>对于要能容忍拜占庭错误的情况，包括 PBFT（Practical Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1997 年）为代表的概率算法等。确定性算法一旦达成共识就不可逆转，即共识是最终结果；而概率类算法的共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。拜占庭类容错算法往往性能较差，容忍不超过 1&#x2F;3 的故障节点。</li>
</ul>
</li>
<li>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized)副本控制协议”。</li>
</ul>
<h2 id="分布式系统的几个主要难题"><a href="#分布式系统的几个主要难题" class="headerlink" title="分布式系统的几个主要难题"></a>分布式系统的几个主要难题</h2><ol>
<li>网络问题</li>
<li>时钟问题</li>
<li>节点故障问题</li>
</ol>
<h2 id="达成共识还可以解决分布式系统中的以下经典问题"><a href="#达成共识还可以解决分布式系统中的以下经典问题" class="headerlink" title="达成共识还可以解决分布式系统中的以下经典问题"></a>达成共识还可以解决分布式系统中的以下经典问题</h2><ol>
<li>互斥（Mutual exclusion）：哪个进程进入临界区访问资源？</li>
<li>选主（Leader election）：在单主复制的数据库，需要所有节点就哪个节点是领导者达成共识。如果一些由于网络故障而无法与其他节点通信，可能会产生两个领导者，它们都会接受写入，数据就可能会产生分歧，从而导致数据不一致或丢失。</li>
<li>原子提交（Atomic commit）：跨多节点或跨多分区事务的数据库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护这种事务的原子性，必须让所有节点对事务的结果达成共识：要么全部提交，要么全部中止&#x2F;回滚。</li>
</ol>
<ul>
<li>总而言之，在共识的帮助下，分布式系统就可以像单一节点一样工作——所以共识问题是分布式系统最基本的问题。</li>
</ul>
<h2 id="FLP-不可能（FLP-Impossibility）"><a href="#FLP-不可能（FLP-Impossibility）" class="headerlink" title="FLP 不可能（FLP Impossibility）"></a>FLP 不可能（FLP Impossibility）</h2><ul>
<li>早在 1985 年，Fischer、Lynch 和 Paterson （FLP）在 “Impossibility of Distributed Consensus with One Faulty Process[5]” 证明了：在一个异步系统中，即使只有一个进程出现了故障，也没有算法能保证达成共识。</li>
<li>简单来说，因为在一个异步系统中，进程可以随时发出响应，所以没有办法分辨一个进程是速度很慢还是已经崩溃，这不满足终止性（Termination）。</li>
<li>FLP给后来的人们提供了研究的思路——不再尝试寻找异步通信系统中共识问题完全正确的解法。FLP 不可能是指无法确保达成共识，并不是说如果有一个进程出错，就永远无法达成共识。</li>
</ul>
<h2 id="同步系统中的共识"><a href="#同步系统中的共识" class="headerlink" title="同步系统中的共识"></a>同步系统中的共识</h2><ul>
<li>Dolev 和 Strong 在论文 “Authenticated Algorithms for Byzantine Agreement[9]” 中证明了：同步系统中，如果 N 个进程中最多有 f 个会出现崩溃故障，那么经过 f + 1 轮消息传递后即可达成共识。</li>
<li>在一个有 f 个拜占庭故障节点的系统中，必须总共至少有 3f + 1 个节点才能够达成共识。即 N &gt;&#x3D; 3f + 1。</li>
<li>虽然同步系统下拜占庭将军问题的确存在解，但是代价很高，需要 O(N^f+1 ) 的信息交换量，只有在那些安全威胁很严重的地方使用（例如：航天工业）</li>
<li>PBFT(Practical Byzantine Fault Tolerance)[12] 算法顾名思义是一种实用的拜占庭容错算法，由 Miguel Castro 和 Barbara Liskov 发表于 1999 年。</li>
<li>算法的主要细节不再展开。PBFT 也是通过使用同步假设保证活性来绕过 FLP 不可能。PBFT 算法容错数量同样也是 N &gt;&#x3D; 3f + 1，但只需要 O(n^2 ) 信息交换量，即每台计算机都需要与网络中其他所有计算机通讯。</li>
</ul>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><ul>
<li>一致性（Consistency）是指多副本（Replications）问题中的数据一致性。</li>
</ul>
<ol>
<li>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</li>
</ol>
<ul>
<li>分布式中一致性是非常重要的，分为弱一致性和强一致性。现在主流的一致性协议一般都选择的是弱一致性的特殊版本：最终一致性。</li>
</ul>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><ul>
<li>CAP是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个要素最多只能同时实现两点，不可能三者兼顾。</li>
<li>CAP理论提出就是针对分布式环境的，所以，P 这个属性是必须具备的。</li>
</ul>
<ol>
<li>Consistency 一致性<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。等同于所有节点拥有数据的最新版本。<br>CAP中的C指的是强一致性。</li>
<li>Availability 可用性<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。如果不考虑一致性，这个是很好实现的，立即返回本地节点的数据即可，而不需要等到数据一致才返回。</li>
<li>Partition Tolerance 分区容忍性<br>Tolerance也可以翻译为容错，分区容忍性具体指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即系统容忍网络出现分区，分区之间网络不可达的情况，分区容忍性和扩展性紧密相关，Partition Tolerance特指在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
</ol>
<ul>
<li><p>传统数据库都是假设不保证P的，因为传统数据库都是单机或者很小的本地集群，假设网络不存在问题，出现问题手工修复。所以，损失分区容错(P)只保证CA相当于就是一个单体应用，根本不是分布式。</p>
</li>
<li><p>分布式是要求单个节点故障(概率太高了)系统仍能完成运行。搭建分布式就是间接要求必须保证P，即P是现实，那C和A就无法同时做到，需要在这两者之间做平衡。</p>
</li>
<li><p>像银行系统，是通过损失可用性(A)来保障CP，银行系统是内网，很少出现分区不可达故障状态，一旦出现，不可达的节点对应的ATM就没法使用，即变为不可用。同时如果数据在各分区未达到一致，ATM也是Loading状态即不可用。</p>
</li>
<li><p>在互联网实践中，可用性又是极其重要的，因此大部分是通过损失一致性(C)来保障AP，当然也非完全牺牲一致性，使用弱一致性，即一定时间后一致的弱一致性，当数据还在同步时(WRITE之后)，使用上一次的数据。</p>
</li>
<li><p>Google 2009年 在Transaction Across DataCenter 的分享中，对一致性协议在业内的实践做了一简单的总结，如下图所示，这是 CAP 理论在工业界应用的实践经验。<br><img src="/2020/09/12/20200912-fen-bu-shi-yi-zhi-xing-xie-yi/cap-sumarry.png"></p>
</li>
</ul>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><ul>
<li>Basically Available（基本可用）</li>
<li>Soft state（软状态）</li>
<li>Eventually consistent（最终一致性）</li>
</ul>
<ul>
<li>BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</li>
<li>BASE理论是对大规模的互联网分布式系统实践的总结，用弱一致性来换取可用性，不同于ACID，属于AP系统。</li>
</ul>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>ACID（Atomicity原子性，Consistency一致性，Isolation隔离性，Durability持久性）是事务的特点，具有强一致性，一般用于单机事务，分布式事务若采用这个原则会丧失一定的可用性，属于CP系统。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按单主和多主进行分类"><a href="#按单主和多主进行分类" class="headerlink" title="按单主和多主进行分类"></a>按单主和多主进行分类</h3><ol>
<li>单主协议，即整个分布式集群中只存在一个主节点。主备复制、2PC、 Paxos、Raft、ZAB。<ul>
<li>（不允许数据分歧）：整个分布式系统就像一个单体系统，所有写操作都由主节点处理并且同步给其他副本。</li>
</ul>
</li>
<li>多主协议，即整个集群中不只存在一个主节点。Pow、Gossip协议。<ul>
<li>（允许数据分歧）：所有写操作可以由不同节点发起，并且同步给其他副本。</li>
</ul>
</li>
</ol>
<ul>
<li>单主协议由一个主节点发出数据，传输给其余从节点，能保证数据传输的有序性。而多主协议则是从多个主节点出发传输数据，传输顺序具有随机性，因而数据的有序性无法得到保证，只保证最终数据的一致性。这是单主协议和多主协议之间最大的区别。</li>
</ul>
<pre>
－－－单主－－主备复制、2PC、 Paxos、Raft、ZAB
｜
－－－多主－－Pow、Gossip
</pre>

<h3 id="按CAP中的P分类"><a href="#按CAP中的P分类" class="headerlink" title="按CAP中的P分类"></a>按CAP中的P分类</h3><ul>
<li>分区容忍的一致性协议跟所有的单主协议一样，它也是只有一个主节点负责写入（提供顺序一致性），但它跟 2PC 的区别在于它只需要保证大多数节点（一般是超过半数）达成一致就可以返回客户端结果，这样可以提高了性能，同时也能容忍网络分区（少数节点分区不会导致整个系统无法运行）。分区容忍的一致性算法保证大多数节点数据一致后才返回客户端，同样实现了顺序一致性。</li>
</ul>
<pre>
－－－非P－－主备复制、2PC
｜
－－－P   －－Paxos、Raft
</pre>

<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><h3 id="1、主备复制"><a href="#1、主备复制" class="headerlink" title="1、主备复制"></a>1、主备复制</h3><ul>
<li>主备复制可以说是最常用的数据复制方法，也是最基础的方法，很多其他协议都是基于它的变种。 主备复制要求所有的写操作都在主节点上进行，然后将操作的日志发送给其他副本。可以发现由于主备复制是有延迟的，所以它实现的是最终一致性。</li>
<li>主备复制的实现方式：主节点处理完写操作之后立即返回结果给客户端，写操作的日志异步同步给其他副本。这样的好处是性能高，客户端不需要等待数据同步，缺点是如果主节点同步数据给副本之前数据缺失了，那么这些数据就永久丢失了。MySQL 的主备同步就是典型的异步复制。</li>
</ul>
<h3 id="2、2PC"><a href="#2、2PC" class="headerlink" title="2、2PC"></a>2、2PC</h3><ul>
<li>2PC 是典型的 CA 系统，为了保证一致性和可用性，2PC 一旦出现网络分区或者节点不可用就会被拒绝写操作，把系统变成只读的。</li>
<li>由于 2PC 容易出现节点宕机导致一直阻塞的情况，所以在数据复制的场景中不常用，一般多用于分布式事务中。</li>
<li>如果网络环境较好，该协议一般还是能很好的工作的，2PC广泛应用于关系数据库的分布式事务处理，如mysql的内部与外部XA都是基于2PC的，一般想要把多个操作打包未原子操作也可以用2PC。</li>
</ul>
<pre>
｜－－－1. Prepare(Vote Request) 
｜
｜－－－2. Global Commit (1－ return (Vote Commit)) （正常流程）
｜
｜－－－2. Global Rollback (1－ return (Vote Abort)) （异常流程）
</pre>

<ul>
<li>缺点：    <ol>
<li>性能问题(两个阶段都涉及同步等待阻塞，极大降低了吞吐量)</li>
<li>协调者单点故障问题</li>
<li>丢失消息导致的数据不一致问题</li>
</ol>
</li>
</ul>
<h3 id="3、3PC"><a href="#3、3PC" class="headerlink" title="3、3PC"></a>3、3PC</h3><ul>
<li><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞。在2PC的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题;但是性能问题和不一致问题仍然没有根本解决。</p>
</li>
<li><p>CanCommit阶段: 检查下自身状态的健康性，看有没有能力进行事务操作。</p>
</li>
<li><p>和2PC区别：</p>
<ol>
<li>相比较2PC而言，3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而2PC只有协调者才拥有超时机制。这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。</li>
<li>通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ol>
</li>
<li><p>无论是2PC还是3PC都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos。意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>
</li>
</ul>
<h3 id="4、MVCC"><a href="#4、MVCC" class="headerlink" title="4、MVCC"></a>4、MVCC</h3><ul>
<li>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初也是在数据库系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</li>
</ul>
<h3 id="5、Paxos协议"><a href="#5、Paxos协议" class="headerlink" title="5、Paxos协议"></a>5、Paxos协议</h3><ul>
<li>2PC、3PC 两个协议的协调者都需要人为设置而无法自动生成，是不完整的分布式协议，而Paxos 就是一个真正的完整的分布式算法。系统一共有几个角色：Proposer（提出提案）、Acceptor（参与决策）、Learner（不参与提案，只负责接收已确定的提案，一般用于提高集群对外提供读服务的能力），实践中一个节点可以同时充当多个角色。</li>
<li>作者在描述Paxos时，列举了希腊城邦选举的例子，所以该算法又被称为希腊城邦算法。</li>
<li>Paxos是非常经典的一致性协议，但是因为过于理论化，难以直接工程化，因此工业界出现了诸多基于Paxos思想出发的变种。虽然这些变种最终很多都和原始的Paxos有比较大的差距，甚至完全演变成了新的协议，但是作为奠基者的Paxos在分布式一致性协议中依然持有不可撼动的地位。</li>
<li>Paxos协议的容错性很好，只要有超过半数的节点可用，整个集群就可以自己进行Leader选举，也可以对外服务，通常用来保证一份数据的多个副本之间的一致性，适用于构建一个分布式的一致性状态机。</li>
<li>Google的分布式锁服务Chubby就是用了Paxos协议，而开源的ZooKeeper使用的是Paxos的变种ZAB协议。</li>
</ul>
<h3 id="6、Raft协议"><a href="#6、Raft协议" class="headerlink" title="6、Raft协议"></a>6、Raft协议</h3><ul>
<li>Raft协议是斯坦福的Diego Ongaro、John Ousterhout两人于2013年提出，作者表示流行的Paxos算法难以理解，且其过于理论化致使直接应用于工程实现时出现很多困难，因此作者希望提出一个能被大众比较容易地理解接受，且易于工程实现的协议。Raft由此应运而生。不得不说，Raft作为一种易于理解，且工程上能够快速实现一个较完整的原型的算法，受到业界的广泛追捧。</li>
<li>Raft协议对标Paxos，容错性和性能都是一致的，但是Raft比Paxos更易理解和实施。系统分为几种角色：Leader（发出提案）、Follower（参与决策）、Candidate（Leader选举中的临时角色）。</li>
<li>在Raft协议出来之前，Paxos是分布式领域的事实标准，但是Raft的出现打破了这一个现状（raft作者也是这么想的，请看论文），Raft协议把Leader选举、日志复制、安全性等功能分离并模块化，使其更易理解和工程实现，将来发展怎样我们拭目以待（挺看好）。</li>
<li>Raft协议目前被用于 cockrouchDB，TiKV等项目中</li>
<li>Raft 算法实际上是 Multi-Paxos 的一个变种，通过新增两个约束：<ul>
<li>追加日志约束：Raft 中追加节点的日志必须是串行连续的，而 Multi-Paxos 中则可以并发追加日志（实际上 Multi-Paxos 的并发也只是针对日志追加，最后应用到内部 State Machine 的时候还是必须保证顺序）。</li>
<li>选主限制：Raft 中只有那些拥有最新、最全日志的节点才能当选 Leader 节点，而 Multi-Paxos 由于允许并发写日志，因此无法确定一个拥有最新、最全日志的节点，因此可以选择任意一个节点作为 Leader，但是选主之后必须要把 Leader 节点的日志补全。</li>
<li>基于这两个限制，Raft 算法的实现比 Multi-Paxos 更加简单易懂，不过由于 Multi-Paxos 的并发度更高，因此从理论上来说 Multi-Paxos 的性能会更好一些，但是到现在为止业界也没有一份权威的测试报告来支撑这一观点。</li>
</ul>
</li>
</ul>
<h3 id="Paxos和Raft的对比"><a href="#Paxos和Raft的对比" class="headerlink" title="Paxos和Raft的对比"></a>Paxos和Raft的对比</h3><ul>
<li>Paxos算法和Raft算法有显而易见的相同点和不同点。二者的共同点在于，它们本质上都是单主的一致性算法，且都以不存在拜占庭将军问题作为前提条件。二者的不同点在于，Paxos算法相对于Raft，更加理论化，原理上理解比较抽象，仅仅提供了一套理论原型，这导致很多人在工业上实现Paxos时，不得已需要做很多针对性的优化和改进，但是改进完却发现算法整体和Paxos相去甚远，无法从原理上保证新算法的正确性，这一点是Paxos难以工程化的一个很大原因。相比之下Raft描述清晰，作者将算法原型的实现步骤完整地列在论文里，极大地方便了业界的工程师实现该算法，因而能够受到更广泛的应用。</li>
<li>从根本上来看，Raft的核心思想和Paxos是非常一致的，甚至可以说，Raft是基于Paxos的一种具体化实现和改进，它让一致性算法更容易为人所接受，更容易得到实现。由此亦可见，Paxos在一致性算法中的奠基地位是不可撼动的。</li>
</ul>
<h3 id="7、Gossip算法"><a href="#7、Gossip算法" class="headerlink" title="7、Gossip算法"></a>7、Gossip算法</h3><ul>
<li>Gossip又被称为流行病算法，它与流行病毒在人群中传播的性质类似，由初始的几个节点向周围互相传播，到后期的大规模互相传播，最终达到一致性。</li>
<li>Gossip协议与上述所有协议最大的区别就是它是去中心化的，上面所有的协议都有一个类似于Leader的角色来统筹安排事务的响应、提交与中断，但是Gossip协议中就没有Leader，每个节点都是平等的。</li>
<li>Gossip协议被广泛应用于P2P网络，同时一些分布式的数据库，如Redis集群的消息同步使用的也是Gossip协议，另一个重大应用是被用于比特币的交易信息和区块信息的传播。</li>
<li>去中心化的Gossip看起来很美好：没有单点故障，看似无上限的对外服务能力……本来随着Cassandra火了一把，但是现在Cassandra也被抛弃了，去中心化的架构貌似难以真正应用起来。归根到底我觉得还是因为去中心化本身管理太复杂，节点之间沟通成本高，最终一致等待时间较长……往更高处看，一个企业（甚至整个社会）不也是需要中心化的领导（或者制度）来管理吗，如果没有领导（或者制度）管理，大家就是一盘散沙，难成大事啊。</li>
<li>事实上现代互联网架构只要把单点做得足够强大，再加上若干个强一致的热备，一般问题都不大。</li>
<li>应用：数据同步；缺点：节点之间沟通成本高，最终一致等待时间较长</li>
</ul>
<h3 id="8、Pow（Proof-of-work）"><a href="#8、Pow（Proof-of-work）" class="headerlink" title="8、Pow（Proof of work）"></a>8、Pow（Proof of work）</h3><ul>
<li>Proof-of-work算法又被称为Pow算法。工作量证明算法。</li>
<li>Pow最为人所熟知的应用是比特币。代表者是比特币（BTC），区块链1.0</li>
<li>PoW（Proof of Work，工作量证明）的字面意思是谁干的活多，谁的话语权就大，在一定层面上类似于现实生活中“多劳多得”的概念。以比特币为例，比特币挖矿就是通过计算符合某一个比特币区块头的哈希散列值争夺记账权。这个过程需要通过大量的计算实现，简单理解就是挖矿者进行的计算量越大（工作量大），它尝试解答问题的次数也就变得越多，解出正确答案的概率自然越高，从而就有大概率获得记账权，即该矿工所挖出的区块被串接入主链。</li>
<li>基于PoW节点网络的安全性令人堪忧。大于51%算力的攻击。</li>
<li>51%算力攻击目前仅在“PoW”共识机制中存在，因为“PoW”共识机制依赖算力计算获胜，也就是谁算得快，谁的胜率就高。在使用了“PoW”共识机制的区块链网络中，我们称参与计算哈希的所有计算机资源为算力，那么全网络的算力就是100%，当超过51%的算力掌握在同一阵营中时，这个阵营的计算哈希胜出的概率将会大幅提高。为什么是51%？50.1%不行吗？当然也是可以的，之所以取51%是为了取一个最接近50%，且比50%大的整数百分比，这样当算力值达到51%后的效果将会比50.1%的计算效果更明显。举个例子，如果诚实节点的算力值是50.1%，那么坏节点的算力值就是49.9%。两者的差距不算太大，这样容易导致最终的区块竞争你来我往、长期不分上下。如果算力资源分散，不是高度集中的，那么整个区块链网络是可信的。然而，当算力资源集中于某一阵营的时候，算力的拥有者就能使用算力资源去逆转区块，导致区块链分叉严重，</li>
</ul>
<h3 id="9、PoS（Proof-of-Stake）"><a href="#9、PoS（Proof-of-Stake）" class="headerlink" title="9、PoS（Proof of Stake）"></a>9、PoS（Proof of Stake）</h3><ul>
<li>代表者是以太坊（ETH），以太坊正在从PoW过渡到PoS，区块链2.0</li>
<li>PoS（Proof of Stake，股权证明）是由点点币（PPCoin）首先应用的。该算法没有挖矿过程，而是在创世区块内写明股权分配比例，之后通过转让、交易的方式，也就是我们说的IPO（Initial Public Offerings）公开募股方式，逐渐分散到用户钱包地址中去，并通过“利息”的方式新增货币，实现对节点地址的奖励。PoS的意思是股份制。也就是说，谁的股份多，谁的话语权就大，这和现实生活中股份制公司的股东差不多。但是，在区块链的应用中，我们不可能真实地给链中的节点分配股份，取而代之的是另外一些东西，例如代币，让这些东西来充当股份，再将这些东西分配给链中的各节点。</li>
<li>PoS共识算法具有下面的优缺点：（1）优点•缩短了共识达成的时间，链中共识块的速度更快。•不再需要大量消耗能源挖矿，节能。•作弊得不偿失。如果一名持有多于50%以上股权的人（节点）作弊，相当于他坑了自己，因为他是拥有股权最多的人，作弊导致的结果往往是拥有股权越多的人损失越多。（2）缺点•攻击成本低，只要节点有物品数量，例如代币数量，就能发起脏数据的区块攻击。•初始的代币分配是通过IPO方式发行的，这就导致“少数人”（通常是开发者）获得了大量成本极低的加密货币，在利益面前，很难保证这些人不会大量抛售。•拥有代币数量大的节点获得记账权的概率会更大，使得网络共识受少数富裕账户支配，从而失去公正性。</li>
<li>区块链2.0仍存在性能上的缺陷，难以支持大规模的商业应用开发。与支付宝在“双十一”时26.5万笔交易&#x2F;秒的性能相比，像以太坊这样的区块链系统只能做到几百笔交易&#x2F;秒的水平。交易需由多个参与方确认，是影响区块链性能的主要原因。</li>
</ul>
<h3 id="10、DPoS"><a href="#10、DPoS" class="headerlink" title="10、DPoS"></a>10、DPoS</h3><ul>
<li>代表者是柚子（EOS），区块链3.0</li>
</ul>
<h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><ul>
<li>PBFT拜占庭容错，联盟链中常用。</li>
</ul>
<h3 id="Gossip算法和Pow算法对比"><a href="#Gossip算法和Pow算法对比" class="headerlink" title="Gossip算法和Pow算法对比"></a>Gossip算法和Pow算法对比</h3><ul>
<li>同为去中心化算法，Gossip算法和Pow算法都能实现超大集群的一致性，但是它们的特性可谓有天壤之别。Gossip算法往往应用于超大集群快速达成一致性的目的。它的特性是如流感一般超强的传播速度，以及自身能够管理的数量可观的节点数。但是对于流传的消息没有特别的管控，无法辨别其中的虚假信息，并且只关注与最终的一致性，不关心消息的顺序性。而Pow算法则完全专注于尽可能地解决”拜占庭将军”问题，防止消息的篡改。它可以不计代价地去要求各个节点参与竞选，以付出巨大算力为代价保证平台的安全性。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>区块链：PoW、PoS、Gossip</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="2PC和TCC什么关系"><a href="#2PC和TCC什么关系" class="headerlink" title="2PC和TCC什么关系"></a>2PC和TCC什么关系</h3><ol>
<li><p>2PC在“分布式一致性协议“的范畴，属于CA层面的一个协议，一般作为和其他协议(PAXOS，Raft)进行对比的形式出现。</p>
</li>
<li><p>2PC在“分布式事务“的范畴，属于数据库层面，XA协议的基础。TCC算是一种特殊的2PC。TCC事务的处理流程与2PC两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。</p>
</li>
<li><p>TCC是分布式事务的范畴，但其本质也是分布式一致性的一种协议，只是特指业务上的协议。而一般情况下我们所说的分布式一致性协议，一般是指底层系统实现上的，偏向基础服务上的。如果以后有人对TCC进行改造，描述出底层系统(非业务)的TCC，那么它也属于这篇文章所包含的其中一种分布式一致性协议。对于其他分布式事务的实现方案同理。</p>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>从Paxos到Raft再到EPaxos：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ex7CgJTbxbd5FA2F-BvSVQ">一文总结：分布式一致性技术是如何演进的？</a></li>
<li>众所周知，Paxos是出了名的晦涩难懂，不仅难以理解，更难以实现。而Raft则以可理解性和易于实现为目标，Raft的提出大大降低了使用分布式一致性的门槛，将分布式一致性变的大众化、平民化，因此当Raft提出之后，迅速得到青睐，极大地推动了分布式一致性的工程应用。</li>
<li>EPaxos的提出比Raft还早，但却长期无人问津，很大一个原因就是EPaxos实在是难以理解。EPaxos基于Paxos，但却比Paxos更难以理解，大大地阻碍了EPaxos的工程应用。不过，是金子总会发光的，EPaxos因着它独特的优势，终于被人们发现，具有广阔的前景。</li>
<li>EPaxos更适用于跨AZ跨地域场景，对可用性要求极高的场景，Leader容易形成瓶颈的场景。Multi-Paxos和Raft本身非常相似，适用场景也类似，适用于内网场景，一般的高可用场景，Leader不容易形成瓶颈的场景。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130974371">分布式一致性协议概述</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/558acf897628">分布式系统：一致性协议</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/demon7552003/article/details/86657767">分布式一致性协议</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jQrPSmPhC_yNbIRcufR8KQ">分布式事务：深入理解什么是2PC、3PC及TCC协议</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UfbMFXxJqRhLDXUntKVE8A">详解分布式一致性机制</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qxaR832GsXQBpc6YxgX63Q">漫谈分布式共识问题</a>！！</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KKrxuVCrjlXXWMPTXQ-fvA">分布式之系统底层原理</a>！！！！</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IbBC38rhhQ-mEfw3yf9AVA">深度介绍分布式系统原理与设计</a></li>
<li>[区块链：以太坊DApp开发实战]</li>
<li>[区块链：分布式商业与智数未来]</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/" itemprop="url">分布式事务简要总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-12T14:41:45+08:00">
                2020-09-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>本文涉及一些理论基础</li>
<li>业界目前的分布式事务的解决方案</li>
<li>简单的分类和总结</li>
<li>基本内容都来源网上</li>
</ul>
<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol>
<li>事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。</li>
<li>本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。</li>
<li>全局事务：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。</li>
</ol>
<h3 id="ACID-数据库事务4个特性"><a href="#ACID-数据库事务4个特性" class="headerlink" title="ACID(数据库事务4个特性)"></a>ACID(数据库事务4个特性)</h3><ol>
<li>Atomicity（原子性）</li>
<li>Consistency（一致性)</li>
<li>Isolation（隔离性）</li>
<li>Durablity（持久性）</li>
</ol>
<h3 id="分布式事务-Distributed-Transaction"><a href="#分布式事务-Distributed-Transaction" class="headerlink" title="分布式事务 (Distributed Transaction)"></a>分布式事务 (Distributed Transaction)</h3><ol>
<li>在互联网技术里面，强调追求最终一致性。异地多活就是围绕这一点来做的。</li>
<li>分布式事务从实质上看与数据库事务的概念是一致的，既然是事务也就需要满足事务的基本特性（ACID），只是分布式事务相对于本地事务而言其表现形式有很大的不同。</li>
</ol>
<h3 id="分布式一致性协议-consensus-protocol"><a href="#分布式一致性协议-consensus-protocol" class="headerlink" title="分布式一致性协议 (consensus protocol)"></a>分布式一致性协议 (consensus protocol)</h3><ol>
<li>两阶段提交协议（The two-phase commit protocol，2PC）</li>
<li>3PC</li>
<li>PAXOS</li>
<li>Raft 等</li>
</ol>
<ul>
<li><p>无论是2PC还是3PC都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， ”there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos。意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>
</li>
<li><p>详情看：<a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/09/12/20200912-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/">分布式一致性协议概览</a></p>
</li>
</ul>
<h3 id="DTP-Distributed-Transaction-Processing"><a href="#DTP-Distributed-Transaction-Processing" class="headerlink" title="DTP(Distributed Transaction Processing)"></a>DTP(Distributed Transaction Processing)</h3><ul>
<li><p>DTP（Distributed Transaction Processing Reference Model）：分布式事务处理模型。TM、RM、AP等角色的分布式事务的模型。<br><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/DTP.png"></p>
</li>
<li><p>AP（Application Program，应用程序）</p>
</li>
<li><p>TM（Transaction Manager，事务管理器）</p>
</li>
<li><p>RM（Resource Manager，资源管理器）</p>
</li>
<li><p>DTP规范中主要包含了AP、RM、TM三个部分，其中AP是应用程序，是事务发起和结束的地方；RM是资源管理器，主要负责管理每个数据库的连接数据源；TM是事务管理器，负责事务的全局管理，包括事务的生命周期管理和资源的分配协调等。</p>
</li>
<li><p>XA是DTP的一部分接口规范。</p>
</li>
</ul>
<h3 id="分布式事务框架"><a href="#分布式事务框架" class="headerlink" title="分布式事务框架"></a>分布式事务框架</h3><ul>
<li><p>大多数分布式事务框架，也多借鉴了DTP（Distributed Transaction Processing）模型</p>
</li>
<li><p>RM负责本地事务的提交，同时完成分支事务的注册、锁的判定，扮演事务参与者角色。</p>
</li>
<li><p>TM负责整体事务的提交与回滚的指令的触发，扮演事务的总体协调者角色。</p>
</li>
<li><p>不同框架在实现时，各组件角色的功能、部署形态会根据需求进行调整，例如TM有的是以jar包形式与应用部署在一起，有的则剥离出来需要单独部署（例如Seata中将TM的主要功能放到一个逻辑上集中的Server上，叫做TC( Transaction Coordinator )）</p>
</li>
<li><p>一个好的分布式事务框架应用尽可能满足以下特性：<br>业务改造成本低；1<br>性能损耗低；2<br>隔离性保证完整。3<br>但如同CAP，这三个特性是相互制衡</p>
</li>
<li><p>基于业务补偿的Saga满足1.2；TCC满足2.3；Seata（AT模式）满足1.3</p>
</li>
</ul>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/Saga_TCC_AT.png"></p>
<h3 id="分布式事务的4种模式"><a href="#分布式事务的4种模式" class="headerlink" title="分布式事务的4种模式"></a>分布式事务的4种模式</h3><ol>
<li>AT - (无侵入的分布式事务解决方案)</li>
<li>TCC (业务层的2PC)</li>
<li>Saga (一种补偿协议，长事务解决方案)</li>
<li>XA (DB层的2PC)</li>
</ol>
<ul>
<li>阿里seata框架 实现了这四种模式。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78599954">分布式事务的4种模式</a></li>
</ul>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/Seata.jpg"></p>
<ul>
<li>性能最高的是Saga，其次是TCC。</li>
<li>隔离性最好的是XA（资源层），最差的是Saga。</li>
<li>除了XA，其他三个为柔性事务，补偿式事务。</li>
</ul>
<h3 id="补偿型事务"><a href="#补偿型事务" class="headerlink" title="补偿型事务"></a>补偿型事务</h3><p>补偿型事务处理机制构建在 事务资源 之上（要么在中间件层面，要么在应用层面），事务资源 本身对分布式事务是无感知的。<br><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/%E8%A1%A5%E5%81%BF%E5%9E%8B%E4%BA%8B%E5%8A%A1.png"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>分布式事务实现方案从ACID的角度上，分刚性事务、柔型事务。</li>
<li>刚性事务：通常无业务改造，强一致性，原生支持回滚&#x2F;隔离性，低并发，适合短事务;<br>柔性事务：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。</li>
<li>刚性事务满足ACID理论；柔性事务满足BASE理论（基本可用，最终一致）</li>
<li>刚性事务：XA 协议（2PC、JTA、JTS）、3PC；<br>柔型事务：TCC&#x2F;FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）。</li>
</ul>
<h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><ul>
<li>柔性事务（如分布式事务）为了满足可用性、性能与降级服务的需要，降低一致性（Consistency）与隔离性（Isolation）的要求，遵循 BASE 理论。</li>
<li>柔性事务也部分遵循 ACID 规范：<ol>
<li>原子性：严格遵循</li>
<li>一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽</li>
<li>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽</li>
<li>持久性：严格遵循</li>
</ol>
</li>
</ul>
<h3 id="柔性事务的分类"><a href="#柔性事务的分类" class="headerlink" title="柔性事务的分类"></a>柔性事务的分类</h3><p>柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。</p>
<ol>
<li>两阶段型 (这个并不算柔性事务，资源层，强一致性！)<br>分布式事务二阶段提交，对应技术上的 XA、JTA&#x2F;JTS，这是分布式环境下事务处理的典型模式。</li>
<li>补偿型<br>TCC 型事务（Try-Confirm-Cancel）可以归为补偿型。在 Try 成功的情况下，如果事务要回滚，Cancel 将作为一个补偿机制，回滚 Try 操作；TCC 各操作事务本地化，且尽早提交（没有两阶段约束）；当全局事务要求回滚时，通过另一个本地事务实现“补偿”行为。<br>TCC 是将资源层的二阶段提交协议转换到业务层，成为业务模型中的一部分。</li>
<li>异步确保型<br>将一些有同步冲突的事务操作变为异步操作，避免对数据库事务的争用，如消息事务机制。</li>
<li>最大努力通知型<br>通过通知服务器（消息通知）进行，允许失败，有补充机制。</li>
</ol>
<ul>
<li>针对不同的分布式场景业界常见的解决方案有2PC、TCC、可靠消息最终一致性、最大努力通知这几种。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>JTA（Java Transaction API）：分布式事务的编程API，按照XA、DTP的模型和规范实现，在J2EE中，单库事务通过JDBC事务来支持，跨库事务通过JTA API来支持，通过JTA API可以协调和管理横跨多个数据库的分布式事务，一般来说会结合JNDI。</li>
</ul>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><h3 id="本地消息服务方案-ebay"><a href="#本地消息服务方案-ebay" class="headerlink" title="本地消息服务方案(ebay)"></a>本地消息服务方案(ebay)</h3><ul>
<li><p>eBay 事件队列方案——最终一致性</p>
</li>
<li><p>eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《Base：An Acid Alternative》中提到一个eBay 分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。</p>
</li>
<li><p>(任务表，定时任务或人工自动重试)。</p>
</li>
<li><p>优点：</p>
<ul>
<li>消息的时效性比较高；</li>
<li>从应用设计的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于MQ中间件，弱化了对MQ中间件特性的依赖；</li>
<li>方案轻量级，容易实现。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可以共用；</li>
<li>消息数据与业务数据同步，占用业务系统资源；</li>
<li>业务系统在使用关系型数据库的情况下消息服务性能会受到关系型数据库的并发性能限制。</li>
</ul>
</li>
<li><p>本地消息表:一种非常经典的实现，基本避免了分布式事务，实现了“最终一致性”。但是，关系型数据库的吞吐量和性能方面存在瓶颈，频繁的读写消息会给数据库造成压力。所以，在真正的高并发场景下，该方案也会有瓶颈和限制的。</p>
</li>
<li><p>其他类似方案：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/b4VPvP3m8DA-PM7ZqMGZ">去哪儿网消息队列设计与实现</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/backend-development-eda/">事件驱动架构(EDA)编码实践</a> (事件表方式)</p>
</li>
</ul>
<h3 id="消息队列MQ事务"><a href="#消息队列MQ事务" class="headerlink" title="消息队列MQ事务"></a>消息队列MQ事务</h3><ul>
<li>2PC、3PC的时候我们说没有根本解决性能问题，而如果通过MQ的事务消息来进行异步解耦，并实现系统的数据的最终一致性的话会不会好很多呢？实际上这就是我们下一篇文章要继续讲述的《分布式事务之如何基于RocketMQ的事务消息特性实现分布式系统的最终一致性？:<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014532775/article/details/100830995">https://blog.csdn.net/u014532775/article/details/100830995</a></li>
</ul>
<h4 id="以支付系统为例"><a href="#以支付系统为例" class="headerlink" title="以支付系统为例"></a>以支付系统为例</h4><ol>
<li>上游服务（支付系统）如何确保完成自身支付成功状态更新后消息100%的能够投递到下游服务（用户余额系统）指定的Topic中？<br>1)在这个流程中上游服务在进行本地数据库事务操作前，会先发送一个状态为“待确认”的消息至可靠消息服务，而不是直接将消息投递到MQ服务的指定Topic。<br>2)之后上游服务就会开启本地数据库事务执行业务逻辑操作，这里支付系统就会将该笔支付订单状态更新为“已成功”。<br>3)如果上游服务本地数据库事务执行成功，则继续向可靠消息服务发送消息确认消息，此时可靠消息服务就会正式将消息投递到MQ服务，并且同时更新消息数据库中的消息状态为“已发送”。<br>4)相反，如果上游本地数据库事务执行失败，则需要向可靠消息服务发送消息删除消息，可靠消息服务此时就会将消息删除，这样就意味着事务在上游消息投递过程中就被回滚了，而流程也就此结束了<pre>
实现数据一致性是一个复杂的活。在这个方案中可靠消息服务作为基础性的服务除了执行正常的逻辑外，还得处理复杂的异常场景。在实现过程中可靠消息服务需要启动相应的后台线程，不断轮训消息的状态，这里会轮训消息状态为“待确认”的消息，并判断该消息的状态的持续时间是否超过了规定的时间，如果超过规定时间的消息还处于“待确认”的状态，就会触发上游服务状态询问机制。</pre></li>
</ol>
<p>可靠消息服务就会调用上游服务提供的相关借口，询问这笔消息的处理情况，如果这笔消息在上游服务处理成功，则后台线程就会继续触发上图中的步骤5，更新消息状态为“已发送”并投递消息至MQ服务；反之如果这笔消息上游服务处理失败，可靠消息服务则会进行消息删除。通过这样以上机制就确保了“上游服务本地事务成功处理+消息成功投递”处于一个原子操作了。<br><br>2. 下游服务（用户余额系统）如何确保对MQ服务Topic消息的消费100%都能处理成功？</p>
<pre>
在正常的流程中，下游服务等待消费Topic的消息并进行自身本地数据库事务的处理，如果处理成功则会主动通知可靠消息服务，可靠消息服务此时就会将消息的状态更新为“已完成”；反之，处理失败下游服务就无法再主动向可靠消息服务发送通知消息了。

此时，与消息投递过程中的异常逻辑一样，可靠消息服务也会启动相应的后台线程，轮询一直处于“已发送”状态的消息，判断状态持续时间是否超过了规定时间，如果超时，可靠消息服务就会再次向MQ服务投递此消息，从而确保消息能被再次消费处理。（注意，也可能出现下游服务处理成功，但是通知消息发送失败的情况，所以为了确保幂等，下游服务也需要在业务逻辑上做好相应的防重处理）。
</pre>

<ul>
<li><p>事实上，支付系统的数据一致性是一个复杂的问题，原因在于支付流程的各个环节都存在异步的不确定性，例如支付系统需要跟第三方渠道进行交互，不同的支付渠道交互流程存在差异，并且有异步支付结果回调的情况。</p>
</li>
<li><p>除此以外，支付系统内部本身又是由多个不同子系统组成，除核心支付系统外，还有账务系统、商户通知系统等等，而核心支付系统本身也会被拆分为多个不同的服务模块，如风控、路由等用以实现不同的功能逻辑。某些场景我们无法通过分布式事务来实现数据一致性，只能通过额外的业务补偿手段，如二次轮训、支付对账等来实现数据最终一致性。</p>
</li>
<li><p>综上所述，支付系统是一个复杂的系统，要完全实现数据的一致性单靠某一种手段是无法实现的，大部分情况下我们可以通过额外的业务补偿逻辑来实现数据最终一致性，只是这样补偿逻辑需要以更多的业务开发逻辑为代价，并且在时效性上会存在延迟的问题。</p>
</li>
<li><p>MQ（事务消息）(notify-两阶段提交加回调机制)－ RocketMQ</p>
</li>
</ul>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5_%E4%BA%8B%E5%8A%A1%E4%B8%BB%E5%8A%A8%E6%96%B9%E5%8F%91%E6%B6%88%E6%81%AF.png"><br><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5_%E4%BA%8B%E5%8A%A1%E4%B8%BB%E5%8A%A8%E6%96%B9%E6%B6%88%E6%81%AF%E6%81%A2%E5%A4%8D.jpeg"></p>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><ul>
<li><p>很像阿里的notify</p>
</li>
<li><p>事务发起方首先发送 prepare 消息到 MQ。<br>在发送 prepare 消息成功后执行本地事务。<br>根据本地事务执行结果返回 commit 或者是 rollback。<br>如果消息是 rollback，MQ 将删除该 prepare 消息不进行下发，如果是 commit 消息，MQ 将会把这个消息发送给 consumer 端。<br>如果执行本地事务过程中，执行端挂掉，或者超时，MQ 将会不停的询问其同组的其他 producer 来获取状态。<br>Consumer 端的消费成功机制有 MQ 保证。</p>
</li>
<li><p>从用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可；而在 service 层，则对事务消息的两阶段提交进行了抽象，同时针对超时事务实现了回查逻辑，通过不断扫描当前事务推进状态，来不断反向请求 Producer 端获取超时事务的执行状态，在避免事务挂起的同时，也避免了 Producer 端的单点故障。而在存储层，RocketMQ 通过 Bridge 封装了与底层队列存储的相关操作，用以操作两个对应的内部队列，用户也可以依赖其他存储介质实现自己的 service，RocketMQ 会通过 ServiceProvider 加载进来。<br>从上述事务消息设计中可以看到，RocketMQ 事务消息较好的解决了事务的最终一致性问题，事务发起方仅需要关注本地事务执行以及实现回查接口给出事务状态判定等实现，而且在上游事务峰值高时，可以通过消息队列，避免对下游服务产生过大压力。<br>事务消息不仅适用于上游事务对下游事务无依赖的场景，还可以与一些传统分布式事务架构相结合，而 MQ 的服务端作为天生的具有高可用能力的协调者，使得我们未来可以基于 RocketMQ 提供一站式轻量级分布式事务解决方案，用以满足各种场景下的分布式事务需求。</p>
</li>
<li><p>RocketMQ 阿里开源的消息中间件,原来叫做MetaQ; RocketMQ的各个环节,包括生产者,消费者,broker都是分布式的,所以基本可以保障由于网络原因丢掉,且RocketMQ存在重复消费的问题,所以文档明确表明了应该业务方自己实现幂等性.</p>
</li>
</ul>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/RocketMQ.png"></p>
<ul>
<li>Pulsar、RocketMQ、NSQ、RabbitMQ、Kafka TODO</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>如果由于上游程序bug，下游程序又有二次校验，会导致消息迟迟没消费成功而堆积。（如上游出仓，下游加分成等）</li>
</ul>
<h3 id="AT-自动模式"><a href="#AT-自动模式" class="headerlink" title="AT (自动模式)"></a>AT (自动模式)</h3><ul>
<li><p>AT 模式是一种无侵入的分布式事务解决方案。下面以Seata为例。</p>
</li>
<li><p>Seata实现了AT模式：<a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/dev/mode/at-mode.html">Seata AT 模式</a></p>
</li>
<li><p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
</li>
<li><p>一阶段：Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
</li>
<li><p>二阶段提交：因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
</li>
<li><p>二阶段回滚：Seata 需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就可能需要转人工处理。</p>
</li>
<li><p>写隔离<br>一阶段本地事务提交前，需要确保先拿到 全局锁 。<br>拿不到 全局锁 ，不能提交本地事务。<br>拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</p>
</li>
<li><p>读隔离<br>在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted） 。<br>如果应用在特定场景下，必需要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>
</li>
</ul>
<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><ul>
<li>如果要人工处理。不太适合金钱业务，因为“after image”基本都是在变的。</li>
<li>官方回答：<pre>
Q: 5.脏数据回滚失败如何处理?
A:
1.脏数据需手动处理，根据日志提示修正数据或者将对应undo删除（可自定义实现FailureHandler做邮件通知或其他）
2.关闭回滚时undo镜像校验，不推荐该方案。</pre></li>
</ul>
<p>注：建议事前做好隔离保证无脏数据<br></p>
<ul>
<li>实践验证：TODO</li>
</ul>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><ul>
<li>TCC（Try-Confirm-Cancel）的概念来源于 Pat Helland 发表的一篇名为“Life beyond Distributed Transactions:an Apostate’s Opinion”的论文。</li>
<li>TCC 提出了一种新的事务模型，基于业务层面的事务定义，锁粒度完全由业务自己控制，目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。TCC 把事务运行过程分成 Try、Confirm &#x2F; Cancel 两个阶段，每个阶段的逻辑由业务代码控制。</li>
<li>Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办？<ul>
<li>TCC 中会添加事务日志，如果 Confirm 或者 Cancel 阶段出错，则会进行重试，所以这两个阶段需要支持幂等；如果重试失败，则需要人工介入进行恢复和处理等。</li>
</ul>
</li>
<li>相对于 AT 模式，TCC 模式对业务代码有一定的侵入性，但是 TCC 模式无 AT 模式的全局行锁，TCC 性能会比 AT 模式高很多。</li>
<li>关键属性：应用层面的两阶段操作(应用的侵入性非常强，实现成本高), 强隔离性（预提交校验），性能并非最佳。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>解决了跨服务的业务操作原子性问题，例如组合支付、下订单减库存等场景非常实用</li>
<li>TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，从而避免数据库二阶段中锁冲突的长事务引起的低性能风险</li>
<li>TCC异步高性能，它采用了try先检查，然后异步实现confirm，真正提交是在confirm方法中。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>对微服务的侵入性强，微服务的每个事务都必须实现try、confirm、cancel等3个方法，开发成本高，今后维护改造的成本也高</li>
<li>为了达到事务的一致性要求，try、confirm、cancel接口必须实现幂等性操作</li>
<li>由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，可以考虑采用Redis的方式来记录事务日志</li>
</ol>
<h4 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h4><ul>
<li>蚂蚁金服TCC实践,总结以下注意事项:<pre>
➢业务模型分2阶段设计
➢并发控制
➢允许空回滚
➢防悬挂控制
➢幂等控制
</pre></li>
</ul>
<ol>
<li>允许空回滚<ul>
<li>Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。</li>
</ul>
</li>
</ol>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/%E5%85%81%E8%AE%B8%E7%A9%BA%E5%9B%9E%E6%BB%9A.png"></p>
<ol start="2">
<li>防悬挂控制<ul>
<li>悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。</li>
</ul>
</li>
</ol>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/%E9%98%B2%E6%82%AC%E6%8C%82%E6%8E%A7%E5%88%B6.png"></p>
<h3 id="Saga-‘sɑɡə"><a href="#Saga-‘sɑɡə" class="headerlink" title="Saga [‘sɑɡə]"></a>Saga [‘sɑɡə]</h3><ul>
<li><p>Saga 理论出自 Hector &amp; Kenneth 1987发表的论文 Sagas。Saga 模式是一种长事务解决方案。</p>
</li>
<li><p>Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
</li>
<li><p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
</li>
<li><p>Saga 正向服务与补偿服务也需要业务开发者实现。因此是业务入侵的。</p>
</li>
<li><p>Saga可以看做一个异步的、利用队列实现的补偿事务。Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行。</p>
</li>
<li><p>使用 Saga 模式开发分布式事务时，有两种协调不同服务的方式，一种是协同（Choreography），另一种是编排（Orchestration）</p>
<ol>
<li>选择使用协同的方式处理事务时，服务之间的通信其实就是通过事件进行的，每一个本的事务最终都会向服务的下游发送一个新的事件，既可以是消息队列中的消息，也可以是 RPC 的请求，只是下游提供的接口需要保证幂等和重入</li>
<li>编排的方式引入了中心化的协调器节点，我们通过一个 Saga 对象来追踪所有的子任务的调用情况，根据任务的调用情况决定是否需要调用对应的补偿方案，并在网络请求出现超时时进行重试</li>
</ol>
<ul>
<li>(下游约束)使用 Saga 对分布式事务进行开发时，会对分布式事务的参与者有一定的约束，每一个事务的参与者都需要保证：<ol>
<li>提供接口和补偿副作用的接口；</li>
<li>接口支持重入并通过全局唯一的 ID 保证幂等</li>
</ol>
</li>
</ul>
</li>
<li><p>Saga定义了两种恢复策略：</p>
<ol>
<li>向后恢复，对整个Saga的执行结果撤销。</li>
<li>向前恢复，适用于必须要成功的场景。</li>
</ol>
</li>
<li><p>使用 Saga 实现分布式事务的优点有：</p>
<ul>
<li><strong>微服务架构：</strong>通过对一些基础服务进行组合 &#x2F; 编排来完成各种业务需求。</li>
<li><strong>数据库兼容性高：</strong>对每个服务使用何种数据库技术没有任何要求，服务甚至可以不使用数据库。</li>
</ul>
</li>
<li><p>使用 Saga 实现分布式事务的缺点有：</p>
<ul>
<li><strong>要求服务提供补偿接口：</strong>增加了开发和维护的成本。</li>
<li><strong>不符合 ACID：</strong>没有涉及 Isolation 和 Durability。</li>
</ul>
</li>
<li><p>Saga 从流程上，还可分为两种模式：Orchestration（交响乐）和 Choreography（齐舞）。</p>
</li>
<li><p>关键：每一个参与者都是一个冲正补偿服务、异步。</p>
</li>
<li><p>关键定义：补偿式事务的 Saga</p>
</li>
<li><p>关键属性：性能较好，隔离性较差</p>
</li>
</ul>
<h4 id="方案例子"><a href="#方案例子" class="headerlink" title="方案例子"></a>方案例子</h4><ol>
<li>Ebay提出的基于消息表，即可靠消息最终一致模型，但本质上这也属于Saga模式的一种特定实现。</li>
<li>消息队列MQ事务(可靠消息)(支持事务的消息中间件) <ul>
<li>Apache开源的RocketMQ中间件能够支持一种事务消息机制，确保本地操作和发送消息的异步处理达到本地事务的结果一致。</li>
</ul>
</li>
<li>Saga Orchestration（引入了类似 XA 中的协调者的角色，来驱动整个流程）；基于 Saga Orchestration 和 Kafka 的分布式事务：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o11kXLV94hUn9YylcQ2ayA">微服务中台技术解析之分布式事务方案和实践</a></li>
</ol>
<h4 id="Saga详细说明"><a href="#Saga详细说明" class="headerlink" title="Saga详细说明"></a>Saga详细说明</h4><ul>
<li>最直接的方法就是按照逻辑依次调用服务，但出现异常怎么办?那就对那些已经成功的进行补偿，补偿成功就一致了，这种朴素的模型就是Saga。但Saga这种方式并不能保证隔离性，于是出现了TCC。在实际交易逻辑前先做业务检查、对涉及到的业务资源进行“预留”，或者说是一种“中间状态”，如果都预留成功则完成这些预留资源的真正业务处理，典型的如票务座位等场景。</li>
<li>当然还有像Ebay提出的基于消息表，即可靠消息最终一致模型，但本质上这也属于Saga模式的一种特定实现，它的关键点有两个：<br>基于应用共享事务记录执行轨迹；<br>然后通过异步重试确保交易最终一致（这也使得这种方式不适用那些业务上允许补偿回滚的场景）。</li>
<li>仔细对比这些方案与XA，会发现这些方案本质上都是将两阶段提交从资源层提升到了应用层。</li>
</ul>
<ol>
<li>Saga的核心就是补偿，一阶段就是服务的正常顺序调用（数据库事务正常提交），如果都执行成功，则第二阶段则什么都不做；但如果其中有执行发生异常，则依次调用其补偿服务（一般多逆序调用未已执行服务的反交易）来保证整个交易的一致性。应用实施成本一般。</li>
<li>TCC的特点在于业务资源检查与加锁，一阶段进行校验，资源锁定，如果第一阶段都成功，二阶段对锁定资源进行交易逻辑，否则，对锁定资源进行释放。应用实施成本较高。</li>
<li>基于可靠消息最终一致，一阶段服务正常调用，同时同事务记录消息表，二阶段则进行消息的投递，消费。应用实施成本较低。</li>
</ol>
<h4 id="Saga-模式使用场景"><a href="#Saga-模式使用场景" class="headerlink" title="Saga 模式使用场景"></a>Saga 模式使用场景</h4><ul>
<li>Saga 模式适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。</li>
<li>事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式。</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>一阶段提交本地数据库事务，无锁，高性能；</li>
<li>参与者可以采用事务驱动异步执行，高吞吐；</li>
<li>补偿服务即正向服务的“反向”，易于理解，易于实现；</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。</li>
</ul>
<h4 id="实践经验-1"><a href="#实践经验-1" class="headerlink" title="实践经验"></a>实践经验</h4><ul>
<li>与TCC实践经验相同的是，Saga 模式中，每个事务参与者的冲正、逆向操作，需要支持：<ul>
<li>空补偿：逆向操作早于正向操作时；</li>
<li>防悬挂控制：空补偿后要拒绝正向操作</li>
<li>幂等</li>
</ul>
</li>
</ul>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul>
<li>这里要注意的是，在Saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。隔离性导致在金钱业务的情景中，可能出现”不够扣”的情况（给用户加钱之后，无法撤销，因为被用户花完了）。</li>
</ul>
<h3 id="XA-eXtended-Architecture"><a href="#XA-eXtended-Architecture" class="headerlink" title="XA (eXtended Architecture)"></a>XA (eXtended Architecture)</h3><ul>
<li>XA 规范 是 X&#x2F;Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。</li>
<li>XA协议由Tuxedo首先提出的，并交给X&#x2F;Open组织，作为资源管理器（数据库）与事务管理器的接口标准。XA 规范主要定义了事务协调者（Transaction Manager）和资源管理器（Resource Manager）之间的接口。</li>
<li>XA则规范了TM与RM之间的通信接口，在TM与多个RM之间形成一个双向通信桥梁，从而在多个数据库资源下保证ACID四个特性。</li>
<li>TM和RM之间使用2PC协议。在XA规范的描述中，2PC是TM协调RM们完成已定义的全局事务的方法，AP找TM申请&#x2F;注册全局事务的动作并不是二阶段提交的保障内容。</li>
<li>目前MySQL中只有InnoDB存储引擎支持XA协议。<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/xa.html">https://dev.mysql.com/doc/refman/5.7/en/xa.html</a></li>
</ul>
</li>
<li>XA模式下的 开源框架有atomikos，其开发公司也有商业版本。</li>
<li>优点：<ul>
<li><strong>强一致性：</strong>实现了数据在多个数据库上的强一致提交。</li>
<li><strong>业务侵入性小：</strong>完全靠数据库本身的支持实现分布式事务，不需要改动业务逻辑。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>单点故障：</strong>协调者或者任意一个 XA 数据库都是能引起故障的单点（Single point of failure)。</li>
<li><strong>低性能：</strong>支持 XA 特性的数据库在设计上有大量的阻塞和资源占位操作， 数据体量和吞吐量扩展性差。</li>
<li><strong>数据库选型限制：</strong>对于服务的数据库选型引入了支持 XA 协议这个限制。</li>
</ul>
</li>
<li>XA 在设计上没有考虑到分布式系统的特点，事实上是一个强一致、低可用的设计方案，对网络分隔的容忍度较差。</li>
<li>XA模式缺点：事务粒度大。高并发下，系统可用性低。因此很少使用。</li>
<li>关键属性：DB层面（资源层）</li>
</ul>
<h4 id="Seata-的XA模式"><a href="#Seata-的XA模式" class="headerlink" title="Seata 的XA模式"></a>Seata 的XA模式</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163335038">分布式事务如何实现？深入解读 Seata 的 XA 模式</a></p>
</li>
<li><p>Seata 已经支持的 3 大事务模式：AT、TCC、Saga 都是 补偿型 的。</p>
</li>
<li><p>补偿型 事务处理机制构建在 事务资源 之上（要么在中间件层面，要么在应用层面），事务资源 本身对分布式事务是无感知的。</p>
</li>
<li><p>事务资源 对分布式事务的无感知存在一个根本性的问题：无法做到真正的 全局一致性 。</p>
</li>
<li><p>Seata 1.2.0 版本重磅发布新的事务模式：XA 模式，实现对 XA 协议的支持。</p>
</li>
<li><p>XA 的价值：与 补偿型 不同，XA 协议 要求 事务资源 本身提供对规范和协议的支持。因为 事务资源 感知并参与分布式事务处理过程，所以 事务资源（如数据库）可以保障从任意视角对数据的访问有效隔离，满足全局数据一致性。</p>
</li>
<li><p>除了 全局一致性 这个根本性的价值外，支持 XA 还有如下几个方面的好处：</p>
<ol>
<li>业务无侵入：和 AT 一样，XA 模式将是业务无侵入的，不给应用设计和开发带来额外负担。</li>
<li>数据库的支持广泛：XA 协议被主流关系型数据库广泛支持，不需要额外的适配即可使用。</li>
<li>多语言支持容易：因为不涉及 SQL 解析，XA 模式对 Seata 的 RM 的要求比较少，为不同语言开发 SDK 较之 AT 模式将更 薄，更容易。</li>
<li>传统基于 XA 应用的迁移：传统的，基于 XA 协议的应用，迁移到 Seata 平台，使用 XA 模式将更平滑。</li>
</ol>
</li>
<li><p>从编程模型上，XA 模式与 AT 模式保持完全一致。上层编程模型与 AT 模式完全相同。只需要修改数据源代理，即可实现 XA 模式与 AT 模式之间的切换。</p>
</li>
</ul>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/Seata.jpg"></p>
<h3 id="最大努力通知型"><a href="#最大努力通知型" class="headerlink" title="最大努力通知型"></a>最大努力通知型</h3><ul>
<li>回调客户端确认：支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ol>
<li>为了交易系统更可靠，我们一般会在类似交易这种高级别的服务代码中，加入详细日志记录的，一旦系统内部引发类似致命异常（如超时情况），会有邮件通知。同时，后台会有定时任务扫描和分析此类日志，检查出这种特殊的情况，会尝试通过程序来补偿并邮件通知相关人员。</li>
<li>在某些特殊的情况下，还会有“人工补偿”的，这也是最后一道屏障。</li>
</ol>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><ul>
<li>阿里开源分布式事务解决方案 Fescar:<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TFGRcHV6EgeLB45OEJPRXw">https://mp.weixin.qq.com/s/TFGRcHV6EgeLB45OEJPRXw</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seata/seata">https://github.com/seata/seata</a></li>
<li><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li>
</ul>
<h3 id="四种模式分析"><a href="#四种模式分析" class="headerlink" title="四种模式分析"></a>四种模式分析</h3><p>四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景</p>
<ol>
<li>AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。</li>
<li>TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。</li>
<li>Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。</li>
<li>XA模式是分布式强一致性的解决方案，但性能低而使用较少。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>金钱业务的冻结&amp;结算 接口，其实就是TCC模式，而消费&amp;退款 就是Saga模式。</li>
<li>数据库事务对应刚性事务，以XA模式为例；业务事务对应柔性事务，以TCC，Saga，AT模式为例。</li>
<li>2PC一般是分布式事务的基础协议，具有普适性。</li>
<li>要多考虑“防悬挂控制“、”允许空回滚“。</li>
</ol>
<h3 id="分类归纳"><a href="#分类归纳" class="headerlink" title="分类归纳"></a>分类归纳</h3><ol>
<li><p>分布式事务两种大分类</p>
<ol>
<li>按模式分类：XA、AT、TCC、Saga。</li>
<li>按柔性事务分类：补偿型、异步确保型、最大努力通知型。</li>
</ol>
</li>
<li><p>补偿型(资源之上－业务层或中间件)：AT、TCC、Saga。</p>
</li>
<li><p>业务无侵入：XA、AT；业务侵入：TCC、Saga。</p>
</li>
<li><p>性能：Saga &gt; TCC&gt; XA、AT。</p>
</li>
<li><p>隔离型：XA&gt;TCC、AT&gt;Saga。</p>
</li>
<li><p>刚性事务满足ACID理论；柔性事务满足BASE理论（基本可用，最终一致）。</p>
</li>
<li><p>刚性事务：XA；柔性事务：AT、TCC、Saga。</p>
</li>
<li><p>异步确保型（可靠消息最终一致性）：本地消息服务方案(ebay)、消息队列MQ事务；异步回调：最大努力通知型。</p>
</li>
<li><p>Saga：普通RPC重试、异步确保型（主动）、异步回调（被动）。(异步只是提升性能的一种方式)</p>
</li>
<li><p>总结</p>
<ol>
<li>一致性保证：XA &gt; TCC &#x3D; SAGA &gt; 事务消息</li>
<li>业务友好性：XA &gt; 事务消息 &gt; SAGA &gt; TCC</li>
<li>性能损耗：XA &gt; TCC &gt; SAGA &#x3D; 事务消息</li>
</ol>
</li>
<li><p>分布式事务的解决方案都很难做到有高一致性的同时，也有高性能，同时在实现上也有一定的难度。在业务允许的情况下，我们通常处理分布式事务的一般原则应是：业务规避 &gt; 最终一致 &gt; 强一致。</p>
</li>
</ol>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="XA跟2PC什么关系？"><a href="#XA跟2PC什么关系？" class="headerlink" title="XA跟2PC什么关系？"></a>XA跟2PC什么关系？</h3><ol>
<li>XA规范中2PC是TM协调RM的方式。</li>
</ol>
<h3 id="XA-VS-TCC"><a href="#XA-VS-TCC" class="headerlink" title="XA VS TCC"></a>XA VS TCC</h3><ol start="0">
<li>XA是数据库的2PC，TCC是业务层的2PC</li>
<li>XA是数据库的分布式事务，强一致性，在整个过程中，数据一张锁住状态，即从prepare到commit、rollback的整个过程中，TM一直把持着数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在长事务风险。</li>
<li>TCC是业务的分布式事务，最终一致性，不会出现长事务的锁风险，try是本地事务，锁定资源后就提交事务，confirm／cancel也是本地事务，可以直接提交事务，所以多个短事务不会出现长事务的风险。</li>
</ol>
<p><img src="/2020/09/12/20200912-fen-bu-shi-shi-wu-jian-yao-zong-jie/XA_TCC.png"></p>
<h3 id="XA如何在分布式事务中如何保证隔离性？"><a href="#XA如何在分布式事务中如何保证隔离性？" class="headerlink" title="XA如何在分布式事务中如何保证隔离性？"></a>XA如何在分布式事务中如何保证隔离性？</h3><ol>
<li>由RM直接连接各个数据源(支持XA协议)，RM一般是个单独的服务？</li>
<li>后续通过Seata的XA模式深入了解TODO</li>
</ol>
<h3 id="分布式事务一致性与Paxos一致性的思考"><a href="#分布式事务一致性与Paxos一致性的思考" class="headerlink" title="分布式事务一致性与Paxos一致性的思考"></a>分布式事务一致性与Paxos一致性的思考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zp1kJ895zBb9vA7fgJ20eQ">聊一聊分布式事务</a></li>
<li>分布式事务解决方案，如TCC、Saga、本地消息表等，其本质都是2PC。</li>
<li>Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。</li>
<li>2PC和Paxos都是解决关于“一致性”的问题，其实细想它们解决的问题不在一个层面。<ul>
<li>2PC要求分布式系统中的每个节点要不全部成功，要不全部失败，强调的是原子性。</li>
<li>Paxos要求多个副本之间的数据一致性，其实这里用“一致性”并不准确，应该用“共识（Consensus）”才对。例如2PC中的协调者单点的问题可以用Paxos算法通过选举出新的协调者来解决。</li>
</ul>
</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/598758">GTS-阿里巴巴全新分布式事务解决方案</a><ul>
<li>GTS既不在资源层也不在应用层，它是在中间件层解决事务的问题，这是它们本质的区别。</li>
<li>GTS有两个使用模式，AT和MT。AT是自动模式，可以完全自动回滚，可以覆盖90%左右的业务场景，所以比较推荐使用AT模式，它对业务无侵入，高效，强一致性。还有一种MT模式是GTS推出的兼容TCC的模式，因为有一些情况下是无法避免的要使用TCC模式。</li>
<li>强一致？感觉不是。</li>
</ul>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://ld246.com/article/1588748307781">XA 规范与 TCC 事务模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9e4982384a2">分布式事务（4）XA规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c1fd2420274">初识Open&#x2F;X XA</a></li>
<li><a target="_blank" rel="noopener" href="https://publications.opengroup.org/c193">Distributed Transaction Processing: The XA Specification</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/agilestyle/p/11623047.html">TCC、XA 、DTP区别</a></li>
<li><a target="_blank" rel="noopener" href="https://ld246.com/article/1588748307781">XA 规范与 TCC 事务模型</a></li>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/132895.html">柔性事务的定义与分类</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48586408">MySQL 中基于 XA 实现的分布式事务</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78599954">分布式事务的4种模式</a> </li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163335038">分布式事务如何实现？深入解读 Seata 的 XA 模式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/336224977_673711">讲清楚分布式事务选型：XA、2PC、TCC、Saga、阿里Seata</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jQrPSmPhC_yNbIRcufR8KQ">分布式事务：深入理解什么是2PC、3PC及TCC协议</a></li>
<li><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s/ROVuCPr2Rg3G1m_daYu-Vg">一种提高微服务架构的稳定性与数据一致性的方法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency">分布式系统事务一致性解决方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/xvjunjie/2420402">分布式事务中的三种解决方案详解</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/distributed-transaction-principle">分布式事务的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/omtkduEIZxVIIgkdTlzzSQ">关于如何实现一个TCC分布式事务框架的一点思考</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/295542601_505827">还不理解“分布式事务”？这篇给你讲清楚！</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247488985&amp;idx=1&amp;sn=cafd8ce4b47bf098c7e87846318eff4d&source=41#wechat_redirect">RocketMQ 4.3正式发布，支持分布式事务</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/backend-development-eda/">事件驱动架构(EDA)编码实践</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o11kXLV94hUn9YylcQ2ayA">微服务中台技术解析之分布式事务方案和实践</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-qie-huan-hou-jian-kong-he-xiu-zheng-fang-an/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-qie-huan-hou-jian-kong-he-xiu-zheng-fang-an/" itemprop="url">金融业务容灾切换后监控和修正方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T22:49:21+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-qie-huan-hou-jian-kong-he-xiu-zheng-fang-an/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-qie-huan-hou-jian-kong-he-xiu-zheng-fang-an/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>接<a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/08/31/20200831-%E5%85%B3%E4%BA%8EMHA-Consul-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83/">关于MHA_Consul_MySQL高可用方案的简单总结和思考</a><br>中所讲，该方案无法严格保证主从数据一致或者不丢数据，那么对数据准确性非常严格的业务，则需要在业务层面进行相应的对账和修正。</p>
</li>
<li><p>对账的前提当然是要有流水，可以是业务流水(跟余额表事务绑定)或者是binlog的变更流水。</p>
</li>
<li><p>既然是对准确性要求严格的业务，一般都应该会有业务流水。</p>
</li>
</ul>
<h2 id="方案描述"><a href="#方案描述" class="headerlink" title="方案描述"></a>方案描述</h2><ul>
<li>方案以数据库切换事件为线索，描述切库前的事先准备、切库中的止损、切库后的监控和修正。</li>
</ul>
<h3 id="一、切库前"><a href="#一、切库前" class="headerlink" title="一、切库前"></a>一、切库前</h3><ol>
<li>余额写redis缓存（如果有多机房，需要异步多写对应机房的redis，或nsq通知）</li>
</ol>
<h3 id="二、切库中"><a href="#二、切库中" class="headerlink" title="二、切库中"></a>二、切库中</h3><ol>
<li>发生切库事件</li>
<li>（切库之后的一段时间内）若有用户余额变动操作，比对redis和DB余额是否一致，不一致则阻断一段时间。</li>
</ol>
<ul>
<li>缺点：不一致有可能是误伤（redis刚好写失败导致切库前就不一致）</li>
<li>折中：针对一些大额变更才阻断，增加一些更细致的策略</li>
</ul>
<h3 id="三、切库后"><a href="#三、切库后" class="headerlink" title="三、切库后"></a>三、切库后</h3><ol>
<li>指定主库和从库，对比流水日志</li>
<li>修复数据（若有不一致），并关闭冻结开关</li>
<li>无法修复的订单如何处理（用户余额不足）？<ul>
<li>考虑当坏账处理；通过余额调整（邮件审批方式同步团队成员）；再按流水订单重新扣除</li>
</ul>
</li>
</ol>
<h3 id="对比流水和修复大致思路"><a href="#对比流水和修复大致思路" class="headerlink" title="对比流水和修复大致思路"></a>对比流水和修复大致思路</h3><ol>
<li>读旧主库和新主库的余额变更流水日志</li>
<li>对比得到旧主库存在而新主库不存在的余额变更流水日志</li>
<li>获取受影响的用户的余额，重放流水日志模拟分析，得到受影响人数，受影响金额，不可修复订单（比如余额不足）等情况</li>
<li>按照流水日志中的业务类型重新执行相应的业务sql（充值，消费，提现等）</li>
<li>修复完成之后，重建旧主库，并挂为主库</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/" itemprop="url">金融业务容灾体系简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T00:04:32+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>本文针对金融类(如用户虚拟货币)这类对数据准确性很敏感的业务的容灾架构；</li>
<li>案例中的服务架构为同城主备架构；</li>
<li>内容包括：容灾架构、故障切换、故障恢复、演练方案等；</li>
<li>涉及技术点：MySQL、MHA、Consul等；</li>
<li>本文基于<ol>
<li><a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/08/31/20200831-%E5%85%B3%E4%BA%8EMHA-Consul-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83/">关于MHA-Consul-MySQL高可用方案的简单总结和思考</a></li>
<li><a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/09/05/20200905-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/">如何解决脑裂问题</a></li>
</ol>
</li>
<li>由于某种原因，某些细节不会描述。</li>
<li>关于系统可用性，收藏了一张网图<br><img src="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/availability.png"></li>
<li>MTTF 是 Mean Time To Failure，平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障。系统的可靠性越高，MTTF 越长。（注意：从字面上来说，看上去有 Failure 的字样，但其实是正常运行的时间。）</li>
<li>MTTR 是 Mean Time To Recovery，平均修复时间，即从故障出现到故障修复的这段时间，这段时间越短越好。</li>
<li>故障是正常的，而且是常见的。<br>故障是不可预测突发的，而且相当难缠。<br>我们要干的事儿就是想尽一切手段来降低 MTTR——故障的修复时间。<br>– 陈皓</li>
</ul>
<h2 id="容灾架构"><a href="#容灾架构" class="headerlink" title="容灾架构"></a>容灾架构</h2><p><img src="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/Network_Topology.png"></p>
<p><img src="/2020/09/08/20200908-jin-rong-ye-wu-rong-zai-ti-xi-jian-shu/Architecture.png"></p>
<ol>
<li>红色线条为正常情况下的服务主链路；</li>
<li>同城主备架构： 主－IDC-A；从－IDC-B;</li>
<li>域名灾备：前端通过主域名访问后端接口，当响应超时或者返回50x的时候，前端将切换到备用域名访问后端接口；<ul>
<li>异常情况可能是后端服务异常或者用户所在地区网络不稳定等原因；</li>
<li>针对不幂等的接口，应设置成只切换域名不进行重试；</li>
<li>后端服务可以根据自身服务的异常情况，返回50x，让前端切换到备用域名</li>
</ul>
</li>
<li>主域名为CDN域名，连接北京两个机房，备用域名是非CDN域名，直接连接北京第三个机房；<ul>
<li>使用CDN域名的原因：不把回源点暴露出去，从而把核心机房暴露出去。</li>
</ul>
</li>
<li>使用MHA＋Consul作为DB的切换方案；</li>
<li>每个IDC的gateway配置服务的主权重都是在IDC-A；发生故障切换时，gateway将把服务主权重切换到IDC-B，而通过外网进入IDC-A的流量，服务通过返回50x由前端切换到备用域名。</li>
</ol>
<h2 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h2><h3 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h3><h4 id="触发故障切换的场景"><a href="#触发故障切换的场景" class="headerlink" title="触发故障切换的场景"></a>触发故障切换的场景</h4><ol>
<li>机房孤岛 (MHA＋Consul出发切换)</li>
<li>网络抖动 (由决策服务通过健康检查手段决策)</li>
<li>服务自身异常或机器问题等 (MHA＋Consul出发切换)</li>
</ol>
<h4 id="1-MHA-Consul切换"><a href="#1-MHA-Consul切换" class="headerlink" title="1) MHA+Consul切换"></a>1) MHA+Consul切换</h4><ul>
<li>触发条件：1或3 (主库不可访问)</li>
<li>MHA＋Consul切换后，决策服务切换gateway的服务权重</li>
</ul>
<h4 id="2-决策服务切换"><a href="#2-决策服务切换" class="headerlink" title="2) 决策服务切换"></a>2) 决策服务切换</h4><ul>
<li>触发条件：2 (网络抖动)</li>
<li>决策服务健康检查异常后，通过MHA+Consul主动切换主库，并切换gateway的服务权重</li>
</ul>
<h3 id="机房容灾场景（单机房故障）"><a href="#机房容灾场景（单机房故障）" class="headerlink" title="机房容灾场景（单机房故障）"></a>机房容灾场景（单机房故障）</h3><h4 id="1-机房内外网不通"><a href="#1-机房内外网不通" class="headerlink" title="1) 机房内外网不通"></a>1) 机房内外网不通</h4><ol>
<li>IDC-A故障<ol>
<li>服务权重通过gateway切换到IDC-B</li>
<li>外网无法进入IDC-A，只能进入IDC-B</li>
<li>CDN域名检测异常后剔除IDC-A的服务节点</li>
<li>故障瞬间由于IDC-A不通，cdn结点会重试到IDC-B或者返回前端50x，前端访问备用域名。</li>
</ol>
</li>
<li>IDC-B故障<ol>
<li>服务权重无需调整</li>
<li>外网无法进入IDC-B，只能进入IDC-A</li>
<li>CDN域名检测异常后剔除IDC-B的服务节点</li>
<li>故障瞬间由于IDC-B不通，cdn结点会重试到IDC-A或者返回前端50x，前端访问备用域名。</li>
</ol>
</li>
</ol>
<h4 id="2-机房孤岛（内网不通，外网通）"><a href="#2-机房孤岛（内网不通，外网通）" class="headerlink" title="2) 机房孤岛（内网不通，外网通）"></a>2) 机房孤岛（内网不通，外网通）</h4><ol>
<li>IDC-A故障<ol>
<li>服务权重通过gateway切换到IDC-B</li>
<li>通过外网进入IDC-A的流量，服务自杀返回50x，前端访问备用域名<ul>
<li>服务自杀参考：<a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/09/05/20200905-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/">如何解决脑裂问题</a></li>
</ul>
</li>
</ol>
</li>
<li>IDC-B故障<ol>
<li>服务权重无需调整</li>
<li>通过外网进入IDC-B的流量，服务自杀返回50x，前端访问备用域名</li>
</ol>
</li>
</ol>
<h4 id="3-机房网络抖动"><a href="#3-机房网络抖动" class="headerlink" title="3) 机房网络抖动"></a>3) 机房网络抖动</h4><p>机房服务异常（内外网都通，但该机房服务有问题，网络不稳定，丢包率高等，需机房切换）。<br>流量进入服务之后处理同2）只是切换策略不同。</p>
<h3 id="决策服务"><a href="#决策服务" class="headerlink" title="决策服务"></a>决策服务</h3><ol>
<li>通过Consul判断是否孤岛</li>
<li>通过接口调用失败率，apm，监控网络丢包率等指标判断</li>
<li>相关服务同步切</li>
</ol>
<h4 id="单元化"><a href="#单元化" class="headerlink" title="单元化"></a>单元化</h4><ol>
<li>切换需要把相互依赖的服务整体进行切换，尽量避免跨机房调用。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="gateway如何实现"><a href="#gateway如何实现" class="headerlink" title="gateway如何实现"></a>gateway如何实现</h3><ul>
<li>可以考虑结合服务发现，以localproxy代替nginx代替服务权重配置</li>
</ul>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol>
<li>定时任务是否要切换</li>
<li>MQ消费或生产是否要切换</li>
<li>服务强依赖要单元化，比如强依赖方主备，自己的服务做双活也没用</li>
<li>MQ类发送异步进行</li>
<li>留意nginx重试机制，如以下配置：<code>proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504;</code>，501是不重试的，超时和其他50x会重试。<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mj158518/article/details/49847119">nginx的重试机制</a></li>
</ul>
</li>
</ol>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ol>
<li>服务所依赖的外部服务分为强依赖和弱依赖。弱依赖可以继续降级，而强依赖则不可以。</li>
<li>强依赖可以进一步划分成读依赖和写依赖。通常情况下写依赖是几乎不可能优化的，只能依赖其高可用，比如扣费服务。而读依赖则有优化空间，读依赖可以分为实时性依赖和非实时性依赖，后者可以通过缓存来解决强依赖的问题，比如用户的信息。这部分数据通常的强依赖的，但是又可以缓存下来。</li>
<li>强实时性读依赖的，故障情况下，可以考虑降级成非实时性依赖。比如采取先读远端数据，失败时降级成读缓存的策略。</li>
</ol>
<h3 id="演练方式"><a href="#演练方式" class="headerlink" title="演练方式"></a>演练方式</h3><ol start="0">
<li>前期：tcpcpoy线上流量，复制线上服务部署单独一台演练环境，包括应用和db</li>
<li>kill服务，killDB</li>
<li>iptables屏蔽端口<ul>
<li>iptable和kill应用不一样。前者会有readtimeout，后者直接reset peer</li>
<li>kill应用的方式基本是平稳的，使用iptable屏蔽端口的方式，可能会有connectTimeout或readTimeout。</li>
</ul>
</li>
<li>线上停机房<ul>
<li>停专线一定是孤岛，不存在一边内网通，另一边内网不通的情况，是一个内网（看上图的网络拓扑图）。</li>
</ul>
</li>
</ol>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>备用机房（IDC-B）正常情况下无流量？<ul>
<li>配置万分之一的流量，确保切换前已经可用。</li>
<li>确保切换之前备机房是可用的，是否可用通过观察日志情况。</li>
<li>备用机房异常应该及时告警。</li>
</ul>
</li>
<li>为什么跨机房同步不使用MySQL主从同步而使用otter？<ul>
<li>一般主从同步只在同机房或者同城进行。</li>
<li>otter是阿里开源的一个分布式数据库同步系统，尤其是在跨机房数据库同步方面，有很强大的功能。 </li>
<li>？？？？</li>
</ul>
</li>
<li>相关服务一同切换是否合理<ol>
<li>机房异常一同切换可行；</li>
<li>如果只是单个服务异常，别的服务也要跟着切库不一定合理。决策服务应该支持业务自行配置切换策略。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/20200905-ru-he-jie-jue-nao-lie-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/20200905-ru-he-jie-jue-nao-lie-wen-ti/" itemprop="url">如何解决脑裂问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T00:04:32+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/05/20200905-ru-he-jie-jue-nao-lie-wen-ti/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/05/20200905-ru-he-jie-jue-nao-lie-wen-ti/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是“Split Brain”(脑裂)问题？</p>
<p>Split Brain 是指在同一时刻有两个认为自己处于 Active 状态的 NameNode。对于HA集群而言，确保同一时刻只有一个NameNode处于active状态是至关重要的。否则，两个NameNode的数据状态就会产生分歧，可能丢失数据，或者产生错误的结果。</p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul>
<li><p>Consistency (一致性): 副本一致性特指强一致性；</p>
</li>
<li><p>Availiablity(可用性): 指系统在出现异常时已经可以提供服务;</p>
</li>
<li><p>Tolerance to the partition of network (分区容忍): 指系统可以对网络分区这种异常情 况进行容错处理;</p>
</li>
<li><p>CAP理论，对于P（分区容忍性）而言，是实际存在 从而无法避免的。因为，分布系统中的处理不是在本机，而是网络中的许多机器相互通信，故网络分区、网络通信故障问题无法避免。因此，只能尽量地在C 和 A 之间寻求平衡。</p>
</li>
<li><p>对于数据存储而言，为了提高可用性（Availability），采用了副本备份。某数据块所在的机器宕机了，就去该数据块副本所在的机器上读取。但是，当需要修改数据时，就需要更新所有的副本数据，这样才能保证数据的一致性（Consistency）。因此，就需要在 C(Consistency) 和 A(Availability) 之间权衡。</p>
</li>
<li><p>Quorum机制，就是这样的一种权衡机制，一种将“读写转化”的模型。</p>
</li>
</ul>
<h3 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h3><ol>
<li>Write-all-read-one(简称 WARO).(极端的方案)<ul>
<li>当Client请求向某副本写数据时(更新数据)，只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</li>
<li>WARO牺牲了更新服务的可用性，最大程度地增强了读服务的可用性。而Quorum就是更新服务和读服务之间进行一个折衷。</li>
</ul>
</li>
<li>Quorum 机制<ul>
<li>将 WARO 的条件进行松弛,从而使得可以在读写服务可用性之间做折中,得出 Quorum 机制。</li>
<li>Quorum机制是“抽屉原理”的一个应用。定义如下：假设有N个副本，更新操作wi 在W个副本中更新成功之后，才认为此次更新操作wi 成功。称成功提交的更新操作对应的数据为：“成功提交的数据”。对于读操作而言，至少需要读R个副本才能读到此次更新的数据。其中，W+R&gt;N ，即W和R有重叠。一般，W+R&#x3D;N+1</li>
<li>仅仅依赖 quorum 机制是无法保证强一致性的。因为仅有 quorum 机制时无法确 定最新已成功提交的版本号,除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数 据集群管理,否则很难确定最新成功提交的版本号。<ul>
<li>1）如何读取最新的数据？—在已经知道最近成功提交的数据版本号的前提下，最多读R个副本就可以读到最新的数据了。</li>
<li>2）如何确定 最高版本号 的数据是一个成功提交的数据？—继续读其他的副本，直到读到的 最高版本号副本 出现了W次。</li>
</ul>
</li>
<li>Quorum 机制的三个系统参数 N、W、R 控制了系统的可用性,也是系统对用户的服务承诺:数 据最多有 N 个副本,但数据更新成功 W 个副本即返回用户成功。对于一致性要求较高的 Quorum 系 统,系统还应该承诺任何时候不读取未成功提交的数据,即读取到的数据都是曾经在 W 个副本上成 功的数据。</li>
</ul>
</li>
</ol>
<h3 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a>Lease 机制</h3><ul>
<li>Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发出 lease,则无论接受方是否收到,也无论后续接收方处于何种状态,只要 lease 不过期,颁发者一 定严守承诺;另一方面,接收方在 lease 的有效期内可以使用颁发者的承诺,但一旦 lease 过期,接 收方一定不能继续使用颁发者的承诺。</li>
<li>Lease 机制依赖于有效期,这就要求颁发者和接收者的时钟是同步的。对于这种时钟不同步,实践中的通常做法是 将颁发者的有效期设置得比接收者的略大,只需大过时钟误差就可以避免对 lease 的有效性的影响。</li>
</ul>
<h3 id="解决脑裂的关键"><a href="#解决脑裂的关键" class="headerlink" title="解决脑裂的关键"></a>解决脑裂的关键</h3><h4 id="raft是如何解决的？"><a href="#raft是如何解决的？" class="headerlink" title="raft是如何解决的？"></a>raft是如何解决的？</h4><ol start="0">
<li>核心是“大多数成功”机制。Raft就是基于Quorum机制下实现的。</li>
<li>看下以下这篇文章:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/072380e12657">为 Raft 引入 leader lease 机制解决集群脑裂时的 stale read 问题</a><ul>
<li>这种方法牺牲了一定的可用性（在脑裂时部分客户端的可用性）换取了一致性的保证。</li>
<li>多数派的网络分区挂了，岂不是直接不可写了</li>
</ul>
</li>
<li>如何解决多数派的网络分区挂了，服务就不可用的问题？<ul>
<li>我的答案是部署不止两个网络分区，至少三个网络分区；这样任意一个分区挂了，服务都可用，除非三个分区的大多数分区挂了(挂了2个)；</li>
</ul>
</li>
<li>副本控制协议分为两大类:“中心化(centralized)副本控制协议”和“去中心化(decentralized) 副本控制协议”。解决脑裂的其中一个关键点是哪种 “去中心化的协议”，paxos和raft都是。</li>
</ol>
<h4 id="使用非分布式存储的应用如何解决？"><a href="#使用非分布式存储的应用如何解决？" class="headerlink" title="使用非分布式存储的应用如何解决？"></a>使用非分布式存储的应用如何解决？</h4><ol>
<li>上述处理脑裂问题的前提是：服务本身就是一个分布式存储服务，使用raft等一致性协议；那么普通的业务服务，使用MySQL的的情况下，怎么解决脑裂问题？</li>
<li>MySQL主从服务复制，这种存储服务本身就不是去中心的分布式数据库；</li>
<li>解决问题的核心点是：引入第三方组件作为整个业务集群的“选主服务”(比如Consul、Etcd，都是基于Raft协议)；结合MySQL的半同步复制机制：支持配置n个从库ack才响应客户端（类似Quorum机制）和MHA，可以很大程度的避免丢数据导致不一致。</li>
<li>Consul本身就是基于raft协议，可以利用其去中心化的特性，作为选主服务，业务通过Consul识别到哪个集群是主集群之后，可定制进行相应的业务处理。</li>
</ol>
<h4 id="选主服务"><a href="#选主服务" class="headerlink" title="选主服务"></a>选主服务</h4><ol>
<li>Consul、Etcd (Raft)<ul>
<li>在本次案例中是通过判断是否能获得Consul集群中的leader来判断孤岛的（调获取某个node的信息接口，如果没有leader会返回“No cluster leader”）；而不是通过Consul分布式锁的方式选主。</li>
</ul>
</li>
<li>ZooKeeper (ZAB、Paxos )</li>
<li>Chubby 分布式锁；<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/R2FCLknar6bCvykJ1m7rJQ">Google的锁，才是分布式锁？</a></li>
</ol>
<h3 id="使用Consul解决脑裂问题"><a href="#使用Consul解决脑裂问题" class="headerlink" title="使用Consul解决脑裂问题"></a>使用Consul解决脑裂问题</h3><ul>
<li><img src="/2020/09/05/20200905-ru-he-jie-jue-nao-lie-wen-ti/Consul_no_leader.png"></li>
</ul>
<h4 id="如何判断“孤岛”？"><a href="#如何判断“孤岛”？" class="headerlink" title="如何判断“孤岛”？"></a>如何判断“孤岛”？</h4><ol>
<li>在三个IDC部署一个Consul集群，该集群会存在一个leader，且每个IDC的service在网络正常的情况下，都能检测到哪个是leader；依赖Consul的raft协议选举判断网络孤岛；(为了后续描述简单，假设每个IDC只部署一个Consul结点)</li>
<li>每个IDC的service只访问当前IDC对应的Consul结点；当访问返回“No cluster leader”时，说明该网络分区已经是”孤岛”；<pre>
curl 'http://consul:8500/v1/health/service/nodeName?passing&wait=1s&index=1&tag=master'
No cluster leader
</pre></li>
<li>通过“No cluster leader”来判断孤岛的前提是，假设Consul是高可用的。因为当有两个Consul结点无法访问或挂掉的时候，也有能误判成没有leader（实际上并未出现网络孤岛，只是Consul集群异常）；</li>
<li>引入双重检查机制，解决Consul集群因为可用性问题导致的误判的可能性；在Consul判断为网络孤岛的情况下，通过ping异地IDC的service的健康检查接口，二次确认；双重检查机制只能解决误判问题，若Consul集群不能高可用，那么判断孤岛的机制将失效。</li>
</ol>
<h4 id="如何处理“孤岛”？"><a href="#如何处理“孤岛”？" class="headerlink" title="如何处理“孤岛”？"></a>如何处理“孤岛”？</h4><ol>
<li>判断为孤岛的网络分区的服务，如果接收到外网请求(因为是孤岛情况下其他IDC内网不通)，可以拒绝服务，也可以返回特殊的业务错误码或HTTP错误码，由上层服务或客户端重试到其他的机房。</li>
</ol>
<h4 id="“孤岛”消失后如何恢复？"><a href="#“孤岛”消失后如何恢复？" class="headerlink" title="“孤岛”消失后如何恢复？"></a>“孤岛”消失后如何恢复？</h4><ol>
<li>手动恢复。”孤岛”的网络分区服务不恢复提供服务，由开发人员确认DB等无异常后再手动恢复；</li>
<li>自动恢复。需做好充分的检测手段才能启用自动恢复：DB是否发生切换、主从DB数据是否一致（如比对脚本）、判断网络是否已经恢复到策略(防止来回切)等。</li>
</ol>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="为什么每个IDC的service只访问当前IDC对应的Consul结点？-前提是Consul高可用性"><a href="#为什么每个IDC的service只访问当前IDC对应的Consul结点？-前提是Consul高可用性" class="headerlink" title="为什么每个IDC的service只访问当前IDC对应的Consul结点？(前提是Consul高可用性)"></a>为什么每个IDC的service只访问当前IDC对应的Consul结点？(前提是Consul高可用性)</h4><ol>
<li>假设IDC-A出现网络孤岛的情况下，IDC-A的service本身就无法访问IDC-B的Consul结点；</li>
<li>假设IDC-B未出现网络孤岛，IDC-A的service只需要访问IDC-A的Consul结点即可判断；</li>
</ol>
<h4 id="选主服务一定要选择基于去中心一致性协议的组件吗？"><a href="#选主服务一定要选择基于去中心一致性协议的组件吗？" class="headerlink" title="选主服务一定要选择基于去中心一致性协议的组件吗？"></a>选主服务一定要选择基于去中心一致性协议的组件吗？</h4><ol>
<li>不一定。使用选主服务只是利用组件高可用性和选举机制解决脑裂问题。Raft等去中心一致性的协议解决的的一致性问题及其leader的选举机制。换句话，只要该组件能高可用且在结点大多数存活（网络互通）的情况下，能选举出一个Leader即可，数据的一致性并不重要（因为没用到组件提供的数据存储功能）。</li>
<li>一般情况下，业务使用MHA-Consul-MySQL作为DB切换的高可用方案；那么解决脑裂问题，也使用Consul组件，也可以减少服务对其他组件的依赖。</li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol>
<li>Group Replication<ul>
<li>Group Replication由至少3个或更多个节点共同组成一个数据库集群，事务的提交必须经过半数以上节点同意方可提交，在集群中每个节点上都维护一个数据库状态机，保证节点间事务的一致性。Group Replication基于分布式一致性算法Paxos实现，允许部分节点故障，只要保证半数以上节点存活，就不影响对外提供数据库服务，是一个真正可用的高可用数据库集群技术。 Group Replication支持两种模式，单主模式和多主模式。在同一个group内，不允许两种模式同时存在，并且若要切换到不同模式，必须修改配置后重新启动集群。 在单主模式下，只有一个节点可以对外提供读写事务的服务，而其它所有节点只能提供只读事务的服务，这也是官方推荐的Group Replication复制模式。</li>
</ul>
</li>
<li>NewSQL<ul>
<li>关于NewSQL的定义是：这是一类现代关系型的DBMS，旨在为NoSQL的OLTP读写负载提供相同的可扩展性能，同时仍然提供事务的ACID保证。</li>
<li>TiDB。TiDB 是一个分布式 NewSQL 数据库。它支持水平弹性扩展、ACID 事务、标准 SQL、MySQL 语法和 MySQL 协议，具有数据强一致的高可用特性，是一个不仅适合 OLTP 场景还适OLAP 场景的混合数据库。</li>
</ul>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>刘杰：分布式原理介绍</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5626889.html">分布式系统理论之Quorum机制</a></li>
<li><a target="_blank" rel="noopener" href="https://kingson4wu.gitee.io/2020/08/31/20200831-%E5%85%B3%E4%BA%8EMHA-Consul-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83/">关于MHA_Consul_MySQL高可用方案的简单总结和思考</a></li>
<li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2017/08/01/">MySQL · 引擎特性 · Group Replication内核解析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/71073707">我们听到的TiDB到底是什么？</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/" itemprop="url">关于MHA_Consul_MySQL高可用方案的简单总结和思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-31T21:39:33+08:00">
                2020-08-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MHA + Consul + MySQL的高可用方案，网上已经有很多资料，这里只是做一下简要的总结和思考。文章部分文字摘自Reference中的链接。<br>直接先上一张图</p>
<p><img src="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/MHA_Consul_MySQL%E5%88%87%E6%8D%A2.png"></p>
<ol>
<li>图中的灾备架构适用于同城主备架构的业务，比如金钱业务；</li>
<li>DB层是一主多从，主库至在其中一个机房，并在DB集群上搭建跨IDC的MHA；同样Consul也是跨IDC的集群；</li>
<li>业务的写主流量配置在主库机房的一侧，当主库故障发生DB切换产生新主库时，流量也跟从新主库一同切换；</li>
<li>主库切换通过MHA完成，并通过Consul集群和应用的SDK通知到业务服务。</li>
<li>MySQL采用默认的异步复制方式</li>
</ol>
<h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><ol>
<li>解决MySQL的单点问题。当主库发生故障时能提升从库为新的主库，且应用层能自动识别；从而缩短故障的处理时间；</li>
<li>通过Consul能支持从库的故障切换以及从库扩容或下线；</li>
</ol>
<h3 id="每个组件各自的作用"><a href="#每个组件各自的作用" class="headerlink" title="每个组件各自的作用"></a>每个组件各自的作用</h3><ol>
<li>MHA：监控主节点，可以在故障时自动或手动切换、非故障时手动主从切换。切换时会进行数据补齐，并将新的master信息更新到consul中。</li>
<li>Consul：MySQL服务注册并提供健康检查、记录最新的master；还可以提供其他配置性的服务，比如dns，可解析数据库域名。</li>
<li>SDK: sdk通过consul-api监控MySQL ip列表的变化，能连接新的库和去掉已下线的库。</li>
</ol>
<p>下面的部分将对使用到的技术逐一简要描述和总结。</p>
<h2 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre>
MySQL MHA架构介绍：

MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。

该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。

在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。

目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。（出自：《深入浅出MySQL(第二版)》）
</pre>

<pre>
MHA工作原理总结为以下几条：
（1）从宕机崩溃的master保存二进制日志事件（binlog events）;
（2）识别含有最新更新的slave;
（3）应用差异的中继日志(relay log) 到其他slave;
（4）应用从master保存的二进制日志事件(binlog events);
（5）提升一个slave为新master;
（6）使用其他的slave连接新的master进行复制。
</pre>

<pre>
自带脚本：
自动切换脚本：/usr/local/bin/master_ip_failover
手动切换脚本：/usr/local/bin/master_ip_online_change
</pre>

<h3 id="图中的MHA阐述"><a href="#图中的MHA阐述" class="headerlink" title="图中的MHA阐述"></a>图中的MHA阐述</h3><ol>
<li>服务为主备架构，部署在IDC-A和IDC-B，其中主流量在IDC-A；MHA MANAGER则部署在IDC-C（第三个机房），这样才能保证任意一边的IDC出问题，都不影响MHA的切换；</li>
<li>为了防止来回切导致严重数据问题。可以设置，当MHA发生自动切换时，MHA MANAGER无论成功与否都会退出；</li>
<li>MHA在故障时可以进行数据补齐。</li>
</ol>
<h2 id="MySQL-半同步复制"><a href="#MySQL-半同步复制" class="headerlink" title="MySQL 半同步复制"></a>MySQL 半同步复制</h2><h3 id="主从复制的基本原理"><a href="#主从复制的基本原理" class="headerlink" title="主从复制的基本原理"></a>主从复制的基本原理</h3><ol>
<li>[master] SQL操作存入binLog中;</li>
<li>[slave] 连接master，进行数据同步;</li>
<li>[master] dump thread 把binlog数据发送到slave中;</li>
<li>[slave] 创建I&#x2F;O线程读取 master传输过来的binlog内容并写入到relay Log;</li>
<li>[slave] 创建SQL线程，从relay Log读取并执行。</li>
</ol>
<h3 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h3><ol>
<li><p>异步复制（Asynchronous replication）</p>
<ul>
<li>MySQL默认的复制即是异步的，主库先提交事务，然后立即响应客户端。</li>
<li>如果主库crash，且主库上已经提交的事务还没有同步到相应的从库上，那么当从库提升为主时，会导致新主上的数据不完整。</li>
<li>性能最好</li>
</ul>
</li>
<li><p>全同步复制（Fully synchronous replication）</p>
<ul>
<li>当主库执行完一个事务，且所有的从库都同步完之后才响应客户端。</li>
<li>性能差</li>
</ul>
</li>
<li><p>半同步复制（Semisynchronous replication）</p>
<ul>
<li>AFTER_COMMIT；即参数 rpl_semi_sync_master_wait_point &#x3D; after_commit</li>
<li>介于异步复制和全同步复制之间，主库提交完事务之后不立即响应客户端，而是等待至少一个从库接收到并写到relay log中才响应客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</li>
<li>等待的时间以rpl_semi_sync_master_timeout参数为准，默认为10秒。在这等待的10秒里，对其他会话该事务是可见的；所以一旦master发生宕机，对外就会产生不一致的影响</li>
<li>Slave ACK超时，将退化为异步复制模式 （所以半同步复制并不是严格意义上的半同步复制）</li>
</ul>
</li>
<li><p>增强半同步（Loss-less Semi-Synchronous）</p>
<ul>
<li>AFTER_SYNC；即参数 rpl_semi_sync_master_wait_point &#x3D; after_sync</li>
<li>after sync是MySQL5.7官方新加以解决MySQL5.6半同步缺陷的选项，也是官方推荐的方式。</li>
<li>原理：客户端发送过来一个请求，经过mysql的SQL分析，存储引擎处理，写入binlog，然后		写入从库的relaylog，存储引擎层提交，最后返回给客户端。</li>
<li>优点：主库把SQL操作先发给从库的relay log，然后再提交，再响应给客户端，这个过程即使		在storage commit之后主crash了，日志也已经写入到relay log中，从库和主库数据一致。</li>
<li>在commit之前等待Slave ACK，可以堆积事务，利于group commit，有利于提升性能。</li>
<li>在master接受到Slave ACK之前，数据的变化对其他会话时不可见的，因为此时并未提交，从	而也不会产生数据不一致的影响。</li>
<li>同样，Ack超时，也将退化为异步复制模式</li>
</ul>
</li>
<li><p>组复制 MySQL Group Replication（MGR）</p>
<ul>
<li>MGR内部实现了分布式数据一致性协议，paxos通过其来保证数据一致性。</li>
</ul>
</li>
</ol>
<h3 id="after-commit-VS-after-sync"><a href="#after-commit-VS-after-sync" class="headerlink" title="after_commit VS after_sync"></a>after_commit VS after_sync</h3><p><img src="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/after_commit.png"><br><img src="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/after_sync.png"></p>
<ul>
<li>after_commit：master把每一个事务写到二进制日志并保存到磁盘上，并且提交（commit）事务，再把事务发送给从库，开始等待slave的应答。响应后master返回结果给客户端，客户端才可继续。</li>
<li>after_sync  ：master把每一个事务写到二进制日志并保存磁盘上，并且把事务发送给从库，开始等待slave的应答。确认slave响应后，再提交（commit）事务到存储引擎，并返回结果给客户端，客户端才可继续。</li>
<li>半同步和增强半同步都是等待slave的ACK后才给客户端返回成功（也就是整个流程完成）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/MySQL_copy.png"></p>
<ul>
<li>一致性要求高的，比如金融类的（相比其他业务TPS较低），可以考虑开启增强半同步复制</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>MySQL 5.7新增了rpl_semi_sync_master_wait_for_slave_count系统变量，可以用来控制主库接收多少个从库写事务成功反馈，给高可用架构切换提供了灵活性。	当该变量值为2时，主库需等待两个从库的ACK。</li>
</ol>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>Consul is a tool for service discovery and configuration. Consul is distributed, highly available, and extremely scalable</li>
<li>Consul是一个服务管理软件。支持多数据中心下，分布式高可用的，服务发现和配置共享。采用 Raft 算法,用来保证服务的高可用。</li>
<li>Consul使用Gossip Protocol来管理成员资格并向集群广播消息。所有这些都是通过使用Serf库提供的。</li>
<li>关于raft算法原理，可以后续再讲。</li>
</ul>
<h3 id="和MHA的结合使用"><a href="#和MHA的结合使用" class="headerlink" title="和MHA的结合使用"></a>和MHA的结合使用</h3><ol>
<li>checkmysql 脚本部署到每台 consul server 中, 实现了多点检测 MySQL 是否正常;</li>
<li>checkmysql 脚本在超过半数的情况下调用 masterha_manager_consul 脚本进行主从切换;</li>
</ol>
<h4 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h4><ul>
<li>MHA 是切换工具，控制数据库主从切换和数据补齐；</li>
<li>MHA 进行故障检测，故障时进行切换并通知Consul下发新的主库配置到应用服务。</li>
</ul>
<h4 id="从库上下线"><a href="#从库上下线" class="headerlink" title="从库上下线"></a>从库上下线</h4><ul>
<li>Consul可以对从库进行健康检查，通过配置下发控制从库上下线。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="CMDB"><a href="#CMDB" class="headerlink" title="CMDB"></a>CMDB</h3><ul>
<li>配置管理数据库( Configuration Management Database,CMDB)</li>
<li>自动化运维立足之本。在容灾切换管理工具中，可以直接一键从CMDB中同步所有业务系统，并能够非常灵活的定义每个业务系统的切换过程环节以及每个环节所有执行的具体操作。</li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/031028/2426950">CMDB与容灾备份的关联</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/302057">好的CMDB建设，应该具备这些要素</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42556618/article/details/107345128">【运维探讨】如何实现更加简单、高效、安全的灾备切换管理？</a></li>
</ul>
<h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><ul>
<li>脑裂问题是分布式多活建设必须面临的问题之一。</li>
<li>以上面的架构进行描述，当IDC-A和IDC-B、IDC-C网络不通时，其实IDC-A就是一个网络孤岛。<br>这时候时IDC-B中的从库就会提升为主库，并开始接收写操作。因为IDC-A已经是个数据孤岛，服务的主从库并未发生改变(接收不到consul下发的配置)，此时也接受外部的写操作请求，那么就会造成两边数据都有写操作，错误的双主架构导致错误的数据问题。</li>
</ul>
<h4 id="如何避免脑裂问题"><a href="#如何避免脑裂问题" class="headerlink" title="如何避免脑裂问题"></a>如何避免脑裂问题</h4><ol>
<li>如何让IDC的服务可以判断自身是否孤岛，从而拒绝服务，避免数据问题呢？</li>
<li>其中一个方案使用Consul作为选主服务来解决。后续另开文章叙述。</li>
<li>使用etcd：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VFJg14JcapijOyhfJJMYUg">etcd 实现故障时主备秒级切换高可用架构</a></li>
<li>分布式锁服务Chubby（参见文献[Bur06]）集群锁服务提供一个与文件系统类似的API用来操作锁。Chubby 可以处理异地、跨机房级别的锁请求。Chubby 使用Paxos协议来提供分布式一致性（具体描述参看第23章）。Chubby 是实现主实例选举（Master-Election）过程的关键组件。例如，一个服务有5个冗余实例在同时运行，但是只有一个实例可以处理对外请求，一般的做法是通过Chubby进行自动选举，选择一个实例成为主实例。Chubby适合存放那种对一致性要求非常高的数据。—《SRE：Google运维解密》</li>
</ol>
<h4 id="结合raft的思考"><a href="#结合raft的思考" class="headerlink" title="结合raft的思考"></a>结合raft的思考</h4><ul>
<li>为了避免脑裂，需要有选主机制，一般超半数的投票才能成为leader；Consul就是基于raft是实现的；</li>
<li>在线上部署consul必须至少是三个机房，因为如果只有两个机房，其中一个机房挂了（刚好是大多数机器的机房），服务将不可用；</li>
<li>分布式存储系统，需要解决数据的一致性问题和脑裂问题。<ol>
<li>raft有实现，但是首先得基于raft协议的文件存储；</li>
<li>使用MySQL作为存储，Consul作为选主服务的业务：Consul可以解决脑裂问题<ul>
<li>MySQL的增强半同步复制机制 支持配置n个从库ack才响应客户端（其实和raft大多数结点写成功才算成功有点类似[Quorum机制]），可以很大程度的避免丢数据导致不一致。</li>
</ul>
</li>
</ol>
</li>
<li>一般金钱业务使用同城两个机房，主备架构，那么不能完全和raft三机房匹配（三机房意味着一定每个机房至少有一个结点接收到数据才算成功）。当然每个机房可以有多个DB，比如同城的两个机房A合B，A有一主一丛，B有两从。增强半同步可以根据实际情况配置rpl_semi_sync_master_wait_for_slave_count参数，指定必须多少个从库成功。<ul>
<li>MySQL使用异步复制的，一般情况下，切完机房保持数据一致性或检查监控数据一致性的方案，需要业务方自行监控和修正。</li>
<li>就算使用了增强半同步，理论上数据也只是落盘到relay log，极端情况下，从库也可以立马故障，甚至无法恢复。这种极端情况基本不考虑了，只能业务自己权衡，允不允许丢数据，有没有其他修复数据机制（日志文件或对账等），要不要继续提供服务了。</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="为什么Dump和I-x2F-O线程不能多线程？"><a href="#为什么Dump和I-x2F-O线程不能多线程？" class="headerlink" title="为什么Dump和I&#x2F;O线程不能多线程？"></a>为什么Dump和I&#x2F;O线程不能多线程？</h3><ol>
<li>dump线程和IO线程都是负责网络传输，如果将这里扩展为多线程那么会将一份Binlog日志分割为多份，并行传输，那么在slave端将会要额外的增加代码考虑如何将多份日志还原为原来的Binlog，大大增加难度。</li>
<li>性能瓶颈不在IO，扩展后也没有多大效率提升。</li>
<li>为什么Redis 6.0使用IO多线程增强性能，MySQL这里使用IO多线程却不行？<ul>
<li>Redis是多个Client节点一个Server节点（暂且这么看），IO线程需要处理多个不同Client来源的请求；MySQL主从复制，本质上是1个Client端一个Server端，增大IO线程也无济于事。</li>
</ul>
</li>
</ol>
<h3 id="增强半同步是否会导致从有数据而主却没有？"><a href="#增强半同步是否会导致从有数据而主却没有？" class="headerlink" title="增强半同步是否会导致从有数据而主却没有？"></a>增强半同步是否会导致从有数据而主却没有？</h3><ul>
<li>是。在Loss-less Semi-Synchronous模式下，master在调用binlog sync之后，engine层commit之前等待Slave ACK（需要收到至少一个Slave节点回复的ACK后）。这样只有在确认Slave收到事务events后，master事务才会提交，然后把结果返回给客户端。此时此事务才对其他事务可见。在这种模式下解决了after_commit模式带来的幻读和数据丢失问题，因为主库没有提交事务。但也会有个问题，假设主库在存储引擎提交之前挂了，那么很明显这个事务是不成功的，但由于对应的Binlog已经做了Sync操作，从库已经收到了这些Binlog，并且执行成功，相当于在从库上多了数据，也算是有问题的，但多了数据，问题一般不算严重。这个问题可以这样理解，作为MySQL，在没办法解决分布式数据一致性问题的情况下，它能保证的是不丢数据，多了数据总比丢数据要好。</li>
</ul>
<h3 id="MHA本身就支持自动切，为什么还要使用Consul？"><a href="#MHA本身就支持自动切，为什么还要使用Consul？" class="headerlink" title="MHA本身就支持自动切，为什么还要使用Consul？"></a>MHA本身就支持自动切，为什么还要使用Consul？</h3><ul>
<li>MHA本身提供了自动切换主库的功能，但是MHA本身没有提供通知应用等机制。因此采用比较成熟的方案MHA+consul，并以SDK的方式接入。</li>
</ul>
<h3 id="自动切换安全吗？"><a href="#自动切换安全吗？" class="headerlink" title="自动切换安全吗？"></a>自动切换安全吗？</h3><ol>
<li>直接启用masterha_manager 自动切换脚本并不安全，主要因为在网络抖动的情况下并不能保证数据库真的不能访问。不能仅通过一个点的检测就判断数据库不可访问。</li>
<li>通过 Consul( Consul 提供 dns 接口)集群的特性, 增加多点检测机制, 在 n 个集群的环境中, 有超过半数的检测点检测到数据库有问题, 就认为数据库不可访问, 这时调用 masterha_manager 脚本进行切换。</li>
<li>网络问题千变万化，在发生切换事件之后，需有相应的方案对主从流水数据进行对账或修正（确定基于binlog与应用日志的重要数据校验与补偿机制）。</li>
<li>发生切换事件之后，在确定数据已经无异常之前，需要防止再自动切回去，造成严重的数据异常。所以一般情况下，只能自动切一次，直到人工介入确认无异常，重新设置为自动切模式。当然，有完善的监控比对数据异常机制的情况下，可以考虑做成自动化，无需依赖人工介入。</li>
</ol>
<h3 id="MHA切换之后，主库禁写后，现有的连接是否还能继续写入"><a href="#MHA切换之后，主库禁写后，现有的连接是否还能继续写入" class="headerlink" title="MHA切换之后，主库禁写后，现有的连接是否还能继续写入?"></a>MHA切换之后，主库禁写后，现有的连接是否还能继续写入?</h3><p><img src="/2020/08/31/20200831-guan-yu-mha-consul-mysql-gao-ke-yong-fang-an-de-jian-dan-zong-jie-he-si-kao/MySQL_%E6%9D%83%E9%99%90.png"><br>mha切库禁写时，直接锁住整个实例，新操作无法写入，直接就设置read_only。</p>
<h3 id="自动切的时机如何把握？"><a href="#自动切的时机如何把握？" class="headerlink" title="自动切的时机如何把握？"></a>自动切的时机如何把握？</h3><ol>
<li>自动切的最佳时机很难人为，必须经过多种故障场景的测试，确定合适尽可能安全的切换策略和参数。</li>
<li>在实践中，初期可以先告警人工介入决定是否切换；确定好合适的切换策略和参数后，自动切在非核心业务中稳定正确运行一段时间后才在核心业务运用。</li>
</ol>
<h3 id="MHA能保证数据一定不丢吗？"><a href="#MHA能保证数据一定不丢吗？" class="headerlink" title="MHA能保证数据一定不丢吗？"></a>MHA能保证数据一定不丢吗？</h3><ul>
<li>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失。但如上所述，网络等问题时无解的，理论上还是存在丢的可能性。一致性要求高的，比如金钱类的（相比其他业务TPS较低），可以考虑开启半同步复制，大大降低数据丢失的风险。</li>
</ul>
<h3 id="新的主库和原主库数据一致性问题如何解决？"><a href="#新的主库和原主库数据一致性问题如何解决？" class="headerlink" title="新的主库和原主库数据一致性问题如何解决？"></a>新的主库和原主库数据一致性问题如何解决？</h3><ol>
<li>MHA只能尽量保证数据补齐；</li>
<li>主从延迟较大时，切主库有风险；</li>
<li>开启半同步复制可以大大降低丢数据的风险，但也带来一定的性能损耗；</li>
<li>要做好切库后，主从日志流水对比修复方案</li>
</ol>
<h3 id="不一致如何止损？"><a href="#不一致如何止损？" class="headerlink" title="不一致如何止损？"></a>不一致如何止损？</h3><ol>
<li>根据业务情况进行实现，比如在发生切换事件的一端时间内(比如一个小时)，阻断大额交易操作，等待开发确认后再恢复；</li>
<li>具体实现可以使用redis存储数据快照，执行前和数据库的数据进行对比判断是否阻断，或其他可行方案；</li>
<li>是否应该阻断，公司的利益和用户的利益，这是个哲学问题。。。</li>
</ol>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>云数据库使用数据库代理进行连接:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/236/72619">读写分离扩展云数据库 MySQL 性能</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/236/35671">切换网络</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arstercz/p/6963920.html">基于 consul 架构的 MHA 自动切换</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangjianrong1985/article/details/102479034">基于MHA+consul的MySQL高可用设计</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuanzhi201111/p/4231412.html">MySQL高可用之MHA的搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://code.google.com/p/mysql-master-ha/">MHA官方介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3MzYwNjQ3NA==&mid=2651297535&idx=1&sn=2138d7d09cf5294c73810b133eed67e3&chksm=84ff42dab388cbcc90d9642b6cd3ed5de8e524cc10737947ce0c46eb287e95f4bae62472fa24&mpshare=1&scene=1&srcid=0518czFAsyzFLKkM07SIauWS#rd">京东MySQL数据库主从切换自动化</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunss/archive/2010/10/05/1844204.html">MySQL数据库的授权原则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoujinyi/p/3808673.html">MySQL MHA 搭建&amp;测试</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ivictor/p/5735580.html">MySQL半同步复制</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33330687/article/details/107496954">MySQL - 异步复制，半同步复制，增强半同步复制，组复制，全告诉你</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1537291">mysql 半同步复制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/allenhu320/p/11316276.html">增强半同步复制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3bfb0bfb8b34">【MySQL】5.7增强半同步AFTER SYNC&amp;AFTER COMMIT</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/20200831-shi-yong-redis-shi-xian-bang-dan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/31/20200831-shi-yong-redis-shi-xian-bang-dan/" itemprop="url">使用Redis实现榜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-31T21:14:24+08:00">
                2020-08-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/31/20200831-shi-yong-redis-shi-xian-bang-dan/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/31/20200831-shi-yong-redis-shi-xian-bang-dan/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><ol>
<li>使用redis实现</li>
<li>基于直播间业务场景</li>
<li>不阐述详细实现细节</li>
</ol>
<h3 id="二、相关Redis数据结构和命令"><a href="#二、相关Redis数据结构和命令" class="headerlink" title="二、相关Redis数据结构和命令"></a>二、相关Redis数据结构和命令</h3><h4 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h4><ol>
<li>Sismember 命令判断成员元素是否是集合的成员。</li>
</ol>
<h4 id="Redis-有序集合-sorted-set"><a href="#Redis-有序集合-sorted-set" class="headerlink" title="Redis 有序集合(sorted set)"></a>Redis 有序集合(sorted set)</h4><ol>
<li>Zrevrank 命令返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</li>
<li>Zincrby 命令对有序集合中指定成员的分数加上增量 increment</li>
<li>Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列</li>
<li>Zremrangebyrank 命令用于移除有序集中，指定排名(rank)区间内的所有成员。</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>查找特定前缀key：scan命令</li>
</ol>
<h3 id="三、如何实现"><a href="#三、如何实现" class="headerlink" title="三、如何实现"></a>三、如何实现</h3><h4 id="榜单保存"><a href="#榜单保存" class="headerlink" title="榜单保存"></a>榜单保存</h4><ol>
<li>使用 Redis 有序集合(sorted set)保存榜单数据</li>
<li>如果是按时间排序的榜单，把时间戳存到score字段；如果是按礼物数量排序，把数量存到score；其他排序场景同理</li>
</ol>
<h4 id="榜单添加数据操作幂等"><a href="#榜单添加数据操作幂等" class="headerlink" title="榜单添加数据操作幂等"></a>榜单添加数据操作幂等</h4><ol>
<li>使用数据库日志表（唯一索引） （最严格可靠）</li>
<li>使用一个set保存所有的消息ID，并使用sismember防止重复处理（并发场景可能不幂等）</li>
</ol>
<h4 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h4><ol>
<li>使用一个set保存现有所有在线的房间榜单；定时任务检查房间是否在播，不在线的进行清理（同时可以监听房间下播时间）</li>
<li>保存一定数量的redis榜单：Zremrangebyrank 命令用于移除有序集中，指定排名(rank)区间内的所有成员</li>
<li>使用scan命令 查找特定前缀key的榜单，同1或2操作进行清理</li>
</ol>
<h3 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h3><ol>
<li>房间榜单的标识是房间id有时可能不够，因为通过榜单有时是和本场开播挂钩的，同一个房间多次开播，可能导致不同场次的数据导致榜单错误。<br>增加房间开播id标识可以解决。</li>
<li>老生常谈的哲学问题:二八定理。花费大量时间来得到较低的收益，实现时要从业务看是否值得。但不代表在做设计方案时不去考虑，这是严谨性的问题。<br>按极端的方式考虑，实际实现按业务需要进行选择折中。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/20/20200820-guan-yu-cdn-huan-cun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/20/20200820-guan-yu-cdn-huan-cun/" itemprop="url">关于CDN缓存总结摘要</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-20T22:06:31+08:00">
                2020-08-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/20/20200820-guan-yu-cdn-huan-cun/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/20/20200820-guan-yu-cdn-huan-cun/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CDN缓存的几点总结"><a href="#CDN缓存的几点总结" class="headerlink" title="CDN缓存的几点总结"></a>CDN缓存的几点总结</h3><ol>
<li>CDN资源的标识: url</li>
<li>跟HTTP缓存无关的请求头不影响CDN缓存（亲测）</li>
<li>不仅是静态资源，接口的数据可以做CDN缓存（亲测）</li>
<li>CDN服务一般都有默认的缓存配置（比如一分钟），服务端可以通过设置HTTP缓存相关的Header控制是否适用CDN缓存</li>
<li>HTTP缓存和CDN缓存分别作为客户端缓存和服务端缓存</li>
</ol>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>关键字段有Expires，Cache-Control ，Last-Modified ，Etag 四个字段，Expires和Cache-Control用来确定确定缓存的存储时间，Last-Modified 和Etag则用来确定缓存是否要被更新</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>控制强制缓存的字段分别是Cache-Control和Expires，其中Cache-Control优先级比Expires高</p>
<ol>
<li>Expires: HTTP1.0的，已废弃</li>
<li>Cache-Control: HTTP1.1中用来控制缓存时间的参数 (Cache-Control:max-age&#x3D;30;xxx;)<pre>
public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。
private: 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。
max-age=seconds: 设置缓存存储的最大周期，相对于请求的时间缓存seconds秒，在此时间内，访问资源直接读取本地缓存，不向服务器发出请求。（与expires同时出现时，max-age优先级更高）
s-maxage=seconds: 规则等同max-age，覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。（与expires或max-age同时出现时，s-maxage优先级更高）
no-store: 不缓存服务器响应的任何内容，每次访问资源都需要服务器完整响应
no-cache: 缓存资源，但立即过期，每次请求都需要跟服务器对比验证资源是否被修改。（等同于max-age=0）
</pre></li>
</ol>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。</p>
<ol start="2">
<li>Last-modified: 源头服务器认定的资源做出修改的日期及时间。精确度比Etag低。包含有If-Modified-Since或 If-Unmodified-Since首部的条件请求会使用这个字段。</li>
<li>Etag: HTTP响应头是资源的特定版本的标识符。</li>
</ol>
<h4 id="如何控制不使用缓存"><a href="#如何控制不使用缓存" class="headerlink" title="如何控制不使用缓存"></a>如何控制不使用缓存</h4><ul>
<li>F5刷新：<br>(Cache-Control: max-age&#x3D;0)<br>浏览器会设置max-age&#x3D;0，跳过强缓存判断，会进行协商缓存判断【浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match（如果上一次response带Last-Modified, Etag）这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.】</li>
<li>强制刷新 (command+shift+R)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。<br>ctrl+F5强制刷新：<br>(Cache-Control: no-cache)<br>跳过强缓存和协商缓存，直接从服务器拉取资源。【浏览器不仅会对本地文件过期，而且不会带上If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.】</li>
<li>如何不缓存<br>Cache-Control其他字段：<br>no-cache: 虽然字面意义是“不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须向服务器对缓存资源进行验证。<br>no-store: 不使用任何缓存<br>禁止缓存：<br>Cache-Control: no-cache, no-store, must-revalidate<br>Expires：设为当前时间之前</li>
<li>强缓存存在两种形式：from memory cache 与 from disk cache (浏览器F12查看)</li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><ul>
<li>cdn缓存是一种服务端缓存</li>
<li>与http缓存规则不同的是，这个规则并不是规范性的，而是由cdn服务商来制定</li>
<li>回源的意思就是返回源站，何为源站，就是我们自己的服务器;CDN回源，没有资源就去源站读取，有资源就直接发送给用户。</li>
<li>cdn缓存配置，整体来说，建议和http缓存配置保持统一</li>
</ul>
<h4 id="不一致的影响"><a href="#不一致的影响" class="headerlink" title="不一致的影响"></a>不一致的影响</h4><p>cdn的缓存配置会受到http缓存配置的影响，而且各个cdn服务商并不完全一致，以腾讯云为例，在缓存配置的文档中特别有以下说明。<br>这会对我们有什么影响呢？</p>
<ol>
<li>如果我们http缓存设置cache-control: max-age&#x3D;600，即缓存10分钟，但cdn缓存配置中设置文件缓存时间为1小时，那么就会出现如下情况，文件被访问后第12分钟修改并上传到服务器，用户重新访问资源，响应码会是304，对比缓存未修改，资源依然是旧的，一个小时后再次访问才能更新为最新资源</li>
<li>如果不设置cache-control呢，在http缓存中我们说过，如果不设置cache-control，那么会有默认的缓存时间，但在这里，cdn服务商明确会在没有cache-control字段时主动帮我们添加cache-control: max-age&#x3D;600。<br>注：针对问题1，也并非没有办法，当我们必须要在缓存期内修改文件，并且不向想影响用户体验，那么我们可以使用cdn服务商提供的强制更新缓存功能，主要注意的是，这里的强制更新是更新服务端缓存，http缓存依然按照http头部规则进行自己的缓存处理，并不会受到影响。</li>
</ol>
<h4 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h4><ul>
<li>cdn缓存的配置并不复杂， 复杂的情况在于cdn缓存配置会受到http缓存配置的影响，并且不同的cdn运营商对于这种影响的处理也都不一致，实际使用时，建议去对应的cdn服务商文档中找到对应的注意事项。</li>
<li>CDN缓存控制:如果源站设置了 no-cache 、private、 max-age &#x3D; 0 都遵循源站，CDN 是不会进行缓存的。</li>
<li>又拍云为开发者执行缓存刷新提供了主动更新和被动更新两种方式。<ol>
<li>主动更新主要是指同名资源在源服务器更新之后，开发者手动刷新文件。又拍云提供了可视化的操作台供用户执行缓存刷新操作，同时支持 URL 刷新和规则刷新。此外开发者也可通过 API 接口完成刷新操作。</li>
<li>被动刷新则是等文件在 CDN 节点的缓存过期之后，节点回源拉取源服务器上最新的文件。这个过程由 CDN 自动完成，无需手动操作。</li>
</ol>
</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eb974c412399">动态CDN加速</a></p>
</li>
<li><p>CDN的全称是Content Delivery Network，即内容分发网络</p>
</li>
<li><p>动态CDN加速:非静态数据，通过CDN的加速来起到快速回源的效果的。使用到的就是CDN的快速传输的能力。其实也就是DSA(Dynamic Site Acceleration)</p>
<ul>
<li>传统的DSA有:<ul>
<li>TCP 优化：设计算法来处理网络拥堵和包丢失，加快这些情况下的数据从cdn的恢复以及一些常见的TCP瓶颈</li>
<li>Route optimization：就是优化从源到用户端的请求的线路，以及可靠性，就是不断的测量计算得到更快更可靠的路线</li>
<li>Connection management：就是边缘和源之间，包括CDN之前的线路，采用长连接，而不是每一个请求一个连接</li>
<li>On-the-fly compression：就是数据在刚刚离开源的时候就进行压缩，可以缩短在整个网络之中的流通时间</li>
<li>SSL offload：加速或者说减少一些安全监测，减少原服务器执行这种计算密集型的压力</li>
<li>Pre-fetching：有的服务可以解析HTML文件，并将原始服务器预取缓存对象嵌入到文件中</li>
</ul>
</li>
<li>更可靠的连接(只要负责连接边缘服务器，如果直接走回源线路的话，线路会很长，不可靠)</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/EasonJim/p/8323578.html">使用CDN隐藏服务器真实IP</a></p>
<ul>
<li>隐藏服务器真实IP是解决问题最好和最快的方法，但只针对小流量，大流量同样会扛不住。<br>服务器前端加CDN中转，比如阿里云、百度云加速、360网站卫士、加速乐、安全宝等，如果资金充裕的话，可以购买高防的盾机，用于隐藏服务器真实IP，域名解析使用CDN的IP，所有解析的子域名都使用CDN的IP地址。此外，服务器上部署的其他域名也不能使用真实IP解析，全部都使用CDN来解析。</li>
<li>另外防止服务器对外传送信息泄漏IP，最常见的是，服务器不使用发送邮件功能，如果非要发送邮件，可以通过第三方代理(例如sendcloud)发送，这样对外显示的IP是代理的IP。</li>
</ul>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/baf12d367fe7">聊聊 CDN 缓存与浏览器缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34043301/article/details/87964291">http缓存与cdn缓存配置指南</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83486624">CDN 基础架构及缓存控制</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006673084">从HTTP响应头看各家CDN缓存技术</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58685072">HTTP 缓存机制</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/" itemprop="url">打赏类业务货币体系简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-04T00:08:36+08:00">
                2020-08-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在打赏类业务中，消费跟分成是紧紧挂钩的。比如在直播间送礼，用户通过花费虚拟货币给对方送礼，而对方则得到相应的分成。</li>
<li>定义：用户花费的是“金币”，接受者得到的是“银币”。</li>
</ul>
<h3 id="设计概要"><a href="#设计概要" class="headerlink" title="设计概要"></a>设计概要</h3><p><img src="/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/%E9%87%91%E9%92%B1%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB.png"></p>
<h4 id="一、用户货币类型组成"><a href="#一、用户货币类型组成" class="headerlink" title="一、用户货币类型组成"></a>一、用户货币类型组成</h4><ol>
<li>用户通过充值或活动赠币等方式得到“金币(coin)”<ul>
<li>充值行为得到的是“充值金币(money)”</li>
<li>活动赠币等非充值行为得到的是“非充值金币(virtualCoin)”</li>
<li>coin&#x3D;money + virtualCoin</li>
</ul>
</li>
<li>消费行为的接受者（收益方）得到的是“银币(bean)”</li>
</ol>
<h4 id="二、业务情况"><a href="#二、业务情况" class="headerlink" title="二、业务情况"></a>二、业务情况</h4><p>所有的业务场景其实都是对上述几种货币类型的加减，主要分为以下几类：</p>
<ol>
<li>充值业务</li>
<li>消费业务（伴随着分成）</li>
<li>赠币业务（活动获取）</li>
<li>兑换业务（“银币”可以兑换成“金币”进行消费）</li>
<li>结算业务（“银币”可以进行提现）</li>
<li>管理员调整（运营行为，对用户货币进行调整）</li>
</ol>
<h4 id="三、冻结账户设计"><a href="#三、冻结账户设计" class="headerlink" title="三、冻结账户设计"></a>三、冻结账户设计</h4><p>针对消费场景，有两种形式的消费：</p>
<ol>
<li>即时消费(比如送礼)；<ul>
<li>用户消费的同时，收益方立即得到相应的分成</li>
</ul>
</li>
<li>延迟消费(比如申请上麦)<ul>
<li>先对用户的“金币“进行冻结，根据最终的结果，对用户冻结的金币进行结算或退回；用户的消费时间为实际结算的时间（不是冻结时的时间）。</li>
</ul>
</li>
</ol>
<p><img src="/2020/08/04/20200804-da-shang-lei-ye-wu-huo-bi-ti-xi-jian-shu/%E9%87%91%E9%92%B1%E5%86%BB%E7%BB%93%E8%B4%A6%E6%88%B7%E8%AE%BE%E8%AE%A1.png"></p>
<ul>
<li>冻结&amp;结算 和 消费&amp;退款 在技术实现设计上的差异：<ol>
<li>前者两次RPC，后者一次RPC</li>
<li>前者以结算时间作为消费完成时间；后者是以扣币时间作为消费完成时间，且退款会导致营收数据受影响</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/" itemprop="url">《程序员的职业素养》摘要</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-21T23:14:29+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/Shanghai_Beach_3.png"></p>
<p>6年前看的书，重新整理一下</p>
<p><img src="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB.jpeg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E5%89%8D%E8%A8%80.jpeg"></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h4 id="一-专业主义"><a href="#一-专业主义" class="headerlink" title="一 (专业主义)"></a>一 (专业主义)</h4><ol>
<li>专业主义的精髓就在于将公司的利益视同个人的利益。(这个呢，看情况吧)</li>
<li>不能忽略完整的测试环节，否则就交付软件是不负责任的。</li>
<li>为自己的不完美负责。代码难免出现bug，但这并不意味着你不用对它们负责。</li>
<li>让QA找不出任何问题。把自己没把握的代码发送给QA是不专业的，违背了“不行损害之事”的原则。</li>
<li>有些代码很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好事先写测试，再写要测的代码。(前半句挺对，后半句实际上比较难操作？)</li>
<li>职业发展是你自己的事。雇主没有义务确保你在职场能够立于不败之地。<ul>
<li>雇主出了钱，你必须付出时间和精力。一周工作60个小时，前40小时给雇主，后20小时是给自己的。你应该看书，练习，学习，做一些提升职业能力的事情。</li>
<li>每天大概是3个小时是给自己提升的，你可以在路上学习，在公交学习等，利用一些时间碎片。</li>
<li>一周有168小时，给你雇主40小时，为自己的职业发展留20小时，剩下的108小时再留56小时给睡眠，那么还剩52小时可做其他的事。</li>
<li>其实这样让你免于枯竭匮乏，假设你热爱软件开发，渴望成为专业开发者，在那20个小时里，就应该做能够激发，强化你的热情的事，那20小时是充满乐趣！</li>
</ul>
</li>
<li>IT行业发展迅猛，要时常了解自己的领域，坚持广泛学习才不至于落伍，但并不意味着忘掉过去。别忘了桑塔亚纳的诅咒：“不能铭记过去的人，注定重蹈先人的覆辙”。</li>
<li>每个软件开发人员必须精通的事项：<pre>
设计模式。GOF书中的全部24种模式。
设计原则。必须了解SOLID原则，而且深刻了解组件设计原则。
方法。必须理解XP，Scrum，精益，看板，瀑布，结构化分析及结构化设计等。
实践。必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。
工件。必须了解如何使用UML图，DFD图，结构图，Petri网络图，状态迁移图表，流程图和决策表。
</pre></li>
<li><hr>
<ul>
<li>练习。业精于勤，真正专业人士往往勤学苦干，以求得自身技能的纯属精炼。</li>
<li>合作。学习的第二个最佳方法就是与他人合作。从彼此身上学到很多东西，而且能在更短的时间内更高质量地完成更多工作。并不是要花全部时间一直和别人共事，独处的时间也更重要。</li>
<li>辅导。教学相长，想迅速牢固地掌握某些事实和观念，最好的方法就是与由你负责的人交流这些内容。传道授业中，导师也会从中受益。</li>
</ul>
</li>
<li>了解业务领域。了解自己所开发项目的业务领域，了解该领域的基本架构和基本知识，一边同客户和用户访谈。花时间与业内专家交流，了解他们的原则和价值观念。</li>
<li>雇主的问题就是你的问题。弄明白这些问题，并寻求最佳解决方案。开发系统时，站在雇主的角度思考，确保开发的功能真正满足雇主的需要。</li>
</ol>
<h4 id="二-说“不”"><a href="#二-说“不”" class="headerlink" title="二 (说“不”)"></a>二 (说“不”)</h4><ol>
<li>许诺“尝试”，就意味着你承认自己之前未尽全力，承认自己还有余力可施。<br>只要你许诺会去“尝试”，你其实是在承诺你会确保成功。<br>从本质上讲，承诺“尝试”就是一种不诚实的表现。你这么做的原因，可能是为了护住面子和避免冲突。</li>
<li>坚守专业主义精神，不能为了赶工而写出糟糕的代码，如果不能做到，当初就应该说“不”。<br>(这个吧，尽量吧，前提老板是个讲道理的人。。。。)</li>
</ol>
<h4 id="三-说“是”"><a href="#三-说“是”" class="headerlink" title="三 (说“是”)"></a>三 (说“是”)</h4><ol>
<li><p>口头上说。心里认真。付诸行动。<br>做出承诺，包含三个步骤。<br>1口头上说自己将会去做。<br>2心里认真对待做出的承诺。<br>3真正付诸行动。</p>
</li>
<li><p>没有做到自己对他人之前的承诺，会让自己难堪。言必信，行必果。<br>你只能承诺自己能完全控制的事。<br>如果你不尽早告诉别人可能的问题，就错失了让他们帮助你达成目标，兑现承诺的机会。<br>(前提是老板要讲道理啊。。。)</p>
</li>
<li><p>若为了赶工完成任务，周六日加班，那么要求周三才上班也是应该的。 (现实情况。。。)</p>
</li>
</ol>
<h4 id="四-编码"><a href="#四-编码" class="headerlink" title="四 (编码)"></a>四 (编码)</h4><ol>
<li>编码是一项颇具挑战也十分累人的智力活动。相比其他，编码要求更加聚精会神。<br>自己的代码要让其他人看得懂。(将心比心啊！)</li>
<li>如果感到疲劳或者心烦意乱，千万不要编码。<br>奉献精神和职业素养，更多意义上指要遵循纪律原则而非成为长时间工作的工作狂。<br>要确保自己已经将睡眠，健康和生活方式调整到最佳状况，这样才能做到每天的8个小时工作时间内全力以赴。 (虽然生活欺骗了你，但自己也别自暴自弃。。。。)</li>
<li>中断无法避免，总有人会打断你，消耗你的时间。发生这种情况时要记住一点，也许下次也会轮到你去打断别人请求帮助。因此，礼貌地表现出乐于助人的态度才是专业的态度。(还是将心比心！)</li>
<li>当大脑已经无法正常思考却硬逼自己在深夜还加班解决问题，你只会把自己折腾得更累，回家洗澡之类的反而会豁然开朗。<br>当碰到困难而受阻时，当你感到疲倦时，就离开一会儿，让富有创造力的潜意识接管问题。<br>精力分配得当，你将能在更短的时间内以更少的精力完成更多的事情。让自己保持好节奏，让团队保持好节奏。<br>了解你的创造力和智力运行的模式，充分发挥它们的优势而非与之背道而驰。<br>埋头忙于解决问题时，有时候可能会由于和问题贴得太近，无法看清楚所有的可选项。由于大脑中富有创造力的部分被紧张的专注力所抑制，你会错过漂亮的解决方案。<br>(适当放松一下，欲速则不达！！)</li>
<li>互相帮助是每个程序员的职责所在。作为专业人士，要以随时帮助别人为荣。<br>当然你需要独处时间，你可以直接并礼貌的告诉别人你在某个时间段不希望被人打扰。<br>(自重感啊)</li>
<li>接受他人的帮助。如果有人向你伸出援手，要诚挚接受，心怀感激地接受帮助并诚意合作。<br>不要因为自己进度压力很大，就推开伸来的援手。不妨给他半个小时的时间。如果到时那个人不能真正帮到你，再礼貌地致歉用感谢结束谈话也不迟。要记住，如同要以乐于助人为荣一样，也要以乐于接受别人的帮助为荣。<br>要学会如何求助。如果帮助唾手可得却让自己一个人堵在那儿，是很不专业的表现。<br>(透明透明！不盲目埋头苦干！)</li>
<li>辅导缺乏经验的程序员是那些经验丰富的程序员的职责。向资深导师寻求辅导也是年轻程序员的专业职责。(大家都那么菜，别不好意思！)</li>
</ol>
<h4 id="六-练习"><a href="#六-练习" class="headerlink" title="六 (练习)"></a>六 (练习)</h4><ol>
<li>保持不落伍的一种方法是为开源项目贡献代码。</li>
<li>职业程序员是用自己的时间来练习。老板的职责不包括避免你的技术落伍，也不包括为你打造一份好看的履历。<br>既然你是用自己的时间练习，就不必限制在老板规定的语言和平台。可以选择你喜欢的语言，练习你喜欢的技术。<br>(要多多学习啊！)</li>
</ol>
<h4 id="九-时间管理"><a href="#九-时间管理" class="headerlink" title="九 (时间管理)"></a>九 (时间管理)</h4><ol>
<li>受到邀请的会议没有必要全部参加。参加的会议太多，其实只能证明你不够专业。理智使用时间，谨慎选择，礼貌拒绝。<br>邀请你参加会议的人并不负责管理你的时间，为时间负责的只有你。<br>领导最重要的责任之一，就是帮你从某些会议脱身。好的领导一定会主动维护你拒绝出席的决定，因为他和你一样关心你的时间。<br>(时间宝贵，无效浪费还不如用来睡觉。。。)</li>
<li>如果会议让人厌烦，就离席。如果你发现参加某个会议是在浪费时间，就应当想个礼貌的方法退出来。<br>重要的是，你应当明白，继续呆在会议室里是浪费时间；继续参加对你没有太多意义的会议，是不专业的行为。</li>
<li>如果受到会议邀请，务必弄清楚指定的议题是什么，每个议题花多长时间没要取得什么成果。如果得不到确切的答案，你可以礼貌拒绝。</li>
<li>专业开发人员会安排好他们的睡眠，保证清晨有饱满的注意力去上班。</li>
<li>运动需要肌肉的注意力，而编程需要的是心智的注意力。肌肉注意力有助于改善心智注意力。</li>
<li>时间拆分与番茄工作法。</li>
<li>专业开发人员会评估每个任务的优先级，排除个人喜好和需要，按照真实的紧急程度来执行任务</li>
<li>选择了走不通的技术道路，你对这个决定越是坚持，浪费时间就越多。<br>专业开发人员不会执拗于某个不容放弃的主意，他们会保持开放的头脑来听取其他意见，让自己有多种选择，一旦看清楚，就会避开。</li>
</ol>
<h4 id="十-预估"><a href="#十-预估" class="headerlink" title="十(预估)"></a>十(预估)</h4><ol>
<li>专业开发人员能够清楚区分预估和承诺。只有在确切知道可以完成的前提下，他们才会给出承诺。而且会尽可能清楚说明预估的概率分布，这样主管就可以做出合适的计划。</li>
<li>大多数情况下，专业人士都不会给出确切的承诺，而是提供概率预估，来描述期望完成时间及可能的变数。</li>
</ol>
<h4 id="十一-压力"><a href="#十一-压力" class="headerlink" title="十一(压力)"></a>十一(压力)</h4><ol>
<li>即使有压力，专业人士也会冷静果断。尽管压力不断增大，他仍然会坚守所受的训练和纪律，他知道这些是他赖以战胜有最后期限和承诺所带来的压力感的最好方法。</li>
<li>快速前进确保最后期限的方法，便是保持整洁。专业人士不会为了快点前进而乱来。脏乱只会导致缓慢。</li>
<li>观察自己在危机时刻的反应，就可以了解自己的信念。如果在危机中依然遵循着你守持的纪律，就说明你确信这些纪律。<br>如果在平常时候你会注意保持代码整洁，但在危机时刻你却产出混乱的代码，就说明你并不真正相信混乱会导致速度下降。<br>如果你遵守的纪律原则是工作的最佳方式，那么即使是深度危机中，也要坚决秉持这些纪律原则。</li>
</ol>
<h4 id="十二-协作"><a href="#十二-协作" class="headerlink" title="十二(协作)"></a>十二(协作)</h4><ol>
<li><p>专业程序员最糟糕的表现就是两耳不闻窗外事，只顾一头将自己埋在技术堆里，甚至连公司业务火烧眉毛行将崩溃了也不闻不问。<br>你的工作职责就是要让业务免于陷入困顿，让公司可以长久发展下去。<br>专业程序员会花时间去理解业务。他们会和用户讨论他们正在使用的软件，会和销售人员与市场人员讨论所遭遇的问题，会和经理们沟通，明确团队的短期目标和长期目标。</p>
</li>
<li><p>不正常的团队最糟糕的症状是，每个程序员在自己代码周边筑起一道高墙，拒绝让其他程序员接触到这些代码。<br>这样会造成许多重复代码，模块间的接口完全是杂乱混淆而非正交的。<br>将代码所有权的各种隔断全部打破，由整个团队共同拥有全部代码的做法，相较于此要好得多。<br>专业开发人员不会阻止别人修改代码的。他们通过合作来达到学习的目的。</p>
</li>
</ol>
<h4 id="十四-辅导、学徒期与技艺"><a href="#十四-辅导、学徒期与技艺" class="headerlink" title="十四(辅导、学徒期与技艺)"></a>十四(辅导、学徒期与技艺)</h4><ol>
<li>计算机科班毕业生的质量一直令我颇感失望。究其原因，并不是这些毕业生不够聪明或缺乏天份，而是由于大学并没有教授真正的编程之道。</li>
<li>我们今天的做法和我所提倡的理想化的学徒制程序，这两者之间的主要差异在于技术方面的传授，培训，督导和检查。<br>观念上最大差别在于，专业主义价值观和技术敏锐度需要进行不断的传授，培育，滋养和文火慢炖，直至其深植入文化当中。<br>我们当前的做法之所以传承无力， 主要是因为其中缺少了资深人士辅导新人向其传授技艺的环节。</li>
</ol>
<p><img src="/2020/07/21/20200721-cheng-xu-yuan-de-zhi-ye-su-yang-zhai-yao/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E6%80%BB%E7%BB%93.jpeg"></p>
<hr>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><pre>
编辑推荐

编程大师Bob大叔40年编程生涯心得体会
讲解成为真正专业程序员所需态度原则
业界权威好评，广受赞誉
助您职业生涯迈上更高台阶

媒体推荐

Bob大叔的这本新作又一次抬高了专业程序员的门槛，指出了他们需要在历练尚浅的软件开发职业生涯中需要不断精进的内容。
——Markus Gartner,it-agile公司资深软件开发者

有一些技术书颇具启发与教益，有一些则读来轻松喜悦且富有趣味，但很少有技术书籍能够同时兼具所有这四个特色。我感觉Martin所有的书都可归入此列。
——George Bullock，微软公司资深程序经理

如果计算机科学学位要求有“毕业后必读书单”，本书当在其列。本书描述了迈向专业程序员的修炼旅程……而且阅读起来确实异常有趣。
——Jeff Overvey，伊利诺伊大学厄本那-香槟分校

如果你期望自己能成为软件专业人士，那么本书不容错过。
——R.L.Bogetti,Baxter Healthcare公司系统主设计师

作者简介

Robert C.Martin
世界级软件开发大师，设计模式和敏捷开发先驱，敏捷联盟首任主席，C++ Report前主编，背后辈程序员尊称为“Bob大叔”。20世纪70年代初成为职业程序员，后创办Object Mentor公司并任总裁。Martin还是一名多产的作家，至今已发表数百篇文章、论文和博客，除本书外，还著有《代码整洁之道》、《敏捷软件开发：原则、模式和实践》、《UML：Java程序员指南》等。他最近创办了cleancoders.com网站，专为软件开发人员提供教育视频。

目录

目　录

第1章　专业主义　1
1.1　清楚你要什么　2
1.2　担当责任　2
1.3　首先，不行损害之事　4
1.3.1　不要破坏软件功能　4
1.3.2　不要破坏结构　7
1.4　职业道德　8
1.4.1　了解你的领域　10
1.4.2　坚持学习　11
1.4.3　练习　11
1.4.4　合作　12
1.4.5　辅导　12
1.4.6　了解业务领域　13
1.4.7　与雇主/客户保持一致　13
1.4.8　谦逊　13
1.5　参考文献　14

第2章　说“不”　15
2.1　对抗角色　17
2.2　高风险时刻　20
2.3　要有团队精神　22
2.3.1　试试看　24
2.3.2　消极对抗　25
2.4　说“是”的成本　27
2.5　如何写出好代码　34

第3章　说“是”　37
3.1　承诺用语　39
3.1.1　识别“缺乏承诺”的征兆　40
3.1.2　真正的承诺听起来是怎样的　41
3.1.3　总结　43
3.2　学习如何说“是”　43
3.2.1　“试试”的另一面　43
3.2.2　坚守原则　44
3.3　结论　47

第4章　编码　48
4.1　做好准备　49
4.1.1　凌晨3点写出的代码　50
4.1.2　焦虑时写下的代码　51
4.2　流态区　53
4.2.1　音乐　54
4.2.2　中断　55
4.3　阻塞　55
4.4　调试　57
4.5　保持节奏　60
4.5.1　知道何时应该离开一会　60
4.5.2　开车回家路上　61
4.5.3　洗澡　61
4.6　进度延迟　61
4.6.1　期望　62
4.6.2　盲目冲刺　62
4.6.3　加班加点　63
4.6.4　交付失误　63
4.6.5　定义“完成”　64
4.7　帮助　64
4.7.1　帮助他人　64
4.7.2　接受他人的帮助　65
4.7.3　辅导　66
4.8　参考文献　66

第5章　测试驱动开发　67
5.1　此事已有定论　69
5.2　TDD的三项法则　69
5.3　TDD的优势　70
5.3.1　确定性　70
5.3.2　缺陷注入率　71
5.3.3　勇气　71
5.3.4　文档　72
5.3.5　设计　72
5.3.6　专业人士的选择　73
5.4　TDD的局限　73
5.5　参考文献　74

第6章　练习　75
6.1　引子　75
6.1.1　10的22次方　76
6.1.2　转变　77
6.2　编程柔道场　79
6.2.1　卡塔　80
6.2.2　瓦萨　81
6.2.3　自由练习　81
6.3　自身经验的拓展　82
6.3.1　开源　82
6.3.2　关于练习的职业道德　82
6.4　结论　83
6.5　参考文献　83

第7章　验收测试　84
7.1　需求的沟通　84
7.1.1　过早精细化　86
7.1.2　迟来的模糊性　87
7.2　验收测试　89
7.2.1　“完成”的定义　89
7.2.2　沟通　91
7.2.3　自动化　92
7.2.4　额外工作　93
7.2.5　验收测试什么时候写，由谁来写　93
7.2.6　开发人员的角色　94
7.2.7　测试的协商与被动推进　95
7.2.8　验收测试和单元测试　96
7.2.9　图形界面及其他复杂因素　97
7.2.10　持续集成　98
7.3　结论　98

第8章　测试策略　99
8.1　QA应该找不到任何错误　100
8.1.1　QA也是团队的一部分　100
8.1.2　需求规约定义者　100
8.1.3　特性描述者　100
8.2　自动化测试金字塔　101
8.2.1　单元测试　101
8.2.2　组件测试　102
8.2.3　集成测试　103
8.2.4　系统测试　104
8.2.5　人工探索式测试　104
8.3　结论　105
8.4　参考文献　105

第9章　时间管理　106
9.1　会议　107
9.1.1　拒绝　107
9.1.2　离席　108
9.1.3　确定议程与目标　109
9.1.4　立会　109
9.1.5　迭代计划会议　109
9.1.6　迭代回顾和DEMO展示　110
9.1.7　争论/反对　110
9.2　注意力点数　111
9.2.1　睡眠　112
9.2.2　咖啡因　112
9.2.3　恢复　112
9.2.4　肌肉注意力　112
9.2.5　输入与输出　113
9.3　时间拆分和番茄工作法　113
9.4　要避免的行为　114
9.5　死胡同　115
9.6　泥潭　115
9.7　结论　116

第10章　预估　117
10.1　什么是预估　119
10.1.1　承诺　119
10.1.2　预估　120
10.1.3　暗示性承诺　121
10.2　PERT　122
10.3　预估任务　125
10.4　大数定律　127
10.5　结论　127
10.6　参考文献　128

第11章　压力　129
11.1　避免压力　131
11.1.1　承诺　131
11.1.2　保持整洁　132
11.1.3　危机中的纪律　132
11.2　应对压力　133
11.2.1　不要惊慌失措　133
11.2.2　沟通　133
11.2.3　依靠你的纪律原则　133
11.2.4　寻求帮助　134
11.3　结论　134

第12章　协作　135
12.1　程序员与人　137
12.1.1　程序员与雇主　137
12.1.2　程序员与程序员　140
12.2　小脑　142
12.3　结论　143

第13章　团队与项目　144
13.1　只是简单混合吗　144
13.1.1　有凝聚力的团队　145
13.1.2　如何管理有凝聚力的团队　146
13.1.3　项目承包人的困境　147
13.2　结论　148
13.3　参考文献　148

第14章　辅导、学徒期与技艺　149
14.1　失败的学位教育　149
14.2　辅导　150
14.2.1　DIGI-COMP I, 我的第一台计算机　150
14.2.2　高中时代的ECP-18　152
14.2.3　非常规辅导　154
14.2.4　艰难的锤炼　155
14.3　学徒期　156
14.3.1　软件学徒期　158
14.3.2　现实情况　159
14.4　技艺　160
14.5　结论　161

附录　工具　162
</pre>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">142</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">154</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'LR34RG5CRdFgzK8ijwc5Hq0B-gzGzoHsz',
        appKey: 'qqtIlANIluHpfpOnxTUnYrku',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>





  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
