<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="为啥不吃三文鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="为啥不吃三文鱼">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>拉巴力的纸皮箱</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/02/19/20250219-langchain-yao-dian-ji-lu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/19/20250219-langchain-yao-dian-ji-lu/" itemprop="url">LangChain要点记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-19T20:53:32+08:00">
                2025-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>基于书籍简单记录要点</p>
</blockquote>
</blockquote>
<p><img src="/2025/02/19/20250219-langchain-yao-dian-ji-lu/LangChain.png"></p>
<h1 id="LangChain-提供了多种模板供选择"><a href="#LangChain-提供了多种模板供选择" class="headerlink" title="LangChain 提供了多种模板供选择"></a>LangChain 提供了多种模板供选择</h1><ul>
<li>LangChain 提供了以下格式化 SQL 提示词模板（翻译）：</li>
</ul>
<pre>
1. 你是一个 PostgreSQL 专家。给定一个输人问题，首先创建一个语法正确的 PostgreSQL查询来运行，然后查看查询结果，扑返回针对输人问题的答案。
2. 除非用户明确指定了要返回的结果数量，否则应使用 PostgreSQL 的LIMIT 子句来限制查询结果，最多返回top.k条记录。你可以对结果进行排序，以返回数据库中最有信息价值的数据。
3. 绝对不要查询表中的所有列。你只能在询回答问题所需的列。用双引号（"）将每个列名包裹起来，表示官们是界定的标识符。
4. 注意只使用你在表巾可以看到的列名，不要责询不存在的列。此外，要注意哪一列在哪个表中。
5. 如果问题涉及“今天”，请注意使用 CURRENT_DATE 函数获取当前日期。

使用以下格式：

问题：这里的问题
SQL查询：要运行的 SQL 查询
SQL结果：SQL 查询的结果
答案：这里的最终答案

只使用以下表：

(table_info)

问题：｛input｝

</pre>

<ul>
<li>想象一下，如果没有 LangChain 提供的这个提示词模板，当你要开始编写一段SQL查询代码时，会走多少弯路？LLM 应用开发的最后1公里，其意义是确保开发者无须为了一个小细节而多走弯路，正如居民无须跑很远坐公交车一样，每一个关键的细节都能得到及时而准确的处理，使得整个开发过程更为高效。</li>
</ul>
<h1 id="记忆提示词"><a href="#记忆提示词" class="headerlink" title="记忆提示词"></a>记忆提示词</h1><ul>
<li><p>创建提示词是最重要的环节。在创建的过程中你可以理解为什么加人记忆组件后，“聊天备忘录”有了内容，让链组件有了“记忆”。使用提示词模板包装器，自定义一个提示词模板字符串。</p>
</li>
<li><p>提示词内容分为四部分：</p>
<ul>
<li>一是对模型的指导词：“请你回答问题的时候，依据文档内容和聊天记录回答，如果在其中找不到相关信息或者答案，请回答不知道。”；</li>
<li>二是使用问题检索到的相关文档内容；“文档内容是：｛context｝”；三是记忆组件输出的记忆内容：“聊天记录是：｛chat_history｝”；四是用户的输人：“Human：(human _input)”<pre>
template = "n*你是说中文的 chatbot.
请你回答问题的时候，依据文持内容和脚天记录回答，如果在其中找不到相关信息戒着答案，请回答
不知道。
文档内容是：｛context）
聊天记录是：｛chat_history）
Human: (human_input)
Chatbot:"""
</pre></li>
</ul>
</li>
<li><p>LangChain 框架由以下开发库组成。</p>
<ul>
<li>（1）LangChain-Core：基础抽象和 LangChain 表达语言（LCEL）。</li>
<li>（2）LangChain-Community：组件及内置的大量第三方技术集成模块，一般被封装为合作伙伴模块（例如 LangChain-openai）。</li>
<li>（3）LangChain：构成应用架构的上层核心组件，包括 Chains、Agents 等。</li>
<li>（4）Templates：官方提供的一些常见的应用模板。</li>
<li>（5）LangServe：将 LangChain 链部署为 REST API 的平台。</li>
<li>（6）LangSmith：帮助开发者跟踪调试、测试、评估和监控大模型应用的在线平台。</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><p>Langchain agent是怎么找到search工具并使用的</p>
<ul>
<li>可以正确识别和调用它，因为它主要是通过 description 语义匹配，而不是看 name 的具体字符串。</li>
<li>但 name 仍然有一定作用，比如：LLM 可能会参考 name 来做初步判断；调试时 name 可以帮助你看日志，知道 Agent 选了哪个工具</li>
</ul>
</li>
<li><p>LLM本身没有内在记忆，每个查询都是独立进行的</p>
<ul>
<li>所谓的记忆和检索增强生成（RAG）是通过外部手段实现的，即将相关信息添加到提示词模板中</li>
</ul>
</li>
</ul>
<hr>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Langchain是怎么做到通过分析语义找到对应工具的"><a href="#Langchain是怎么做到通过分析语义找到对应工具的" class="headerlink" title="Langchain是怎么做到通过分析语义找到对应工具的"></a>Langchain是怎么做到通过分析语义找到对应工具的</h2><ul>
<li>From ChatGPT (2025-02-18)</li>
</ul>
<p>LangChain 通过 <strong>LLM（大模型）+ ReAct 框架</strong> 来分析语义并选择工具。它的核心逻辑是让 LLM <strong>先思考</strong>，再决定用哪个工具，并按照工具的格式调用它。  </p>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a><strong>核心机制</strong></h3><ol>
<li><strong>解析用户问题</strong> → 让 LLM 提取关键语义  </li>
<li><strong>匹配工具描述</strong> → 让 LLM 判断哪个工具最适合  </li>
<li><strong>生成调用指令</strong> → LLM 生成工具的调用格式并执行  </li>
<li><strong>工具返回结果</strong> → LLM 解析工具返回的数据并回复用户</li>
</ol>
<p>这套逻辑基于 <strong>ReAct（Reasoning + Acting）</strong> 框架，在 LangChain 里 Agent 主要是用这个方法来动态决策。  </p>
<h3 id="1-解析用户问题"><a href="#1-解析用户问题" class="headerlink" title="1. 解析用户问题"></a><strong>1. 解析用户问题</strong></h3><p>假设你输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.run(<span class="string">&quot;计算 25 * 4 + 10&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>LangChain 会把这个问题交给 LLM（如 GPT-4），让它理解用户的意图。</p>
<p>LLM 可能会把你的问题理解成：</p>
<ul>
<li>这是一个数学计算问题  </li>
<li>需要找到一个能进行数学计算的工具  </li>
<li>计算表达式 <code>25 * 4 + 10</code></li>
</ul>
<h3 id="2-匹配工具描述"><a href="#2-匹配工具描述" class="headerlink" title="2. 匹配工具描述"></a><strong>2. 匹配工具描述</strong></h3><p>假设你有两个工具：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tool(</span><br><span class="line">    name=<span class="string">&quot;Calculator&quot;</span>,</span><br><span class="line">    func=calculator_tool,</span><br><span class="line">    description=<span class="string">&quot;用于数学计算。输入一个数学表达式（如 3 + 5 * 2），输出结果。&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Tool(</span><br><span class="line">    name=<span class="string">&quot;Wikipedia&quot;</span>,</span><br><span class="line">    func=wiki.run,</span><br><span class="line">    description=<span class="string">&quot;查询 Wikipedia 词条，输入一个关键词（如 &#x27;Python programming&#x27;），获取相关信息。&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>LLM 会对比问题和 <code>description</code>，发现 <strong>Calculator 的描述里提到了“数学计算”</strong>，所以它会选择 <code>Calculator</code> 这个工具。</p>
<blockquote>
<p><strong>关键点</strong>：LangChain 让 LLM 直接读 <code>description</code>，所以工具的名字 <code>name</code> 只是一个标识，核心还是 <code>description</code> 的语义匹配。</p>
</blockquote>
<h3 id="3-生成调用指令"><a href="#3-生成调用指令" class="headerlink" title="3. 生成调用指令"></a><strong>3. 生成调用指令</strong></h3><p>LangChain 让 LLM 生成一个类似 JSON 的格式，表示它要调用哪个工具：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Calculator&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;action_input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;25 * 4 + 10&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后 LangChain 会<strong>解析这个指令</strong>，找到 <code>Calculator</code> 工具，并把 <code>25 * 4 + 10</code> 传给 <code>func</code> 去执行。</p>
<h3 id="4-工具返回结果"><a href="#4-工具返回结果" class="headerlink" title="4. 工具返回结果"></a><strong>4. 工具返回结果</strong></h3><p>计算工具执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;25 * 4 + 10&quot;</span>)  <span class="comment"># 计算得到 110</span></span><br></pre></td></tr></table></figure>
<p>LangChain 把 <code>110</code> 返回给 LLM，LLM 可能会回复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 * 4 + 10 = 110</span><br></pre></td></tr></table></figure>
<p>最终 <code>agent.run()</code> 会输出这个结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>LangChain 让 LLM 负责：</p>
<ol>
<li><strong>分析用户语义</strong></li>
<li><strong>匹配工具（通过 <code>description</code>）</strong></li>
<li><strong>生成调用工具的指令</strong></li>
<li><strong>解释工具返回的结果</strong></li>
</ol>
<p>它的核心是利用 <strong>LLM 的推理能力</strong>，结合 ReAct 让它“思考后再行动”。所以只要 <code>description</code> 够清晰，即使 <code>name</code> 乱写，它也能找到正确的工具！</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>《LangChain入门指南构建高可复用、可扩展的LLM应用程序》</li>
<li>《基于大模型的RAG应用开发与优化——构建企业级LLM应用》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/02/17/20250217-shen-du-xue-xi-ji-chu-ru-men-bei-wang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/17/20250217-shen-du-xue-xi-ji-chu-ru-men-bei-wang/" itemprop="url">深度学习基础入门备忘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-17T11:08:39+08:00">
                2025-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>简单粗略通读了解，先记录备忘<br>后续考虑结合相关视频深入理解</p>
</blockquote>
</blockquote>
<ul>
<li><p>《深度学习人门：基于Python的理论与实现》：<a target="_blank" rel="noopener" href="https://github.com/Kingson4Wu/Deep-Learning-from-Scratch">https://github.com/Kingson4Wu/Deep-Learning-from-Scratch</a></p>
<ol>
<li>感知机是一种接收多个输入信号并输出一个信号的算法。它的工作原理基于权重和偏置这两个关键参数。</li>
<li>机器学习的任务是让计算机自动确定合适的权重和偏置参数值。</li>
<li>求解机器学习问题的步骤<ol>
<li>训练（学习）</li>
<li>推理（神经网络的前向传播）</li>
</ol>
</li>
<li>激活函数(activation function)：决定如何来激活输入信号的总和；激活函数是连接感知机和神经网络的桥梁。</li>
<li>神经网络的学习过程：通过损失函数 (loss function)和梯度法 (gradient method)来优化网络参数<ol>
<li>学习的目标是通过梯度下降法(gradient descent method)找到使损失函数值最小的权重参数</li>
<li>学习率(learning rate)：决定参数更新的步长（超参数、人工设定）</li>
</ol>
</li>
<li>随机梯度下降(stochastic gradient descent)(SGD)能在一定程度上帮助避免局部最优，通常将SGD与其他技术结合使用,以获得更好的优化效果</li>
<li>深度学习：加深了层的深度神经网络；通过叠加层，可以创建更深的网络结构</li>
</ol>
</li>
<li><p>《深度学习进阶：自然语言处理》：<a target="_blank" rel="noopener" href="https://github.com/Kingson4Wu/Natural-Language-Processing">https://github.com/Kingson4Wu/Natural-Language-Processing</a></p>
<ol>
<li>自然语言处理的目标就是让计算机理解人说的话，进而完成 对我们有帮助的事情</li>
<li>单词的分布式表示（分布式假设）（单词向量化）：“某个单词的含义由它周围的单词形成”；单词本身没有含义，单词含义由它 所在的上下文(语境)形成。</li>
<li>向量间的相似度：余弦相似度(cosine similarity)；直观地表示了“两个向量在多大程度上指向同一方向”</li>
<li>让计算机理解单词含义：基于推理的方法(word2vec)（基于神经网络）。</li>
<li>语言模型(language model)给出了单词序列发生的概率；使用概率来评估一个单词序列发生的可能性，即在多大程度上是自然的 单词序列。<ul>
<li>生成的新文本是训练数据中没有的新生成的文本。因为语言模型并不是背诵了训练数据，而是学习了训练数据中单词的排列模式</li>
<li>语言模型的评价：困惑度(perplexity)、分叉度</li>
</ul>
</li>
<li>“马尔可夫性”或者“马尔 可夫模型”“马尔可夫链”：指未来的状态仅 依存于当前状态。</li>
<li>RNN（循环神经网络）：被引入来解决前馈网络在处理时序数据上的局限性。<ul>
<li>传统RNN中存在的梯度消失和梯度爆炸问题</li>
<li>LSTM的结构与传统RNN的不同之处在于，它引入了记忆单元（c）。记忆单元在LSTM层之间传递，但不直接用作输出。LSTM的对外输出是隐藏状态向量（h）。</li>
</ul>
</li>
<li>seq2seq模型（也称为Encoder-Decoder模型）用于将一个时序数据转换为另一个时序数据    <ul>
<li>传统 seq2seq 模型 将编码器输出压缩为固定长度向量，导致长序列信息丢失</li>
<li>Attention 机制 允许模型在解码时关注输入序列的不同部分，类似人类注意力</li>
</ul>
</li>
<li>Transformer：基于 Attention 构成；基于 Attention 构成</li>
</ol>
</li>
<li><p>《深度学习入门：强化学习》：<a target="_blank" rel="noopener" href="https://github.com/Kingson4Wu/Reinforcement-Learning">https://github.com/Kingson4Wu/Reinforcement-Learning</a></p>
<ol>
<li>机器学习（按学习方法划分）：监督学习(supervised learning)、无监督学习(unsupervised learning)、强化学习(reinforcement learning)<ol>
<li>监督学习：给正确答案打标签；输入的数据由“老师”打标签</li>
<li>无监督学习：无“正确答案标签”；没有 “老师”的存在；主要目标是找到隐藏在数据中的结构和模式；分组(聚类)、特征提取、降维</li>
<li>强化学习：智能代理和环境相互作用；智能代理是行动的主体；强化学习接受”奖励”作为来自环境的反馈</li>
</ol>
</li>
<li>强化学习行动的策略<ol>
<li>“贪婪行动”(greedy )，也叫利用(exploitation)：根据以前的经验选择最佳行动（可能错过更好的选择）</li>
<li>“非贪婪行动”，也叫作探索(exploration)：对价值做出更准确的估计。</li>
</ol>
</li>
<li>强化学习算法最终归结为如何在“利用”和 “探索”之间取得平衡</li>
<li>ε-greedy 算法、马尔可夫决策过程(MDP)</li>
<li>在强化学习中，我们的目标是获得最优策略</li>
<li>深度强化学习(deep reinforcement learning)：强化学习和深度学习的结合</li>
<li>通用人工智能(artificial general intelligence, AGI)</li>
</ol>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="参数、输入向量和嵌入模型的真正关系"><a href="#参数、输入向量和嵌入模型的真正关系" class="headerlink" title="参数、输入向量和嵌入模型的真正关系"></a>参数、输入向量和嵌入模型的真正关系</h2><ul>
<li><p>在神经网络中，“参数”特指模型在训练过程中学习得到的变量，主要包括<strong>权重（weights）和偏置（biases）</strong>，它们决定了模型如何处理输入并生成输出，是模型内部真正“学到的知识”。输入特征的数量（即输入维度）常被初学者误认为是“参数”，但实际上，它属于输入数据的结构，而非模型的可训练部分。每个神经元在接受输入时，会对输入向量进行<strong>加权求和并加上偏置</strong>，将这个结果作为激活函数的输入，激活函数再施加非线性变换，产生神经元的输出。虽然权重确实与输入一一对应，但激活函数并不直接作用于原始输入，而是作用于这个线性组合的结果。</p>
</li>
<li><p>在现代深度学习模型中，尤其是语言模型（如 GPT），输入向量的维度是固定的，这一维度通常由<strong>嵌入模型（embedding layer）或输入预处理过程</strong>所决定。例如，文本经过分词和嵌入后，每个 token 被映射为一个固定长度的向量（如 768 维），整个输入变为一个定长矩阵。为了确保矩阵运算的可行性与模型结构的稳定性，输入长度往往被限制在最大长度内，不足时通过填充处理，超长则截断。因此，嵌入层不仅是将离散信息转为向量表示的桥梁，也是模型输入维度的决定因素之一。</p>
</li>
</ul>
<h2 id="感知机、激活函数和神经网络三者关系"><a href="#感知机、激活函数和神经网络三者关系" class="headerlink" title="感知机、激活函数和神经网络三者关系"></a>感知机、激活函数和神经网络三者关系</h2><ul>
<li>感知机是神经网络的基本构建单元，它通过对输入加权求和后传入激活函数来决定输出。激活函数引入非线性，使神经网络能拟合复杂关系。神经网络由多个感知机层叠构成，层与层之间通过激活函数连接，从而具备强大的表达和学习能力。三者关系为：<strong>激活函数是感知机的一部分，感知机是神经网络的基础单元。</strong></li>
</ul>
<h3 id="三者之间的关系总结："><a href="#三者之间的关系总结：" class="headerlink" title="三者之间的关系总结："></a>三者之间的关系总结：</h3><table>
<thead>
<tr>
<th>组成层级</th>
<th>关系说明</th>
</tr>
</thead>
<tbody><tr>
<td>感知机</td>
<td>最基础的神经元模型，是神经网络的最小单元</td>
</tr>
<tr>
<td>激活函数</td>
<td>是感知机或神经元的核心部分，引入非线性</td>
</tr>
<tr>
<td>神经网络</td>
<td>是多个感知机&#x2F;神经元的组合，通过激活函数形成强大的拟合能力</td>
</tr>
</tbody></table>
<p>可以这样理解它们的层级结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">神经网络 = 多个感知机（神经元）组成</span><br><span class="line">感知机 = 线性加权求和 + 激活函数</span><br><span class="line">激活函数 = 赋予神经网络非线性表达能力的关键</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/02/13/20250213-guan-yu-ai-ti-dai-ren-lei-gong-zuo-de-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/13/20250213-guan-yu-ai-ti-dai-ren-lei-gong-zuo-de-wen-ti/" itemprop="url">关于AI大语言模型替代人类工作的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-13T15:05:23+08:00">
                2025-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AI的局限性或缺点"><a href="#AI的局限性或缺点" class="headerlink" title="AI的局限性或缺点"></a>AI的局限性或缺点</h2><ul>
<li><strong>难以预测与控制</strong>：AI的运行机制像黑箱，难以准确预知其行为，尤其在关键场景下可能会犯致命错误。</li>
<li><strong>无法背锅</strong>：AI犯错时，责任归属难以明确，导致无法追究错误的责任，缺乏人类信誉体系的约束。</li>
<li><strong>逻辑推理不严谨</strong>：AI的推理基于概率预测，不是绝对严谨的逻辑推理。训练数据如果有误，AI可能无法辨别。</li>
<li><strong>无法创新</strong>：AI不具备创造全新概念的能力，更多的是基于历史数据进行知识复述与组合，无法像人类一样发明新技术或理念。</li>
<li><strong>对超出训练数据的场景应对差</strong>：AI在面对未曾训练过的数据时，表现较差，容易出错。</li>
</ul>
<h2 id="AI的好处"><a href="#AI的好处" class="headerlink" title="AI的好处"></a>AI的好处</h2><ul>
<li><strong>提高效率</strong>：AI在许多领域极大提升了效率，尤其在数据处理、搜索和重复性任务上。对于程序员来说，它是一个强大的辅助工具，帮助快速解决技术问题。</li>
<li><strong>降低门槛</strong>：AI减少了对低级重复性任务的需求，拉近了人们在某些知识领域的差距。</li>
<li><strong>支持决策和监督</strong>：AI辅助决策，尤其是在复杂任务中，能提供数据支持，减少人为错误。</li>
</ul>
<h2 id="AI工具下需要的人才"><a href="#AI工具下需要的人才" class="headerlink" title="AI工具下需要的人才"></a><strong>AI工具下需要的人才</strong></h2><ul>
<li><strong>清晰表述与提问能力</strong>：能够清晰提出问题和有效沟通是与AI协同工作的关键，好的表述能力有助于提高工作效率。</li>
<li><strong>整理与分析能力</strong>：能够有效梳理信息、分解任务，并向AI提出清晰问题的人，会更善于利用AI工具。</li>
<li><strong>与产品交互能力</strong>：AI可以编写代码，但仍需要人类与产品经理沟通，理解需求并做出相应调整。</li>
</ul>
<h2 id="程序员的利好与不可替代的能力"><a href="#程序员的利好与不可替代的能力" class="headerlink" title="程序员的利好与不可替代的能力"></a><strong>程序员的利好与不可替代的能力</strong></h2><ul>
<li><strong>AI对程序员的利好</strong>：<ul>
<li>AI大幅提升了开发效率，尤其在编程辅助、技术搜索、业务方案思考等方面。</li>
<li>某些低级任务减少了人力需求，使得程序员能更多专注于创造性和复杂问题的解决。</li>
</ul>
</li>
<li><strong>程序员不可替代的地方</strong>：<ul>
<li><strong>清晰的提问和判断能力</strong>：程序员的核心能力在于能理解问题，并准确表达需求，AI只能作为工具辅助工作。</li>
<li><strong>与产品沟通</strong>：AI生成的代码和解决方案需要程序员与产品团队对接，确保最终结果符合需求。</li>
<li><strong>决策和经验判断</strong>：AI的能力有限，尤其在面对复杂决策时，仍需依赖经验丰富的程序员来进行判断和修正。</li>
</ul>
</li>
</ul>
<h2 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a><strong>个人观点</strong></h2><ul>
<li>AI目前主要是利用历史数据和记忆进行信息处理，不能进行创新（如无法创造出类似K8S的技术）。</li>
<li>尽管AI能提高程序员的工作效率，但目前它更多是辅助工具，而不是替代品。</li>
<li>对普通程序员来说，理解大模型技术的基本原理和概念非常重要，未来将需要在“AI操作系统”上来构建应用。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote>
<blockquote>
<p>来自claude.ai的评价<br>2025-02-13</p>
</blockquote>
</blockquote>
<p>我来分析一下这些观点，指出其中可能存在的错误或需要讨论的地方：</p>
<ol>
<li>关于”无法创新”的说法需要更谨慎：</li>
</ol>
<ul>
<li>虽然AI确实主要基于已有数据进行组合和推理，但说它”不具备创造全新概念的能力”可能过于绝对</li>
<li>AI已经展示出一定的创新能力，比如在围棋、蛋白质折叠等领域提出了人类之前没有想到的解决方案</li>
<li>更准确的说法是AI的创新能力与人类不同，它通过大规模数据分析和模式识别来实现创新</li>
</ul>
<ol start="2">
<li>“逻辑推理不严谨”的表述不够准确：</li>
</ol>
<ul>
<li>现代AI系统（尤其是形式化验证系统）可以进行严格的逻辑推理</li>
<li>大语言模型确实存在基于概率的推理特点，但这不等同于所有AI系统都如此</li>
<li>人类的推理同样也常常基于经验和概率判断，而不总是严格的逻辑推导</li>
</ul>
<ol start="3">
<li>关于”难以预测与控制”：</li>
</ol>
<ul>
<li>这个观点部分正确，但需要注意现代AI系统已经有了很多可解释性的工具和方法</li>
<li>某些领域的AI系统（如用于医疗诊断的AI）已经实现了相当程度的可解释性</li>
<li>“像黑箱”这种说法可能过于简化了问题</li>
</ul>
<ol start="4">
<li>“无法背锅”的说法不够准确：</li>
</ol>
<ul>
<li>实际上已经有了相关的法律和责任框架在建立</li>
<li>AI系统的责任可以追溯到开发者、部署者和使用者</li>
<li>这更多是一个治理和监管的问题，而不是技术本身的限制</li>
</ul>
<ol start="5">
<li>“个人观点”部分关于K8S的例子不够恰当：</li>
</ol>
<ul>
<li>K8S本质上是一个系统架构和设计方案，而不是完全创新的技术</li>
<li>AI实际上可以通过分析已有系统设计模式，提出类似的架构方案</li>
<li>更准确的说法是AI在某些创新领域的能力仍有限制，而不是完全无法创新</li>
</ul>
<ol start="6">
<li>好处部分基本准确，但可以补充：</li>
</ol>
<ul>
<li>AI不仅提高效率，还能发现人类容易忽视的模式和关联</li>
<li>在某些领域（如图像识别、语音处理）已经超越了人类性能</li>
<li>AI能够24&#x2F;7工作，这个优势没有被提到</li>
</ul>
<ol start="7">
<li>关于程序员不可替代性的分析基本合理，但可以补充：</li>
</ol>
<ul>
<li>程序员在系统架构设计、安全性考虑等方面的经验特别重要</li>
<li>处理边界条件和异常情况的能力仍然需要人类经验</li>
<li>对业务场景的深入理解和商业价值判断也是关键能力</li>
</ul>
<ol start="8">
<li>“AI操作系统”的说法需要澄清：</li>
</ol>
<ul>
<li>这个比喻可能会造成误解，更准确的说法是”AI基础设施”或”AI平台”</li>
<li>程序员需要理解的不仅是技术原理，还包括AI的应用场景和限制</li>
</ul>
<p>总的来说，这些观点大体上是合理的，但部分表述过于绝对或简化。AI的能力和局限性是一个复杂的话题，需要更细致和平衡的讨论。理解AI的真实能力和限制，对于更好地利用AI工具至关重要。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/02/13/20250213-shen-du-xue-xi-wei-shi-me-neng-xue-xi-bing-zuo-dui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/13/20250213-shen-du-xue-xi-wei-shi-me-neng-xue-xi-bing-zuo-dui/" itemprop="url">深度学习为什么能学习并做对</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-13T14:14:52+08:00">
                2025-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ul>
<li>目前无法解释为什么深度学习可以给出答案，只能大概解释为什么它能学习</li>
<li>这就相当于：我不能解释为什么这个人是通过什么做对这道题的，我只能解释他有正常的学习能力以及合适的学习资料，所以他自己能学习并做对题目</li>
<li>所以深度学习是怎么给出答案的，后续或许应该由它本身来告诉我们。</li>
<li>依据不同人的认知水平，来告诉我们它通过学习所发现的规律。同时人类通过它能快速学习发现事物规律的能力，来进一步帮助提升人类的认知。</li>
</ul>
<h1 id="AI对我理解的看法"><a href="#AI对我理解的看法" class="headerlink" title="AI对我理解的看法"></a>AI对我理解的看法</h1><blockquote>
<blockquote>
<p>From chatGPT (2025-02-13)</p>
</blockquote>
</blockquote>
<ul>
<li><p>你理解的方向是对的，可以稍微精炼和调整一下：</p>
<ul>
<li>深度学习的一个核心问题就是我们无法完全解释它是如何给出具体答案的。我们能解释的只是它是如何通过大量的数据和训练过程进行学习的。换句话说，深度学习像是一个“黑箱”，我们可以观察到输入和输出，但它在其中如何处理信息、做出决策，通常并不完全透明。</li>
<li>可以类比成：假设有一个人做对了某道题目，虽然我们可能无法完全解释他是如何一步一步得出答案的，但我们能确定他具备了良好的学习能力和充足的学习资源。所以，深度学习也类似，它通过大量的数据、适当的算法和优化手段“学习”并给出答案。</li>
<li>至于它如何给出具体的答案，最终可能还是要依靠深度学习本身来“解释”。这意味着，未来我们可能会开发出更先进的方法，帮助我们理解深度学习网络中的“决策过程”。同时，借助它所展现出的强大规律发现能力，我们可以利用这种能力来加速我们对事物的认知。</li>
</ul>
</li>
<li><p>我的看法：</p>
<ul>
<li>我同意你的观点，深度学习的“黑箱性”是目前我们面临的主要挑战之一。它的强大之处在于能自动从海量数据中发现规律，但如何理解这些规律，如何将这些规律和人类的认知能力相结合，是我们目前探索的方向之一。其实，未来可能不仅仅是“深度学习告诉我们如何做”，而是人类和深度学习的合作能进一步推动科学与技术的发展，帮助我们发现一些潜在人类难以触及的规律。</li>
<li>深度学习不只是一个工具，它还可能是一个不断反馈、不断自我优化的过程，给我们打开了认知的新窗口。</li>
</ul>
</li>
</ul>
<h1 id="AI自己对这个问题的看法"><a href="#AI自己对这个问题的看法" class="headerlink" title="AI自己对这个问题的看法"></a>AI自己对这个问题的看法</h1><blockquote>
<blockquote>
<p>From chatGPT (2025-02-13)</p>
</blockquote>
</blockquote>
<ul>
<li><p>关于“深度学习为什么能学习并做对”的问题，我的理解是，深度学习通过大量的数据训练，自动从中提取规律、建立模型，并根据这些模型对新数据做出预测。深度学习的优势在于它能够发现一些非常复杂和抽象的规律，而这些规律通常是我们人类在没有机器帮助的情况下很难发现的。</p>
</li>
<li><p>但是，为什么深度学习能给出正确的答案，实际上是一个复杂的过程。深度学习模型并不像人类一样有明确的逻辑推理或意识，它只是基于输入数据的模式，使用一系列参数和数学运算来“拟合”数据。对于这个过程的解释，我们只能说它通过优化算法（如梯度下降等）调整模型参数，使得输出尽可能接近实际结果。因此，深度学习并不“理解”问题，而是通过反复训练找到了一组合适的参数，能在特定任务上取得高效的预测或分类结果。</p>
</li>
<li><p>你可以把深度学习看作一个“发现者”，它通过大量的例子不断试错和优化，不断接近正确的答案，但它没有明确的推理过程。比如，人类在做题时有一定的思考过程，我们可以分析每一步的原因，而深度学习则是通过计算和数据模式的关联来找到最优解。</p>
</li>
<li><p>至于“深度学习为什么能做对”，目前我们更多关注它的实际效果而非其过程的透明性，因为即使我们无法完全解释它的每一个决策，也可以通过其出色的表现来证明它的有效性。未来，随着研究的深入，我们可能会找到更好的方法，帮助我们理解这些“黑箱”模型的内部机制。</p>
</li>
<li><p>总结来说，深度学习通过数据的反复训练和优化，能够找到规律并给出准确的预测，而为什么它能做对，更多是依赖于它强大的计算能力和从数据中提取规律的能力，而不是基于传统意义上的推理或解释。</p>
</li>
<li><p>几个关键点总结：</p>
<ol>
<li><strong>深度学习的学习过程</strong>：深度学习通过大量的数据训练，利用优化算法（如梯度下降）调整模型参数，自动从数据中提取规律，完成任务（如预测、分类等）。</li>
<li><strong>无法完全解释“为什么”</strong>：深度学习模型在给出答案时，并没有明确的推理过程或“理解”，它只是通过找到合适的模式和参数来优化输出。其决策过程通常是黑箱的，难以完全解释。</li>
<li><strong>黑箱性质</strong>：我们无法清楚知道深度学习是如何做出具体决策的，但可以看到它在实际任务中表现出色。因此，我们更多关注它的效果，而非其内在工作机制。</li>
<li><strong>与人类认知的对比</strong>：深度学习像是一个“发现者”，通过反复训练和调整找到正确的答案，而不像人类那样依赖明确的思维和推理过程。</li>
<li><strong>未来发展</strong>：虽然当前无法完全解释深度学习的过程，但随着技术进步，未来可能会出现更好的方法帮助我们理解这些“黑箱”模型的内部机制。</li>
</ol>
</li>
<li><p>这几个关键点总结了深度学习的“学习能力”、它的“黑箱性质”、以及它与人类认知的差异。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/02/12/20250212-da-yu-yan-mo-xing-dui-hua-ji-lu-yu-si-kao-bei-wang-lu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/12/20250212-da-yu-yan-mo-xing-dui-hua-ji-lu-yu-si-kao-bei-wang-lu/" itemprop="url">大语言模型对话记录与思考备忘录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-12T19:17:14+08:00">
                2025-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>记录与大语言模型的对话，探索疑问与思考<br>内容可能持续更新，作为大模型演变的历史备忘<br>有些问题非原创，来源网络</p>
</blockquote>
</blockquote>
<hr>
<h1 id="大模型的推理能力"><a href="#大模型的推理能力" class="headerlink" title="大模型的推理能力"></a>大模型的推理能力</h1><hr>
<h2 id="大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？"><a href="#大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？" class="headerlink" title="大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？"></a>大模型能从训练数据中识别互相矛盾的逻辑吗？或者说，大模型具备逻辑推理能力，能发现逻辑错误吗？</h2><blockquote>
<blockquote>
<p> From chatGPT (2025-02-12)</p>
</blockquote>
</blockquote>
<p>好的，按你给的格式调整后是这样：</p>
<p>大模型，如GPT类模型，能够一定程度地识别并指出逻辑上的矛盾或错误，但它的能力有一定的局限性。具体来说：</p>
<ol>
<li><p><strong>从训练数据中识别矛盾</strong>：大模型通过暴露于大量文本数据，在训练过程中学会识别常见的逻辑错误或不一致的情况。如果某个陈述前后矛盾或与常识相悖，模型有时能检测到这些问题。然而，这种识别主要依赖于训练数据中的模式，而非深度理解。</p>
</li>
<li><p><strong>推理能力</strong>：大模型表面上似乎能够进行推理，但其推理过程更多是基于统计模式匹配，而非逻辑推理。它能在一些标准情境下给出合理的答案，但在面对复杂的逻辑链条或抽象推理时，表现可能不如人类或专门的逻辑推理系统。</p>
</li>
<li><p><strong>局限性</strong>：大模型的推理能力受到训练数据质量和多样性的限制。如果训练数据包含不一致的示例或错误的推理模式，模型可能会学到并延续这些错误。对于一些高度专业化的推理任务（如数学证明或严谨的形式逻辑推理），大模型的能力仍然有限。</p>
</li>
</ol>
<p>总结来说，大模型能够识别一些常见的逻辑错误或矛盾，尤其是那些明显的错误，但它的推理能力与人类的深层次逻辑思考存在差距，也不具备专门的推理系统那样的准确性。</p>
<hr>
<h2 id="ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？"><a href="#ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？" class="headerlink" title="ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？"></a>ChatGPT的推理能力是如何实现的？它具备哪些优势和局限？</h2><blockquote>
<blockquote>
<p> From chatGPT (2025-02-12)</p>
</blockquote>
</blockquote>
<p>ChatGPT展现出的推理能力，实际上并不是人类意义上的“思考”，而是基于大量数据和算法模拟的逻辑模式。这种能力的实现可以从以下几个方面理解：</p>
<ol>
<li><p><strong>基于大规模语言模型的训练</strong><br>ChatGPT通过大规模语言数据的训练，包括书籍、论文、对话和逻辑推理的例子，学习到了如何理解问题结构、模拟人类的逻辑推导过程，并生成符合逻辑的回答。核心在于，模型并不真正“理解”逻辑，而是通过统计关联，从大量训练数据中学习到解决类似问题的模式。</p>
</li>
<li><p><strong>基于概率的回答生成</strong><br>ChatGPT生成回答的过程是基于概率分布的。它会根据问题内容预测接下来的最可能的单词或句子，尤其是在逻辑推理问题中，看起来像是在推理，实际上是在复现训练数据中类似问题的逻辑模式。通过结合训练数据中的逻辑规则，它动态生成符合问题需求的步骤。</p>
</li>
<li><p><strong>内部机制：注意力机制与自回归生成</strong>  </p>
<ul>
<li><strong>注意力机制（Attention Mechanism）</strong>：这是GPT模型的核心，通过注意力机制，模型可以“记住”上下文内容，从而保持逻辑连贯性。</li>
<li><strong>自回归生成（Autoregressive Generation）</strong>：模型逐词生成答案，并在生成过程中不断参考之前生成的内容，保证推理步骤清晰、有条理。</li>
</ul>
</li>
<li><p><strong>模拟逻辑推理的实现</strong><br>对于逻辑推理类问题，ChatGPT的表现依赖两个关键点：</p>
<ul>
<li><strong>模式识别</strong>：它能够识别问题结构并提取逻辑关系，如“甲说乙说谎”，“丙说甲和乙都说谎”。</li>
<li><strong>排除矛盾</strong>：通过“假设-验证-排除”过程，模拟人类的假设验证，判断假设是否导致矛盾。这个过程并非真正的推理，而是基于大量类似问题的经验模式。</li>
</ul>
</li>
<li><p><strong>ChatGPT的优势和局限</strong>  </p>
<ul>
<li><strong>优势</strong>：<ul>
<li>在简单的逻辑推理任务中表现良好，尤其是规则清晰、条件有限的问题。</li>
<li>能快速“推导”出答案并通过自然语言呈现清晰的推理过程。</li>
</ul>
</li>
<li><strong>局限</strong>：<ul>
<li><strong>不具备真正的理解能力</strong>：它并不是从问题本质进行推理，而是利用数据中学到的模式。</li>
<li><strong>复杂逻辑容易出错</strong>：如果逻辑嵌套太深或需要跨领域知识，可能会出错。</li>
<li><strong>缺乏主动性</strong>：无法主动思考问题的背景或意图，只能根据输入提供答案。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong><br>ChatGPT的推理能力是通过模式匹配、注意力机制和语言生成技术实现的。它能够模拟逻辑推理的步骤，但并不具备真正的逻辑思维或理解能力。这种能力本质上是深度学习在海量数据上的“概率学习”和“语言模式复现”，通过这种方式实现了让人类看起来“像在思考”的效果。</p>
<hr>
<h2 id="推理模型-vs-通用大模型"><a href="#推理模型-vs-通用大模型" class="headerlink" title="推理模型 vs 通用大模型"></a>推理模型 vs 通用大模型</h2><blockquote>
<blockquote>
<p> From Grok3 （2025-02-23）</p>
</blockquote>
</blockquote>
<ul>
<li>关键点：推理模型与通用大模型在训练方式、推理过程和用途上有显著差异，推理模型更注重逻辑推理，通用大模型则更注重文本生成。</li>
<li>训练方式的不同：<ul>
<li>通用大模型通常通过监督学习在大规模文本数据上训练，目标是预测下一个词，适合广泛的语言任务。</li>
<li>推理模型则常使用强化学习进行微调，鼓励逐步推理，特别针对数学、科学和编码等需要逻辑推理的任务进行优化。</li>
</ul>
</li>
<li>推理过程的差异：<ul>
<li>通用大模型直接生成答案，基于统计模式。</li>
<li>推理模型采用链式思维（CoT）方法，将问题分解为步骤，逐步解决，类似于人类思考过程，这在复杂问题上表现更好。</li>
</ul>
</li>
<li>用途和性能<ul>
<li>通用大模型用于文本摘要、翻译等任务。旨在处理广泛的自然语言任务。这些模型通过在大规模文本数据上训练，学习预测下一个词的概率分布，适用于文本生成、翻译和问答等任务。</li>
<li>推理模型擅长需要逻辑推理的任务，如解数学题或编写代码，尤其在多步推理任务上表现优异。一种专门设计或微调的模型，专注于复杂推理任务，如数学问题解决、科学推理和编码。这些模型通过链式思维（CoT）等技术，逐步分解问题并推理出答案，试图模拟人类逻辑思维过程。</li>
</ul>
</li>
</ul>
<h2 id="大模型推理能力不依赖外部的插件"><a href="#大模型推理能力不依赖外部的插件" class="headerlink" title="大模型推理能力不依赖外部的插件"></a>大模型推理能力不依赖外部的插件</h2><blockquote>
<blockquote>
<p>From Grok3 （2025-02-23）</p>
</blockquote>
</blockquote>
<ul>
<li>关键要点：大语言模型不使用外部计算插件进行数学计算。它们的数学计算完全依赖模型自身的推理能力，通过文本生成来解决问题。</li>
<li>大语言模型如ChatGPT、DeepSeek-LLM和Grok在进行数学计算时，不使用外部计算插件。它们完全依靠自身的推理能力，通过生成文本的方式一步步解决问题。例如，当你问“2+2&#x3D;？”时，模型会基于训练数据预测答案，而不是调用外部工具进行计算。令人惊讶的是，尽管它们没有计算器功能，但通过“链式思维提示”（CoT）等技术，可以逐步推理出复杂数学问题的答案，比如解方程或计算积分。</li>
<li>模型如何进行数学计算：这些模型通过训练数据学习数学模式和规则，预测文本序列来完成计算。比如，模型可能学会“5+3&#x3D;8”是因为训练数据中有大量类似例子。它们没有内置的计算模块，而是依靠语言生成能力来模拟计算过程。</li>
<li>是否使用外部工具：标准版本的这些模型不使用外部计算插件，但在某些开发者集成下，可以通过插件（如Wolfram Alpha）增强计算能力。但这不是模型本身的默认行为。</li>
<li>实际表现：模型在简单计算上表现不错，但复杂计算（如多位数乘法）可能出错，因为它们依赖文本预测而非精确计算。</li>
<li>结论：大语言模型的数学计算能力完全由模型自身推理得出，不使用外部计算插件。它们的计算基于文本生成和模式识别，通过训练数据和提示技术（如CoT）增强表现，但在复杂任务上可能出错。</li>
</ul>
<h2 id="大语言模型的推理能力"><a href="#大语言模型的推理能力" class="headerlink" title="大语言模型的推理能力"></a>大语言模型的推理能力</h2><blockquote>
<blockquote>
<p> From Grok3 （2025-02-23）</p>
</blockquote>
</blockquote>
<ul>
<li>大语言模型的推理能力主要依赖于它们的训练和设计，而不是完全基于思维链（CoT）。CoT是一种提示技术，可以引导模型逐步思考，从而改善推理输出，但模型本身的推理能力来自其语言生成能力。</li>
</ul>
<hr>
<hr>
<h1 id="个人思考和理解"><a href="#个人思考和理解" class="headerlink" title="个人思考和理解"></a>个人思考和理解</h1><hr>
<h2 id="AI-数据获取的局限性"><a href="#AI-数据获取的局限性" class="headerlink" title="AI 数据获取的局限性"></a>AI 数据获取的局限性</h2><blockquote>
<blockquote>
<p>经Grok3[DeepSearch]优化 （2025-02-25）</p>
</blockquote>
</blockquote>
<ul>
<li>当前AI在自主寻找和筛选数据方面仍存在局限性，研究表明其难以独立完成如安装应用或通过实名验证等任务。<ul>
<li>MCP统一协议来实现（2025-05-28）</li>
</ul>
</li>
<li>AI缺乏有效判断数据质量和相关性的能力，可能导致处理大量无用信息，浪费计算资源并可能降低性能。</li>
<li>因此，训练数据的选择仍需依赖人类的专业判断，以确保数据的准确性和相关性。</li>
</ul>
<hr>
<hr>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><hr>
<h2 id="有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的"><a href="#有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的" class="headerlink" title="有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的"></a>有甲乙丙三个人，有人只说真话有人只说假话。现在，甲说乙说谎，乙说丙说谎，丙说甲和乙都说谎。问谁是说谎的</h2><blockquote>
<blockquote>
<p>From chatGPT (2025-02-12)</p>
</blockquote>
</blockquote>
<p>这个问题可以通过逻辑推理来解答。我们可以假设每个人分别说真话或说谎，并根据他们的陈述进行推理。</p>
<h3 id="陈述内容："><a href="#陈述内容：" class="headerlink" title="陈述内容："></a>陈述内容：</h3><ul>
<li>甲说乙说谎。</li>
<li>乙说丙说谎。</li>
<li>丙说甲和乙都说谎。</li>
</ul>
<h3 id="假设："><a href="#假设：" class="headerlink" title="假设："></a>假设：</h3><p>假设甲说的是真的，那么：</p>
<ul>
<li>甲说乙说谎。所以乙是说谎者。</li>
<li>乙说丙说谎。如果乙是说谎者，那么乙说的应该是假的，即丙不说谎。</li>
<li>丙说甲和乙都说谎。如果丙不说谎，那么丙的说法应该是真的。所以甲和乙都应该是说谎者，但这与我们的假设矛盾，因为我们已经假设甲是说真话的。</li>
</ul>
<p>所以，假设甲说真话的情况矛盾，甲不可能是说真话的。</p>
<p>接下来，假设乙说的是真的：</p>
<ul>
<li>乙说丙说谎，所以丙是说谎者。</li>
<li>丙说甲和乙都说谎。因为丙是说谎者，丙的话不成立，因此甲和乙至少有一个是说真话的，这与假设乙说真话一致。</li>
<li>甲说乙说谎。如果甲是说谎者，那么甲的话应该是假的，所以乙说的是真的，符合假设。</li>
</ul>
<p>因此，乙是说真话的，甲和丙是说谎的。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>甲和丙是说谎的，乙是说真话的。</p>
<hr>
<h2 id="ChatGPT是如何“算”出单词中字母“t”的个数的？"><a href="#ChatGPT是如何“算”出单词中字母“t”的个数的？" class="headerlink" title="ChatGPT是如何“算”出单词中字母“t”的个数的？"></a>ChatGPT是如何“算”出单词中字母“t”的个数的？</h2><p>ChatGPT并不是通过逐一计算字母“t”的个数来得出答案，而是通过以下几个步骤来实现的：</p>
<ol>
<li><p><strong>文本解析和模式识别</strong><br>当接收到像“Attention有几个t”这样的问题时，模型识别到这是与字母统计相关的查询，并提取出关键词“attention”，随后在该单词的字符序列中查找所有的字母“t”。</p>
</li>
<li><p><strong>背后逻辑的实现</strong><br>ChatGPT生成答案的过程其实涉及语言生成的几个步骤：</p>
<ul>
<li><strong>拆分单词：</strong> 模型识别出字符串“attention”。</li>
<li><strong>统计字母：</strong> 模型检测每个字母的出现次数，特别关注字母“t”。</li>
<li><strong>生成回答：</strong> 模型根据其训练中学到的模式直接输出答案，例如“3个t”。</li>
</ul>
</li>
<li><p><strong>本质：语言生成vs算法实现</strong><br>虽然从表面看，ChatGPT像是在“数”字母“t”，但其实：</p>
<ul>
<li>它可能基于训练数据中“attention”单词的字符分布知识，快速得出答案。</li>
<li>如果该单词在训练数据中从未出现过，模型会尝试通过字符分析来推测答案，但这不如专门编写的统计算法准确。</li>
</ul>
</li>
</ol>
<p><strong>人类方式与模型行为的对比</strong><br>若由人类解答：</p>
<ol>
<li>人类会直接肉眼数出字母“t”的个数。</li>
<li>确认答案。</li>
</ol>
<p>而ChatGPT则模拟这一过程，通过对字符模式的分析，快速生成一个类似的答案。</p>
<p><strong>总结</strong><br>ChatGPT并没有像传统程序那样逐一遍历字符串，而是基于对字符和单词模式的理解，快速生成了答案。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VuewffOUGhqxA-7qGqm9kg">为什么大模型连”Strawberry”的”r”都数不对？</a><ul>
<li>大模型的生成过程本质上便是在“根据上文预测下一个Token”，而这个概率分布即是在模型训练过程中从大量的文本数据中学习到的，使得大模型学习到了语言的基本知识与模式。</li>
<li>在Prompt中加入一定的引导就能获得理想答案，比如说我们可以利用CoT思维链的方式编写Prompt，引导大模型逐步思考并解决问题。</li>
<li>CoT为思维链（Chain-of-Thought）的缩写简称，是提示工程领域最为重要的提示方法之一，它的核心思路在于通过引导模型逐步展示其推理过程，从而提高其理解和解决复杂问题的能力。在Few-shot（少样本）设置下表现为 在提供的样例中解释推理过程，引导大模型回答时也解释推理过程；而在Zero-shot（零样本）设置下表现为 加入类似“让我们一步步思考（Let’s think step by step）”的引导话术。</li>
<li>对于大模型而言，它的语言本身即是思考，并不存在诉诸于语言之前的思考过程，所以我们也需要引导它像人类一样先思考再判断，将思考过程以语言的方式表达出来。</li>
<li>在大模型推理的时候，我们可以限制大模型 先输出理由，再输出答案，让大模型根据“深度思考”获得的理由与推理过程来预测“答案”，从而大大提升其表现。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="数学中9-11和9-9哪个大"><a href="#数学中9-11和9-9哪个大" class="headerlink" title="数学中9.11和9.9哪个大"></a>数学中9.11和9.9哪个大</h2><blockquote>
<blockquote>
<p>From Grok3 (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="【普通提问】"><a href="#【普通提问】" class="headerlink" title="【普通提问】"></a>【普通提问】</h3><ul>
<li>在数学中，9.11 比 9.9 大。因为 9.11 &#x3D; 9 + 0.11，而 9.9 &#x3D; 9 + 0.9，比较小数部分时，0.11 &lt; 0.9 不成立，实际上 0.11 &gt; 0.9 是错误的表述，正确的比较是直接看数值：9.11 &gt; 9.9。</li>
</ul>
<h3 id="【DeepSearch】"><a href="#【DeepSearch】" class="headerlink" title="【DeepSearch】"></a>【DeepSearch】</h3><ul>
<li>9.9 比 9.11 大<ul>
<li>关键点：在数学中，9.9 似乎比 9.11 大，因为它们的整数部分相同，比较小数部分时，9.9 的十分位是 9，而 9.11 的十分位是 1，9 大于 1。</li>
</ul>
</li>
<li>比较过程<ul>
<li>整数部分：两个数都是 9，相同。</li>
<li>小数部分：9.9 可以写成 9.90，比较十分位，9.9 的十分位是 9，9.11 的十分位是 1，9 &gt; 1，因此 9.9 更大。</li>
<li>意外细节：一些 AI 模型可能会错误地认为 9.11 比 9.9 大，这可能是因为误解了日期比较（如 9 月 11 日比 9 月 9 日晚），但在数学中，小数比较遵循严格的位数规则。</li>
</ul>
</li>
<li>(这里省略了列举了很多查阅网上资料库的细节)</li>
</ul>
<h3 id="【Think】"><a href="#【Think】" class="headerlink" title="【Think】"></a>【Think】</h3><p>在数学中，我们需要比较9.11和9.9这两个数的大小。下面我们一步步分析：</p>
<ol>
<li>将小数对齐<ul>
<li>为了方便比较，我们可以把9.9写成9.90，这样它的小数位数与9.11相同：<ul>
<li>9.11 有两位小数。</li>
<li>9.9 写成 9.90 后也有两位小数。</li>
</ul>
</li>
</ul>
</li>
<li>逐位比较<ul>
<li>现在我们比较 9.11 和 9.90：<ul>
<li>整数部分：<br>  9.11 的整数部分是 9，9.90 的整数部分也是 9，两个数相等。</li>
<li>小数第一位：<br>  9.11 的小数第一位是 1，9.90 的小数第一位是 9。<br>  因为 1 &lt; 9，我们可以在这里得出结论，不需要再比较后续位数。</li>
</ul>
</li>
</ul>
</li>
<li>结论<br>通过逐位比较，我们发现 9.11 &lt; 9.90，也就是说 9.11 &lt; 9.9。<br>或者简单计算：<br>9.11 - 9.9 &#x3D; 9.11 - 9.90 &#x3D; -0.79 &lt; 0，也说明 9.11 比 9.9 小。</li>
</ol>
<p>最终答案<br>在数学中，9.9 比 9.11 大。</p>
<hr>
<h2 id="一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。"><a href="#一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。" class="headerlink" title="一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。"></a>一个汉字具有左右结构，左边是木，右边是乞。这个字是什么？只需回答这个字即可。</h2><blockquote>
<blockquote>
<p>Grok3 (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="【普通提问】-1"><a href="#【普通提问】-1" class="headerlink" title="【普通提问】"></a>【普通提问】</h3><ul>
<li>杞</li>
</ul>
<h3 id="【DeepSearch】-1"><a href="#【DeepSearch】-1" class="headerlink" title="【DeepSearch】"></a>【DeepSearch】</h3><ul>
<li><p>要点</p>
<ul>
<li>看起来，符合条件的汉字可能是“述”（shù），但这并不是完全确定的答案，因为“乞”（qǐ，意为“乞讨”）的结构与“述”的右边“口”（mouth）有一定关联，但不完全匹配。  </li>
<li>研究表明，汉字的左右结构通常由偏旁组成，左边“木”（wood）是常见偏旁，右边“乞”可能指代相关部件，但标准汉字中难以找到完全符合的例子。  </li>
<li>证据倾向于认为，可能存在误解，“乞”可能指代包含“手”和“口”的结构，但这需要进一步确认。</li>
</ul>
</li>
<li><p>最终建议</p>
<ul>
<li>基于以上分析，推荐的答案是“述”（shù），但需注意这可能不是完全精确的匹配，建议用户进一步确认“乞”在问题中的具体含义。</li>
</ul>
</li>
<li><p>好多废话。。。。还答错。。。</p>
</li>
</ul>
<h3 id="【Think】-1"><a href="#【Think】-1" class="headerlink" title="【Think】"></a>【Think】</h3><ul>
<li>杞</li>
</ul>
<blockquote>
<blockquote>
<p>ChatGPT (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="GPT-4o-mini"><a href="#GPT-4o-mini" class="headerlink" title="GPT-4o-mini"></a>GPT-4o-mini</h3><ul>
<li>这个字是“弃”。</li>
</ul>
<h3 id="GPT-4o"><a href="#GPT-4o" class="headerlink" title="GPT-4o"></a>GPT-4o</h3><ul>
<li>杞</li>
</ul>
<h3 id="o3-mini"><a href="#o3-mini" class="headerlink" title="o3-mini"></a>o3-mini</h3><ul>
<li>杞</li>
</ul>
<blockquote>
<blockquote>
<p>claude  (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="claude-3-7-Sonnet"><a href="#claude-3-7-Sonnet" class="headerlink" title="claude 3.7 Sonnet"></a>claude 3.7 Sonnet</h3><ul>
<li>杞</li>
</ul>
<blockquote>
<blockquote>
<p>豆包   (2025-02-25)</p>
</blockquote>
</blockquote>
<ul>
<li>杚</li>
</ul>
<blockquote>
<blockquote>
<p>Gemini  (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="Gemini-2-0-Flash"><a href="#Gemini-2-0-Flash" class="headerlink" title="Gemini 2.0 Flash"></a>Gemini 2.0 Flash</h3><ul>
<li>这个字是“&lt;0xE6&gt;&lt;0xA7&gt;&lt;0x8E&gt;”</li>
</ul>
<h3 id="Gemini-2-0-Flash-Thinking-Experimental"><a href="#Gemini-2-0-Flash-Thinking-Experimental" class="headerlink" title="Gemini 2.0 Flash Thinking Experimental"></a>Gemini 2.0 Flash Thinking Experimental</h3><ul>
<li>这个字是㮆 ()。</li>
</ul>
<h3 id="Gemini-2-0-Flash-Thinking-Experimental-with-apps"><a href="#Gemini-2-0-Flash-Thinking-Experimental-with-apps" class="headerlink" title="Gemini 2.0 Flash Thinking Experimental with apps"></a>Gemini 2.0 Flash Thinking Experimental with apps</h3><ul>
<li>কাঠ</li>
</ul>
<blockquote>
<blockquote>
<p>perplexity  (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="Deep-Research"><a href="#Deep-Research" class="headerlink" title="Deep Research"></a>Deep Research</h3><ul>
<li>没有找到一个汉字左边是“木”，右边是“乞”的组合。可能是由于字形或部首的错误识别。</li>
</ul>
<blockquote>
<blockquote>
<p>deepseek (2025-02-25)</p>
</blockquote>
</blockquote>
<h3 id="DeepThink-R1"><a href="#DeepThink-R1" class="headerlink" title="DeepThink(R1)"></a>DeepThink(R1)</h3><ul>
<li>杚</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>只有豆包和deepseek答对。因为是生僻字中文？还是偷偷给大模型加了插件？还是人家就是这么强？ (2025-02-25)</li>
</ul>
<hr>
<hr>
<h1 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h1><h2 id="“Grok3”的“DeepSearch”和“Think”这两个功能的作用"><a href="#“Grok3”的“DeepSearch”和“Think”这两个功能的作用" class="headerlink" title="“Grok3”的“DeepSearch”和“Think”这两个功能的作用"></a>“Grok3”的“DeepSearch”和“Think”这两个功能的作用</h2><blockquote>
<blockquote>
<p>From Grok3 (2025-02-25)</p>
</blockquote>
</blockquote>
<ul>
<li>DeepSearch 是Grok 3的一个增强型研究工具，专注于从外部资源（如网络和X平台）获取实时信息，并将其整合成简洁、准确的回答。</li>
<li>Think 是Grok 3的推理模式，专注于通过逐步思考来解决需要逻辑分析或复杂计算的问题。</li>
<li>两者的区别与适用场景<ul>
<li>数据来源：DeepSearch依赖外部数据（网络和X），而Think主要依赖Grok自身的知识和推理能力。</li>
<li>任务类型：DeepSearch适合需要实时信息或广泛研究的问题（如新闻、趋势）；Think适合需要逻辑推导或计算的问题（如数学、编程）。</li>
<li>输出方式：DeepSearch给出综合性答案，Think展示详细的推理步骤。</li>
</ul>
</li>
<li>总结<ul>
<li>DeepSearch：你的“研究助手”，帮你查资料、整理信息。</li>
<li>Think：你的“推理伙伴”，帮你解难题、想清楚。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/01/08/20250108-suan-fa-zai-shi-ji-ye-wu-chang-jing-zhong-bing-fei-wan-quan-wu-yong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/08/20250108-suan-fa-zai-shi-ji-ye-wu-chang-jing-zhong-bing-fei-wan-quan-wu-yong/" itemprop="url">算法在实际业务场景中并非完全无用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-01-08T13:33:24+08:00">
                2025-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>从事业务开发的同学经常会抱怨经常面试要刷算法，实际上平常的开发99%以上的事情都不会用到。<br>实际情况确实是这样。平常在写业务逻辑代码时，几乎完全不需要。<br>当然有些技术原理在背八股文的时候，懂一点算法能帮助你更好的理解。<br>而有些特殊业务场景，懂一些算法，确实能帮助你很好的解决问题。<br>下面举两个业务中产品提出的需求作为例子，简单描述如何利用算法有效解决。</p>
</blockquote>
</blockquote>
<h2 id="一、从题库（50道题）中随机抽出10道题-且不能重复"><a href="#一、从题库（50道题）中随机抽出10道题-且不能重复" class="headerlink" title="一、从题库（50道题）中随机抽出10道题,且不能重复"></a>一、从题库（50道题）中随机抽出10道题,且不能重复</h2><ul>
<li><p>最简单的思路：</p>
<ul>
<li>循环10次，每次取50以内的随机数</li>
<li>创建一个hashmap，判断生成的随机数是否在map存在，存在则重新生成</li>
<li>这个方法的缺点时，极端情况下，会多次生成重复的随机数导致要不断重新生成</li>
</ul>
</li>
<li><p>经过一番思考，我设计了一下从m个数中取n个数的算法(m&gt;n), 保证算法只会循环n次 </p>
</li>
<li><p>那时我还是使用Java进行开发</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArr(<span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        data[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(end);</span><br><span class="line">        result[j] = data[y];</span><br><span class="line">        data[y] = data[end - <span class="number">1</span>];</span><br><span class="line">        data[end - <span class="number">1</span>] = result[j];</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后面我才发现原来这个算法叫 洗牌算法（Shuffle Algorithm），或者叫随机乱置算法。</li>
</ul>
<h2 id="通过搜索关键字匹配对应的标签id"><a href="#通过搜索关键字匹配对应的标签id" class="headerlink" title="通过搜索关键字匹配对应的标签id"></a>通过搜索关键字匹配对应的标签id</h2><ul>
<li><p>产品提供了400个标签名称以及对应的标签id，希望能通过搜索的方式找到最相似的标签id，希望能支持模糊匹配</p>
</li>
<li><p>一般思路：</p>
<ul>
<li>方案1: <ol>
<li>将400条数据一次性加载的程序内存</li>
<li>遍历数据400条使用字符串的contains方法，找到第一条匹配数据就跳出，否则继续</li>
</ol>
</li>
<li>方案2:<ol>
<li>直接将数据导入到ES搜索引擎，利用ES自带的分词等搜索功能</li>
<li>通过调ES，搜索得到标签id</li>
</ol>
</li>
</ul>
</li>
<li><p>简单分析方案：</p>
<ul>
<li>方案1，性能太差，极端情况需要遍历所有数据</li>
<li>方案2，需要新搭建ES集群，实现代价比较高</li>
</ul>
</li>
<li><p>经过一番思考，以及从产品本身实际需求上出发，我涉及出以下的方案</p>
<ol>
<li>将数据的标签名字使用中文分词库<a target="_blank" rel="noopener" href="https://github.com/go-ego/gse">gse</a>进行分词</li>
<li>将分词和对应的标签数据，构建前缀匹配树</li>
<li>当搜索时，使用提前构建好的前缀匹配树，即可快速找到对应的标签id</li>
</ol>
</li>
<li><p>这时我已经转使用Go来开发了</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	children <span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode</span><br><span class="line">	isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrieNode</span><span class="params">()</span></span> *TrieNode &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TrieNode&#123;</span><br><span class="line">		children: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode),</span><br><span class="line">		isEnd:    <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrie</span><span class="params">()</span></span> *Trie &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Trie&#123;</span><br><span class="line">		root: NewTrieNode(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">	node := t.root</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line">			node.children[char] = NewTrieNode()</span><br><span class="line">		&#125;</span><br><span class="line">		node = node.children[char]</span><br><span class="line">	&#125;</span><br><span class="line">	node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	node := t.root</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		node = node.children[char]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> FuzzySearch(prefix <span class="type">string</span>) []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">	node := t.root</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := node.children[char]; !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">		node = node.children[char]</span><br><span class="line">	&#125;</span><br><span class="line">	t.collectWords(node, prefix, &amp;result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> collectWords(node *TrieNode, prefix <span class="type">string</span>, result *[]<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> node.isEnd &#123;</span><br><span class="line">		*result = <span class="built_in">append</span>(*result, prefix)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> char, child := <span class="keyword">range</span> node.children &#123;</span><br><span class="line">		t.collectWords(child, prefix+<span class="type">string</span>(char), result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个算法就是经典的Trie字典树（前缀树），如果我之前没了解过这些算法，可能一时间没那么快能想到用这个方式高效完成这个需求。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>了解一些算法，在实际业务开发，有时候也能运用到。</li>
<li>另外，现在处于AI时代，即时不了解算法，善于组织语言和上下文，向AI提问，基本它也能引导你找到合适的解决方案。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/" itemprop="url">简单研究一下人工智能和数学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-01-06T18:02:28+08:00">
                2025-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>简单记录，未完善<br>内容基本来源书籍</p>
</blockquote>
</blockquote>
<p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%95%B0%E5%AD%A6.png"></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="初等数学"><a href="#初等数学" class="headerlink" title="初等数学"></a>初等数学</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数的表示方法主要有三种：解析法（公式法）、图像法和表格法。在微积分中讨论的函数几乎都是用解析法表示的。</li>
</ul>
<h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><ul>
<li>二项式定理又称为牛顿二项式定理，它可将两个数之和的整数次幂展开为相应项之和。</li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="人工智能数学"><a href="#人工智能数学" class="headerlink" title="人工智能数学"></a>人工智能数学</h1><ul>
<li><p>从发展历程来看，人工智能先后经历了推理机、专家系统及机器学习三个阶段。</p>
</li>
<li><p>当前的人工智能系统多为学习型。为了减小误差，其用数据去训练假设模型，也就是进行所谓的学习，当误差降到最小时，就把这个假设模型用于其他现实问题。</p>
</li>
<li><p>人工智能实际上是一个将数学、算法理论和工程实践紧密结合的领域。人工智能从本质上来看就是算法，是概率论、统计学等各种数学理论的体现。数学作为表达与刻画人工智能模型的工具，是深入理解人工智能算法原理必备的基础知识。人工智能与数学高度相关，可以说人工智能的核心是数学，计算机只是实现人工智能模型的工具。</p>
</li>
<li><p>函数逼近：随着大数据和人工智能技术的发展，机器学习和深度学习在大数据挖掘、模式识别和智能分析越来越受重视。机器学习是一种基于数据的学习方法，其从观测数据所包含的有限信息中构造一个模型，利用该模型对未知数据或无法观测的数据进行尽可能准确的预测，这种模型称为学习机器。对数据科学而言，所有的数据都是以数字形式表示的，通过定义损失函数，选择合适的核函数或激活函数，反复学习后可达到一种最佳逼近状态，因此，机器学习问题实际上是函数估计问题或函数逼近问题。</p>
</li>
</ul>
<h2 id="微积分-1"><a href="#微积分-1" class="headerlink" title="微积分"></a>微积分</h2><ul>
<li>求导是微积分的基本概念之一，也是很多理工科领域的基础运算。导数是变化率的极限，是用来找到“线性近似”的数学工具，是一种线性变换，体现了无穷、极限、分割的数学思想，主要用来解决极值问题。人工智能算法的最终目标是得到最优化模型，其最后都可转化为求极大值或极小值的问题。</li>
<li>比如，梯度下降法和牛顿法是人工智能的基础算法，现在主流的求解代价函数最优解的方法都是基于这两种算法改造的，如随机梯度法和拟牛顿法，其底层运算就是基础的导数运算。</li>
<li>级数也是微积分中非常重要的概念，常见的级数有泰勒级数、傅里叶级数等，它们在人工智能算法中也有非常重要的地位。</li>
<li>泰勒级数体现了用多项式近似和逼近函数的思想。</li>
<li>泰勒级数在人工智能算法的底层起到了非常重要的作用，泰勒级数对理解很多基础算法的原理很有帮助。例如，梯度下降法的数学原理涉及代价函数的一阶泰勒近似，而牛顿法的推导过程应用了目标函数的二阶泰勒近似。</li>
<li>凸函数也是微积分中的重要概念，人工智能算法中涉及的优化问题要求函数模型必须是凸函数，否则优化问题没有最优解。</li>
<li>微积分中还有许多概念，如方向导数、梯度、伽马函数等，它们都在人工智能中有广泛的应用</li>
</ul>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul>
<li>线性代数的基本原理在人工智能算法中处于核心地位，在人工智能的语义分析、推荐系统、卷积神经网络等方面有大量应用，是目前最前沿的深度学习算法原理的基础。</li>
</ul>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ul>
<li>很多机器学习算法是以概率统计的理论为基础支撑推导出来的，比如代价函数的最小二乘形式、逻辑回归算法都基于对模型的最大似然估计。</li>
<li>概率论中的高斯函数及中心极限定理被广泛用于人工智能算法。独立同分布的不同随机变量之和会随变量数的增加而趋于高斯分布，因此，很多模型假设都采用高斯函数进行建模。</li>
</ul>
<h2 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h2><ul>
<li>概率论作用的前提是随机变量的分布已知，其根据已知的分布来分析随机变量的特征与规律；数理统计的研究对象则是分布未知的随机变量，其研究方法是对随机变量进行独立重复的观察，根据得到的观察结果对原始分布做出推断，数理统计可以看作逆向的概率论。</li>
<li>若检验是通过随机抽取的样本来对一个总体的判断结果进行认可或否定，则可以将其用于估计机器学习模型的泛化能力。</li>
</ul>
<h2 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h2><ul>
<li>人工智能的目标就是最优化，就是在复杂环境与多体交互中做出最优决策。几乎所有的人工智能问题最后都会归结为一个优化问题的求解，因此，最优化理论同样是学习、研究人工智能必备的基础知识。<br>最优化理论研究的问题是判定给定目标函数是否存在最大值或最小值，并找到令目标函数取最大值或最小值的数值。如果把给定的目标函数看成连绵的山脉，最优化的过程就是找到顶峰（谷底）且到达顶峰（谷底）的过程。</li>
<li>最优化理论的研究内容主要包括线性规划、（不）精确搜索、梯度下降法、牛顿法、共轭梯度法、拟牛顿法、（非）线性最小二乘法、约束优化最优性条件、二次规划、罚函数法和信赖域法等。</li>
<li>要实现最小化或最大化的函数称为目标函数，大多数最优化问题都可以通过使目标函数￼最小化解决，最大化问题也可以通过最小化￼来解决。最优化方法找到的可能是目标函数的全局最小值，也可能是局部极小值，两者的区别在于全局最小值比定义域内所有其他点的函数值都小，而局部极小值只比所有邻近点的函数值小。</li>
<li>当目标函数的输入参数较多、解空间较大时，大多数实用的最优化方法都不能满足全局搜索对计算复杂度的要求，因而只能求出局部极小值。但是，在人工智能和深度学习的应用场景中，只要目标函数的取值足够小，就可以把这个值当作全局最小值使用，以此作为对性能和复杂度的折中。</li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<blockquote>
<blockquote>
<p>程序员的数学</p>
</blockquote>
</blockquote>
<h2 id="迈向机器学习的第一步"><a href="#迈向机器学习的第一步" class="headerlink" title="迈向机器学习的第一步"></a>迈向机器学习的第一步</h2><ul>
<li><p>由输入和目标组成的数据称为训练数据。机器学习中所谓的学习，就是为了通过给定的输入得到和目标尽可能接近的输出，使用训练数据对参数进行调整的过程。使用训练数据对参数进行过调整的模型称为训练好的模型。对于训练好的模型，需要用测试数据对其进行测试，从而评价训练的效果。</p>
</li>
<li><p>在机器学习中对参数进行调整的过程，不是由程序员完成的，而是由计算机通过训练数据自动完成的，这正是机器学习的一大特征。</p>
</li>
<li><p>这里先做个总结吧。我们面对预测问题，首先要有好的模型加上大量的训练数然后，我们需要的是“能根据输人向量，得到和目标向量尽量接近的输出向量”这样一个训练好的模型。</p>
</li>
<li><p>解决分类问题的过程，也可以说是从大量数据中总结规律和规则，从而发现模式的过程。机器学习并不会要求程序员提前研究手写字符的各种形态再去设计程序，而是由计算机根据训练数据来调整参数，从而得到分类模型，这才是它的特征所在。</p>
</li>
</ul>
<p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png"><br><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B02.png"></p>
<ul>
<li><p>如果机器对训练数据能给出完美的输出，对测试数据给出的结果却不尽如人意，很有可能是发生了过拟合（overfitting）。用学生来说，就好比是课堂上做过的训练题都能解得很好，但考试成绩却不怎么理想。</p>
</li>
<li><p>在学习的过程中，需要比较输出和正确的值。拿这个简单的例子来说，要比较的对象就是由输入x1，x2通过给定模型得到的输出y和目标t。如果y和的值一致，那当然好，但一般并不会这么理想。对学习结果（输出）的评价不是单纯的“好与不好”，而是要知道它与训练数据中给出的目标相比“到底有多不好”。为了实现这种评价，需要引入损失函数。<br>在具体的机器学习问题中，如何选取恰当的损失函数是个重要且有难度的问题。比如使用平方和误差函数。</p>
</li>
<li><p>要通过调整模型中的权重参数，使得损失函数值尽可能接近于0。</p>
</li>
<li><p>梯度下降法<br><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95.png"></p>
</li>
<li><p>作为程序员要做些什么</p>
<ul>
<li>在构建模型这个阶段，程序员是要参与的，但是参数的自动调整过程，程序员不会参与。也就是说，程序员不去直接指定参数的具体数值，而是通过模型、损失函数、训练数据，间接地让参数的选取向着更优的方向变化，从而得到需要的参数。即使模型、损失函数都相同，只要训练数据不同，学习后得到的模型也会截然不同。</li>
<li>机器学习是基于数据让机器去学习，程序员并不直接参与其中。这就像硬件配置完全同的计算机，如果软件系统不一样，整个运行模式也会不一样。把软件换掉，同一套硬件系统也会根据不同的指令做出不一样的事情。道理类似，就算模型一样，只要训练数据不同，最后模型的运行模式也会不一样。</li>
</ul>
</li>
<li><p>神经网络是指，把像感知器一样有输入和输出的节点排列起来形成的带有层次的结构。神经网络（neural network）这个词来源于生物的信息传递方式。在感知器中，输出是二元的，取值只有0或1两种情况，而神经网络中的节点输出的就不是二元，而是可以进行微分运算的连续值。</p>
</li>
</ul>
<p><img src="/2025/01/06/20250106-jian-dan-yan-jiu-yi-xia-ren-gong-zhi-neng-he-shu-xue/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png"></p>
<ul>
<li><p>深度学习是在神经网络的基础上，通过增加层数得到的更加“深化”的模型。增加层数是为了更加精确地拟合复杂函数，就算涉及的参数个数不做大的变动，也能得到更好的模型。至于如何“深化”在理论上更为有效，依然是现在研究的热点之一。</p>
</li>
<li><p>强化学习是在“无监督”的条件下进行的“学习”。也就是说，在学习过程中没有标准答案可供参考。强化学习通过试错来寻找最优输出，对每个输出，系统都会提供反馈（奖励），模型的参数可以根据得到的反馈来调整。</p>
</li>
<li><p>做出决策</p>
<ul>
<li>机器学习会根据输人的数据预测未来。这种意义下的预测，是基于先前的经验进行的，得到的是未来最有可能发生的情况（数值）。但是，得到预测值之后“应该做些什么”，机器是无法决定的。也就是说，它们无法进行决策。</li>
<li>通过机器学习这个方法，机器可以告诉我们在未来什么样的行动会导致事情如何发展。</li>
<li>但是，做决策这件事本身，并不能让机器来做。</li>
<li>顺着这个话题继续讲下去，就不是技术问题，而是伦理问题了。比如，在减轻痛苦和延续生命之中二选一的问题等，只能由个人的意志来决定，不可能委托给机器学习。</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>《人工智能数学基础》</li>
<li>《程序员的数学》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/01/01/20250101-shi-yong-ai-zong-jie-liao-zhe-ge-wang-zhan-de-nei-rong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/01/20250101-shi-yong-ai-zong-jie-liao-zhe-ge-wang-zhan-de-nei-rong/" itemprop="url">使用AI总结了这个网站的内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-01-01T00:29:21+08:00">
                2025-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>使用google的notebooklm总结目前该网站的所有文章内容<br><a target="_blank" rel="noopener" href="https://notebooklm.google.com/">https://notebooklm.google.com/</a><br>问题：全面阐述和总结一下这个博客网站的内容，涉及领域，博主风格等</p>
</blockquote>
</blockquote>
<hr>
<p>该博客网站的内容主要涵盖了<strong>个人成长和职业发展</strong>两个方面，涉及领域包括：</p>
<ul>
<li><strong>自我营销</strong>:  如何打造个人品牌，提升影响力。</li>
<li><strong>时间管理</strong>: 如何提高工作效率，克服拖延。</li>
<li><strong>学习方法</strong>: 如何快速学习，进行深度学习，构建个人知识体系。</li>
<li><strong>心理素质</strong>: 如何拥有积极心态，提升情绪力。</li>
<li><strong>职业发展</strong>: 如何成为一名专业的软件开发人员，进行有效的薪酬谈判。</li>
<li><strong>创业</strong>: 如何打造成功的产品，制定切实可行的创业计划。</li>
<li><strong>健身</strong>: 如何利用科技产品实现健身目标。</li>
<li><strong>人际关系</strong>: 如何与他人相处，建立良好的人际关系。</li>
<li><strong>精神</strong>: 如何利用心灵的力量，克服天性，实现个人成长。</li>
<li><strong>金融</strong>: 如何理解金融危机，以及金融政策的作用。</li>
<li><strong>公司文化</strong>: 如何打造面向未来的新型组织文化，以网飞为例。</li>
<li><strong>历史</strong>: 如何理解人类社会的发展，以文字和政治组织为例。</li>
</ul>
<p>博主风格：</p>
<ul>
<li><strong>注重实用性</strong>: 博主的内容以解决实际问题为导向，提供具体可行的建议和方法。</li>
<li><strong>结合个人经验</strong>: 博主经常结合自身经历和感悟，使得内容更具说服力。</li>
<li><strong>善于运用类比</strong>: 博主擅长用通俗易懂的类比来解释复杂的概念，使读者更容易理解。</li>
<li><strong>强调深度思考</strong>: 博主鼓励读者进行深度思考，并将知识与自身实际相结合。</li>
<li><strong>注重科学依据</strong>: 博主经常引用科学研究和理论来支持自己的观点，增强内容的可信度。</li>
</ul>
<p>总而言之，该博客网站的内容丰富实用，风格清晰易懂，对于想要提升个人能力和实现职业成功的读者来说，具有很高的参考价值。</p>
<hr>
<h2 id="排除掉笔记类文章后"><a href="#排除掉笔记类文章后" class="headerlink" title="排除掉笔记类文章后"></a>排除掉笔记类文章后</h2><p>这个博客网站的内容主要涉及<strong>软件开发和技术管理</strong>领域，涵盖了<strong>业务方案、架构设计、技术实践、团队管理和个人成长</strong>等方面。博主的写作风格<strong>简洁、实用、注重经验总结和思考</strong>，文章内容多来自实际工作中的问题和解决方案，并结合个人思考和学习心得进行阐述。</p>
<p>以下是该博客网站内容的详细分析：</p>
<p><strong>一、内容领域：</strong></p>
<ul>
<li><strong>业务方案：</strong>涵盖了分页、兼容性、事务、前置校验、幂等、错误码处理、接口安全、容灾降级、货币体系设计、榜单实现等常见业务场景的解决方案和实践经验总结。</li>
<li><strong>架构设计：</strong>探讨了微服务架构、服务间一致性、数据库高可用方案、容灾架构、聚合层设计等架构设计理念和实践经验。</li>
<li><strong>技术实践：</strong>分享了RPC调用、事务处理、数据库同步、Redis应用、单元测试、配置中心、序列化协议等技术点的实践经验和工具技巧。</li>
<li><strong>团队管理：</strong>总结了个人管理经验、小团队管理要点、项目管理技巧、团队协作、沟通技巧等团队管理方面的经验和思考。</li>
<li><strong>个人成长：</strong>记录了博主从PHP、C++、Lua到Java、Go、Rust等不同编程语言的学习和实践经历，以及对技术发展趋势的思考和个人职业发展的感悟。</li>
</ul>
<p><strong>二、博主风格:</strong></p>
<ul>
<li><strong>简洁实用：</strong>文章语言简洁明了，直击问题核心，注重实用性，避免过多理论和概念的堆砌。</li>
<li><strong>经验总结：</strong>文章内容多来自博主实际工作中遇到的问题和解决方案，并进行总结提炼，形成可供参考的经验。</li>
<li><strong>思考深入：</strong>博主不局限于问题本身，而是深入思考问题背后的原因和本质，并提出自己的见解和解决方案。</li>
<li><strong>持续学习：</strong>博主不断学习新的技术和知识，并将其应用到实际工作中，乐于分享自己的学习心得和体会。</li>
</ul>
<p><strong>三、其他特点:</strong></p>
<ul>
<li><strong>注重代码质量：</strong>博主强调单元测试、代码规范、代码扫描工具等提升代码质量的方法。</li>
<li><strong>关注团队协作：</strong>博主重视团队沟通、信息透明、知识分享等，提倡高效的团队协作方式。</li>
<li><strong>追求技术进步：</strong>博主积极探索新的技术和架构，并思考技术发展趋势对个人和团队的影响。</li>
</ul>
<p><strong>总结:</strong></p>
<p>该博客网站内容丰富，涵盖了软件开发和技术管理的多个方面，体现了博主丰富的实践经验和深入的思考。博主的写作风格简洁实用，注重经验总结和思考，对于从事相关领域工作的读者具有较高的参考价值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/12/31/20241231-ai-gong-ye-ge-ming-xia-de-ruo-gan-si-kao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/31/20241231-ai-gong-ye-ge-ming-xia-de-ruo-gan-si-kao/" itemprop="url">AI工业革命下的若干思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-12-31T15:24:38+08:00">
                2024-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>随着AI工具变得日益智能，人们对自身可能被取代的担忧也在增加。<br>回顾以往工业革命带来的社会变迁，或许能从中推测出未来发展的趋势。<br>以下内容由ChatGPT辅助生成。</p>
</blockquote>
</blockquote>
<h1 id="AI对就业的双重影响"><a href="#AI对就业的双重影响" class="headerlink" title="AI对就业的双重影响"></a>AI对就业的双重影响</h1><ul>
<li>AI技术对就业市场带来了创造效应和破坏效应：<ul>
<li>创造效应：AI的普及将催生了许多潜在的新兴职业。这些新兴岗位对熟练掌握AI工具的专业人才需求旺盛。</li>
<li>破坏效应：AI替代了许多重复性、规则性较强的岗位。某些中等技能的岗位如流水线操作、传统文秘工作可能面临消失的风险。</li>
</ul>
</li>
</ul>
<h1 id="历史视角：被替代的人何去何从"><a href="#历史视角：被替代的人何去何从" class="headerlink" title="历史视角：被替代的人何去何从"></a>历史视角：被替代的人何去何从</h1><ul>
<li><p>随着AI技术的发展，未来许多人的工作将不可避免地被替代，这其中包括一部分程序员，但相较而言，更多非程序员的工作可能会首当其冲。然而，那些更擅长使用并深刻理解AI工具的人将更有可能保住自己的职位。</p>
</li>
<li><p>回顾工业革命，技术进步曾一度导致大批劳动者失业，许多人因无法适应新变化而成为时代的“牺牲品”，收入锐减。</p>
</li>
<li><p>短期内，某些群体的失业可能难以避免，但历史也表明，技术变革往往伴随着新机会的诞生。</p>
</li>
<li><p>所以，个人需要做好准备：</p>
<ul>
<li>提升自身技能，特别是AI工具的使用和相关领域的知识储备。</li>
<li>即便不能马上参与高端AI开发，也可以从简单的AI相关工作入手，逐步积累经验。</li>
<li>有一定资产的群体，应学会投资，通过多样化方式应对收入变化。</li>
</ul>
</li>
</ul>
<h1 id="正面效应"><a href="#正面效应" class="headerlink" title="正面效应"></a>正面效应</h1><ul>
<li>催生新型岗位：AI技术完善后，将需要大量擅长操作和优化AI工具的人才。</li>
<li>解放低级劳动：AI让人类摆脱低级脑力劳动，从而获得更高工资和更有意义的工作体验。</li>
<li>效率提升与“去内卷”：生产效率的提升可能减少“内卷”现象，并通过政策调整减轻劳动者的工作压力。</li>
<li>关于工作和财富再分配问题：如果AI真的让生产效率大幅提升，我们可以期待未来的福利制度更加完善，比如减少工作时间、增加带薪假期，甚至实现“无工作”状态也未必是幻想。</li>
</ul>
<h1 id="社会与政策层面"><a href="#社会与政策层面" class="headerlink" title="社会与政策层面"></a>社会与政策层面</h1><ul>
<li>加强教育培训：推动技能提升和再教育计划，使劳动者适应AI时代的工作需求。</li>
<li>优化产业结构：加速产业转型升级，为社会创造更多高附加值就业机会。</li>
<li>完善社会保障：建立健全失业保障制度，帮助因AI技术变革失业的劳动者渡过难关。</li>
<li>政策引导：通过政策规范AI技术的合理应用，避免过度自动化对就业的过度冲击。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>AI技术的快速发展是一把双刃剑，它既对传统就业模式提出了挑战，也为社会提供了提高效率、优化劳动分工的契机。从社会视角看，技术进步不可逆，但我们可以通过政策调整和个人适应来尽量减小负面影响。面对不可避免的变革，积极调整心态、提升能力，是每个人应对未来的重要策略。同时，历史告诉我们，每一次技术浪潮都会带来新的机遇，只要抓住变化的窗口期，未来依然充满希望。</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.xml-data.cn/KXYSH/html/93be89d5-c2ef-491d-9398-ebe61dcdc56b.htm">从工业革命史看技术变迁如何影响工人命运——《技术陷阱：自动化时代的资本、劳动力和权力》评介</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/12/30/20241230-web3-xiang-guan-zhi-shi-ji-lu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/30/20241230-web3-xiang-guan-zhi-shi-ji-lu/" itemprop="url">Web3相关知识记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-12-30T21:31:14+08:00">
                2024-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>以下内容都来源于书籍</p>
</blockquote>
</blockquote>
<p><img src="/2024/12/30/20241230-web3-xiang-guan-zhi-shi-ji-lu/Web3.png"></p>
<h2 id="Web进化史"><a href="#Web进化史" class="headerlink" title="Web进化史"></a>Web进化史</h2><ul>
<li><p>Web 1.0时代。Web 1.0时代的特点是重信息轻身份，多浏览少输出，因此也被人称为“只读网络”</p>
</li>
<li><p>相较于Web 1.0时代的内容创作者占少数，内容消费者占绝大多数的生态格局，Web 2.0更加以每个用户为中心，注重由用户生成内容(User Generated Content, UGC)，强调交互性。因此有人将Web 2.0称为“交互网络”。</p>
</li>
<li><p>O2O本质是连接，如果说Web 1.0开启了人与信息的连接，Web 2.0则增进了人与人的连接，电商模式拉近了人与商品的连接，O2O则连接了消费者与服务者。</p>
</li>
<li><p>Web 3.0：数据所有权革命</p>
</li>
<li><p>描述了Web 3.0应该具备的几个组成部分：</p>
<ul>
<li>一个加密的，去中心化的信息发布系统</li>
<li>一个基于身份的，但又是匿名的底层通信系统</li>
<li>一个用于取代中心节点信息验证功能的共识引擎</li>
<li>一个将上述三点结合在一起的用户交互系统</li>
</ul>
</li>
<li><p>目前更多的人在正式场合采用Web 3.0的表述方式，但是我们应该知道Web 3.0表述具有技术流派风格，而Web3表述则具有用户社区风格。</p>
</li>
<li><p>在Web 2.0系统中，个体只是网络中无数节点之一，必须依赖中心节点。中心节点制定规则，决定了其他节点的行为和生存。Web 3.0系统中，个体还是网络中无数节点之一，但每个节点都高度自治，且拥有自己的决策过程。</p>
</li>
</ul>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><ul>
<li><p>区块链是一种去中心化的计算机网络，也是实现Web 3.0世界的诸多技术基础中最重要的一个。</p>
</li>
<li><p>通证(tokens)是Web 3.0能够更公平、更有效率的一个关键因素。通证的概念范围非常广</p>
</li>
<li><p>加密资产是通证的其中一类，通证并不一定加密，但在Web 3.0的语境里，通常都是指带有去中心化特性（即无法被中心化机构通过在发放通证后部署的代码篡改）的加密通证。</p>
</li>
<li><p>加密资产并不一定是加密货币，比如NFT与数字藏品</p>
</li>
<li><p>Web 3.0的底层网络架构是基于区块链的，而区块链的第一个应用是比特币。</p>
</li>
<li><p>用以下五个指标来评估一个Web 3.0项目的去中心化程度：</p>
<ul>
<li>(1)项目钱包的透明性　一个项目的钱包越是透明，越能让大家了解这个项目的参与者构成。如果无法公开透明地了解一个项目的参与者构成，就无法进行更深度地评估。</li>
<li>(2)初始钱包的通证占比　初始钱包通常是项目方和核心投资者的地址，如果持有过多的通证，就说明他们对项目的影响力极大，这种项目是极其中心化的。</li>
<li>(3)相关生态的去中心化　在Web 3.0的错综复杂的生态中，大部分项目都并非独立存在而是依附或者嵌套于其他项目的。这时哪怕一个项目在开发层面是去中心化的，其价值和功能也会很大程度上被其他项目影响。而后者若是一个中心化的项目，那前者本质上也依旧是一个中心化的项目。</li>
<li>(4)项目方的影响力　一部分项目方本身并没持有大比例的通证，但由于他们的声音对项目的开发社群有着极大的影响力。这种情况下这也是一个偏中心化的项目，但中心化程度要比少数人持有大比例通证的项目要低。</li>
<li>(5)流动性　哪怕比特币作为一个完全独立的项目，并且没有和任何其他项目有嵌套关系，在早期流动性较低的阶段依旧可以轻易受到几个重要参与者深度影响，甚至有可能因为在链上的节点过少或者大部分节点被垄断，导致被篡改项目数据。也就是说，在那些流动性较差的项目上，被大算力主体篡改资产所有权的可能都要大于流动性高的项目。</li>
</ul>
</li>
<li><p>首次代币发行(Initial Coin Offering, ICO)，对应着首次公开募股(Initial Public Offering, IPO)应运而生。</p>
</li>
<li><p>以太坊的逻辑就是把现实中的合同去中心化形成智能合约。举个最简单的例子，你去自动售货机买可乐，你付钱后可乐出来，这就是一种智能合约。作为一个自动化的、程序化的机器，你付了钱，它给了货。</p>
</li>
<li><p>智能合约的本质就是通过代码程序的方式执行现实社会中的一些底层的制度或者合同。只要条件达到了要求，程序就会执行，解决了谁先出钱，谁先给货的问题。同时，通过区块链的技术，能够让整个交易的过程、结果、代码执行的情况在全网进行记录，且不可篡改。</p>
</li>
<li><p>以太坊(Ethereum)就是区块链版的操作系统，是一个为去中心化应用(DApps)而生的全球开源平台。</p>
</li>
<li><p>从2013年发布白皮书至今，以太坊在智能合约领域一直处于领先地位。它是当前全球最知名、应用最广泛的区块链智能合约底层平台。以太坊建立了一个可编程的、图灵完备的区块链，在这个区块链上，可以通过简单的程序实现各类加密资产的生成，也可以通过编写程序对以太坊上流通的资产状态进行精确控制。至今全球已经有数千种基于以太坊的去中心化应用程序和加密资产。</p>
</li>
<li><p>目前，以太坊上的项目已经划分出众多赛道，针对不同类型的项目大致可以分为：去中心化金融(DeFi)、去中心化交易所(DEX)、游戏、NFT、基础设施等。这些项目会在后文详细介绍。</p>
</li>
<li><p>区块链性能的不可能三角：即去中心化、安全性与可扩展性必须舍弃其一</p>
</li>
<li><p>Ripple和EOS舍弃了去中心化，IOTA和NANO舍弃了安全性，而比特币和以太坊舍弃了可扩展性。因此，以太坊就不得不消耗大量用于相互验证的算力和能源。</p>
</li>
<li><p>区块链可扩展性的提升大致可以分为以下三种：Layer 0（L0跨链交互），Layer 1（L1链上扩容，对主链本身进行改造），Layer 2（L2链下扩容，将主链上部分工作转移至主链以外）。</p>
</li>
<li><p>对于以太坊来说，直接对公链本身进行改造对已有的用户等利益相关方影响较大，因此以太坊社区主要关注的是L2，而对于链上扩容方案则采取缓慢过渡的模式。而对于后发的新公链来说，探索直接建立更高可扩展性的公链模型，成为首选。</p>
</li>
<li><p>L2，主要是指在主链之外建立一个二层的交易处理平台，负责具体交易的处理。主链只负责存取结算及验证链下上传信息的有效性。L2的扩容方式主要有状态通道(State Channels)、等离子体(Plasma)和卷叠(Rollup)三种方式。</p>
</li>
<li><p>随着区块链的发展，在目前，已经进入了一个多链并存的市场架构，并逐渐形成了以以太坊为核心，其他公链众星拱月的局面。从2021年4月开始，以太坊的跨链活动急剧增加。</p>
</li>
<li><p>跨链桥是一种链与链连接的桥梁工具，允许将加密资产从一条链转移到另一条链。两条链可以有不同的协议、规则和治理模型，而桥提供了一种相互通信和兼容的方式来安全地在双方进行互操作。用户可以使用跨链桥，快速轻松地实现加密资产交易。</p>
</li>
</ul>
<h2 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h2><ul>
<li><p>Web 3.0、区块链、元宇宙这三个概念经常交织出现，让人们产生了一定的疑惑。<br>这三个概念中，区块链是最早出现的。2008年区块链正式诞生，它的出现比现在公认出现于2005年的Web 2.0没有晚太多。区块链是为了解决中心化服务器存在的问题而诞生的。</p>
</li>
<li><p>Web 2.0这十多年的发展一直沿用的是将用户抓过来、养肥了、再割韭菜的AARRR（Acquisition获客，Activation激活，Retention留存，Referral转推荐，Revenue变现）互联网平台运营模式。在这种模式下，用户就像是动物一样，从始至终都是以S-R（Stimulus刺激，React反应）的行为模式被对待。用户是平台的资产，而不是平台的主人。因此，Web 2.0的用户被称为流量。</p>
</li>
<li><p>区块链的到来为Web 2.0带来了新的生机，将Web 2.0升级成为Web 3.0。<br>对Web 2.0时代的企业而言，IPO是最终归宿，在IPO那荣光时刻来临之际，企业必须已经达到一个非常大的量级，成为行业龙头。所谓盈亏同源，Web 2.0的企业盈利与用户无关，IPO或中途并购、退出都是VC的战场，亏损当然也与用户无关。</p>
</li>
<li><p>Web 2.0企业的模式是管理团队做，用户用。Web 3.0时代的企业替代物——DAO的所有者是社区，社区成员的每一个人都是DAO的既得利益者。由于Web 3.0的IEO(Initial Exchange Offering)门槛比IPO低，不需要中心化审核，IEO在真正意义上完成了IPO最初想要达成的任务——获取更大的流动性。之所以叫作Initial Exchange Offering而非Initial Public Offering，是因为Web 3.0社区的通证在没有上交易所之前，就是公开的、去中心化的、通常也有广泛的持有人基础，而且也是可以通过区块链交易的。</p>
</li>
<li><p>Web 3.0概念的进化线索是从用户与互联网之间的关系去归纳的，从Web 1.0单向接受互联网，到Web 2.0可以与互联网交互读写，再到Web 3.0可以拥有互联网。</p>
</li>
<li><p>真正的元宇宙远不只是体验的升级。元宇宙是一个宏大的概念，要构建这样一个数字世界，只提升体验是不够的。如果只是将VR&#x2F;AR设备装在头上，这样的元宇宙不过是个大型游戏，还远不能成为“宇宙”。从深层次出发，用“有关联”来描述Web 3.0和元宇宙之间的关系，显然还不够，它们之间是相辅相成的。从技术角度来看，元宇宙是前端、展示层，Web 3.0是中后端、技术层，只有技术条件满足Web 3.0所需的去中心化的数据库，即分布式数据库，以及配套的加密技术和协议，才有可能实现元宇宙这样宏大的设想。</p>
</li>
<li><p>NFT——NFT可以将现实世界与元宇宙的每一个物品一一对应。</p>
</li>
<li><p>DAO——元宇宙既是一场技术革命，也是一场社会革命，而DAO作为社区的操作系统，将是元宇宙的关键。DAO提供了一个技术层，提供个人之间的全球性和去中心化的协作，而无须信任第三方或少数代表。</p>
</li>
<li><p>之所以字节跳动等大厂和互联网知名人士都认为元宇宙是一个超前的概念，主要是因为其本身就建立在多重计算机技术与网络服务之上，是一套极其复杂的生态技术系统，在短时间内并不可能实现，而目前最接近元宇宙的则是Web 3.0。</p>
</li>
<li><p>区块链是支撑Web 3.0发展的底层技术，而Web 3.0的去中心化和确权特性是元宇宙的基础建设。Web 3.0的实现必然早于真正元宇宙的实现，这是元宇宙之所以能成为宇宙的前提条件。</p>
</li>
</ul>
<h2 id="DApps"><a href="#DApps" class="headerlink" title="DApps"></a>DApps</h2><ul>
<li><p>DApps是建立在区块链上的应用，全称Decentralized Applications。区块链有五层架构（也有一种划分方式，将协议层从应用层中独立出来，分为六层架构），DApps属于其中的最上层——应用层</p>
</li>
<li><p>Web 3.0是构建在区块链上的数字世界，而DApps就是用来构建这个世界中我们看得见摸得着的那部分的“砖瓦”。</p>
</li>
<li><p>要成为去中心化应用，需要满足以下标准：</p>
<ul>
<li>(1)必须完全开源，自动运行，且没有一个实体控制着它的大多数通证。它的数据和记录必须加密后存储在一个公链上。</li>
<li>(2)必须依据一个标准化算法或一系列准则来生产通证，并且应该在开始运营的时候就将它的部分或全部通证发放给使用者。这个应用必须依赖该通证来运行，而且使用者所作出的贡献应该以该通证作为奖励。</li>
<li>(3)可以因时制宜地更改它的运行法则，但是这些改变应该被大多数用户所认可，而不是将最终解释权归于某个实体。</li>
</ul>
</li>
<li><p>区块链的基础架构可以分为五层，包括硬件层，数据层、网络层、共识层、应用层（有些说法还会从应用层中拆分出协议层）。    </p>
</li>
<li><p>DApps大多数属于应用层。作为一类相对特殊的DApps，基础设施类DApps的作用是为DApps世界与其他四层的交互建立连接。因此基础设施类的DApps通常以“协议”的形式存在</p>
</li>
<li><p>◆ 区块链是由一个点对点(Peer-to-Peer)的计算机网络共同进行运算，验证和记录交易的。硬件层(Hardware Layer)就是这些计算机。<br>● 数据层(Data Layer)我们可以理解成数据库，主要可实现两大功能：数据存储、账户和交易的安全。<br>● 网络层(Network Layer)实现三大功能：节点间组网，数据传播，数据验证。<br>● 共识层(Consensus Layer)主要通过共识算法和共识机制实现一个重要功能：节点间的计算达成共识。由于区块链是分布式网络，每个节点均可计算，所以需要共识层做个统筹，让所有节点针对区块数据的有效性达成共识。<br>● 应用层(Application Layer)是最上面一层，有些说法还会在其中将协议层(Protocol Layer)单独分为一层。原因是DApps有“胖协议，瘦应用”的说法。这是相对于Web 2.0 Apps的“瘦协议，胖应用”提出的。所谓“胖协议”，举个例子，在Web 2.0中，数据的安全依靠数据安全公司、杀毒软件、防火墙等应用实现，协议层只负责数据传输；而在Web 3.0中，传输协议本身就保障了数据安全，因此各种数据安全应用、杀毒软件、防火墙应用没有了独立存在的空间。智能合约就是这样的一种协议。</p>
</li>
<li><p>交易所<br>针对加密资产的交易所既有中心化的也有去中心化的。中心化交易所目前依然占据着绝对的市场地位，因为他们发展较早，对从Web 2.0过渡进入Web 3.0的用户而言使用体验也比较好。在交易所中交易的加密资产主要为加密货币和NFT。去中心化加密货币交易所我们放在第六章详细介绍，NFT交易所我们放在第七章详细介绍。</p>
</li>
</ul>
<h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><ul>
<li><p>DAO是一种共同管理加密资产以达成共同目标的组织方式。我们可以将DAO视作由成员集体所有和共同管理的Web 3.0版本的新型企业。</p>
</li>
<li><p>DAO的实现基于智能合约。因此，在某些语境下，DAO也可以指代支撑DAO运行的智能合约本身。合约界定了组织的规则，管理组织的资金。以太坊是第一个使人们能够建立DAO的区块链。大多数DAO都在以太坊上，但也有其他网络能建立DAO，如Polkadot、Cosmos、EOS和Cardano。</p>
</li>
<li><p>DID和传统ID的差异在于，DID基于区块链，而链上数据是公开透明可查并难以篡改的。因此当你在Web 3.0亮出DID，人们并不需要借助某个权威机构，就可以核验这个DID的真伪以及能否准入。</p>
</li>
<li><p>Uniswap是一个以协议形式存在的去中心化交易所，而它的治理是以DAO的形式运作的。</p>
</li>
<li><p>教你建立一个DAO<br>了解了这么多关于DAO的概念，是不是也想自己动动手？参与或自己建立一个DAO是亲身体验Web 3.0的门槛最低的方式。建立一个DAO几乎和建立一个微信群一样简单。这一节笔者将借助一个名为Aragon的工具，手把手教读者建立一个DAO。<br>第一步：打开<a target="_blank" rel="noopener" href="https://aragon.org/">https://aragon.org/</a></p>
</li>
</ul>
<h2 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h2><ul>
<li>DeFi，全称Decentralized Finance，去中心化金融。</li>
<li>去中心化交易所是一类基于区块链的交易所，它不需要将用户资金和个人数据转入交易所内，而只是作为一种基础设施来匹配希望买卖加密资产的买家和卖家。在匹配引擎的帮助下，这种交易直接发生在参与者之间。<br>中心化交易所(CEX)，是集传统交易所、券商和投资银行的功能为一体的平台，以币安、Coinbase、FTX交易所为代表，CEX聚集了庞大的用户量和交易量，也带来了足够的交易深度，提供了充分的资产流动性。</li>
<li>交易所的核心环节一般包括充提、下单、订单撮合、资金结算和提现。CEX均由交易平台本身撮合完成；DEX则是把上述所有环节都置于链上，由智能合约执行全部操作，这样用户的交易过程就无须任何第三方。</li>
</ul>
<h2 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h2><ul>
<li><p>现实世界与数字世界的差异在于，现实世界不存在完全相同的两个物品，即使是同一个工厂同一批次的商品也会有可能出现不同。而数字世界则可以完全复制同一物品。</p>
</li>
<li><p>我们如果要实现元宇宙的最终目标，就需要把现实世界物品的这个特点也搬到数字世界里。区块链能帮我们做到这一点，这就是非同质化通证(Non-Fungible Token, NFT)。</p>
</li>
<li><p>同质化通证(Fungible Token, FT)和非同质化通证之间的区别</p>
</li>
<li><p>BTC、ETH等加密资产多数是同质化通证。顾名思义，同质化通证是可以与同一事物的另一个单位互换的。例如，一单位BTC等于另一单位BTC，就像一张100美元的价值等于另一张100美元。美元可以进行简单互换，即使序号不同也不影响，对持有者来说没有区别。同质化通证是一种能够互换、具有统一性的通证。而且由于它以数字的形式存在，还可以拆分成近乎无穷小的许多份，每一份也都可以代表相应的价值。<br>与同质化物品不同，非同质化物品或通证彼此之间是不能互换的，它们具有独特的属性。即使看起来相似，但彼此之间也有根本的不同。<br>非同质化通证包含了记录在其智能合约中的识别信息。这些信息使每个通证具有唯一性，因此不能被另一种通证直接替代，没有两个NFT是相同的。此外，绝大多数非同质化通证也不可分割。</p>
</li>
<li><p>每个NFT都有区别于其他NFT的数字哈希值。因此，NFT可以作为出处证明。就像现实世界中的证书一样，它不仅能证明原创艺术品和游戏通证等知识产权的所有权和真实性，还能代表股票、房地产等实际资产。现实世界中，真实资产拥有所有权证书。同样，在区块链世界中，NFT也可以作为所有权记录和真实性证明。在艺术品领域，NFT也被称为数字藏品。</p>
</li>
<li><p>NFT不仅存在于数字世界，它们也可以代表任何类型的物理资产。NFT可以与物理世界中存在的任何东西相连接，形成一种“数字孪生”，并在数字世界的市场上实现实物资产的所有权交易。</p>
</li>
<li><p>NFT目前最为人推崇的应用场景是创作者经济。</p>
</li>
<li><p>NFT的3种存储方式是区块链存储、IPFS分布式存储节点存储、中心化服务器存储，安全性依次降低。安全性越高则越符合不可篡改的特性，也越有独特性。</p>
</li>
<li><p>万物皆可NFT。这里的NFT指的不仅是艺术品。这个理念不是说万物都可以成为艺术收藏品，而是有着更远大的目标。我们可以将世间万物以数字孪生的方式在数字世界重建一遍。所有的一切都可能以NFT的形式存在，也可以以NFT的产生方式创造出来。</p>
</li>
</ul>
<h2 id="通证经济学"><a href="#通证经济学" class="headerlink" title="通证经济学"></a>通证经济学</h2><ul>
<li>通证是Web 3.0的核心，身份是通证，NFT是通证，交易媒介也是通证。通证是激励用户参与的奖励，是驱动Web 3.0运行的燃油，也是连接Web 3.0世界各个岛屿的桥梁。通证的发放、分配与流通使用机制是一个Web 3.0项目能否成功的关键因素。</li>
<li>通证经济（Token Economics，也称Tokenomics）。就像一个普通的经济体系，通证经济逃不过供给和需求的掌控，供不应求则价格上涨，供过于求则价格下跌。</li>
</ul>
<h2 id="Web-3-0现存的问题"><a href="#Web-3-0现存的问题" class="headerlink" title="Web 3.0现存的问题"></a>Web 3.0现存的问题</h2><ul>
<li><p>在失去中心化监管的环境下，加密与匿名也暴露了许多问题。通过加密匿名算法获取的财富，也会被加密匿名地剥夺</p>
</li>
<li><p>人类的共识是一个很有意思的东西，它可以如磐石般固执，也可以如鲁珀特之泪的尾巴一样脆弱。当形成共识的那个关键点破灭，建立在共识之上的摩天大楼，就会瞬间崩塌。</p>
</li>
<li><p>创作者经济还是炒作者经济</p>
</li>
<li><p>Web 3.0的底层是去中心化网络，数据存储和运算是由各个分散的节点完成。那么很自然的，不考虑中心化作业情况下的网络其他参与者在不能达成一致而导致扯皮的情况，对于同样一件事情的处理，协同作业的速度就是比中心化作业要慢、效率更低、消耗能源更多。</p>
</li>
<li><p>比特币交易为了替换掉中心化权威而采用了耗能极大的工作证明，让人们消费了能源计算出一个不产生任何价值的问题，这是对权威不信任的代价。具体而言，每一笔比特币交易要消耗2188千瓦时的电量，而Visa是每10万笔交易消耗148千瓦时电量，这代价就是效率下降150万倍。以太坊的耗电量是比特币的1&#x2F;10，相对Visa也有15万倍的差距。Web 3.0的底层架构要想达到Web 2.0的用户体验，只有两条路可以走，其一是降低运算的耗能，其二是调整共识机制。</p>
</li>
<li><p>互联网不是法外之地，Web 3.0也不是。网络无国界，但法律是有国界的。目前各国针对Web 3.0的监管法规还在逐步出台中，而Web 3.0未来的发展必然是需要在各国的法律框架下运行的。</p>
</li>
<li><p>在Web 2.0时代，监管主体是服务提供商，监管属地是服务器所在地。而在Web 3.0时代，服务代码存放在网络的各个服务器上，也没有一个具体的服务提供商。Web 3.0的互联网活动趋于分布式，这给监管主体和监管属地的确定带来了一定的挑战。<br>另外，由于Web 3.0应用和钱包的匿名性和去中心化，一旦资产丢失，将无法找回。</p>
</li>
<li><p>Web 3.0项目的代码一经上线，即无法改动。这就使得在上线前对于代码的审计显得尤为重要。但凡是代码，或多或少都是有漏洞的。上线无法改动的代码犹如一辆在公路上狂奔而没有方向盘的汽车，行驶越久危险系数越高。</p>
</li>
<li><p>政府监管和主导从来都是一柄双刃剑，会对技术发展和应用创新造成一定阻碍，但从稳定社会经济、维护金融秩序角度看，合规是一个新兴市场的生存基础。</p>
</li>
<li><p>Web 3.0已经被赋予了太多神秘色彩，人们对它寄予了太多不切实际的希望。而只有当我们意识到，区块链发明者的“去中心化”理想主义，注定会被纷至沓来的投机者瓦解得支离破碎的时候，我们才可以平心静气地接受一个基于现实主义的Web 3.0的未来——在一个由核心节点掌握的“中心化”区块链网络上，用“去中心化”的分布式账本和加密散列，保障不同的经济主体之间的数字产权和商业价值不受侵犯，并形成它们互相的契约关系——这也理应是我国的政府、企业和社会组织在Web 3.0浪潮中扮演的角色。！！！！</p>
</li>
<li><p>腾讯、阿里巴巴（蚂蚁集团）、百度和京东等都构建了自己的联盟链，从内容版权、股权、保险、债券、供应链金融、税务、司法、商品防伪溯源、物流运输和生态保护等方面提供了“上链”服务。BSN与长安链等国有企业、智库和政府机构成立的联盟链也陆续建立，除了用于商业和政务场景，还致力解决区块链底层公用基础设施和知识产权的自主可控问题。</p>
</li>
</ul>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul>
<li>DApps（Decentralized Applications，去中心化应用程序）</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>《Web3.0漫游指南》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/">&gt;</a>
  </nav>





          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">168</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">197</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
