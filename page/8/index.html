<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="为啥不吃三文鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="为啥不吃三文鱼">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>拉巴力的纸皮箱</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/23/20220223-li-jie-zhuang-tai-ji-yuan-li-ji-shi-jian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/23/20220223-li-jie-zhuang-tai-ji-yuan-li-ji-shi-jian/" itemprop="url">理解状态机原理及实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-23T13:42:47+08:00">
                2022-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>有限状态机FSM</p>
</li>
<li><p>描述事物的有限状态机模型的元素由以下组成：</p>
<ol>
<li>状态(State)：事物的状态，包括初始状态和所有事件触发后的状态</li>
<li>事件(Event)：触发状态变化或者保持原状态的事件</li>
<li>行为或转换(Action&#x2F;Transition)：执行状态转换的过程</li>
<li>检测器(Guard)：检测某种状态要转换成另一种状态的条件是否满足</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/37281543f506">https://www.jianshu.com/p/37281543f506</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/46347732">深入浅出理解有限状态机</a></p>
</li>
<li><p>状态机的要素</p>
</li>
<li><p>状态机可归纳为4个要素，即现态、条件、动作、次态。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：<br>  1. 现态：是指当前所处的状态。<br>  2. 条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。<br>  3. 动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。<br>  4. 次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li><p>定义状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ProcessState</span> &#123;</span><br><span class="line"></span><br><span class="line">    INIT(<span class="number">0</span>, <span class="string">&quot;未开始&quot;</span>),</span><br><span class="line">    READY_ONE_SIDE(<span class="number">1</span>, <span class="string">&quot;一方准备完成&quot;</span>),</span><br><span class="line">    READY_ALL(<span class="number">2</span>, <span class="string">&quot;双方准备完成&quot;</span>),</span><br><span class="line">    CHAT(<span class="number">3</span>, <span class="string">&quot;发言完成&quot;</span>),</span><br><span class="line">    END(<span class="number">4</span>, <span class="string">&quot;结束&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    ProcessState(<span class="type">int</span> val, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ProcessEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    READY_ONE_SIDE(<span class="number">1</span>, <span class="string">&quot;一方准备&quot;</span>),</span><br><span class="line">		READY_ALL(<span class="number">2</span>, <span class="string">&quot;另一方准备&quot;</span>),</span><br><span class="line">		CHAT(<span class="number">3</span>, <span class="string">&quot;发言&quot;</span>),</span><br><span class="line">		FORBID_ALL(<span class="number">4</span>, <span class="string">&quot;全员禁言&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    ProcessEvent(Integer code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义状态机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessEventConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProcessEvent event;</span><br><span class="line">    <span class="keyword">private</span> ProcessState fromState;</span><br><span class="line">    <span class="keyword">private</span> ProcessState toState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">desc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fromState.getDesc() + <span class="string">&quot;_&quot;</span> + event.getDesc() + <span class="string">&quot;_&quot;</span> + toState.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;ProcessEventConfig&gt; configList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">configList.add(<span class="keyword">new</span> <span class="title class_">ProcessEventConfig</span>(ProcessEvent.READY_ONE_SIDE, ProcessState.INIT, ProcessState.READY_ONE_SIDE));</span><br><span class="line">configList.add(<span class="keyword">new</span> <span class="title class_">ProcessEventConfig</span>(ProcessEvent.READY_ALL, ProcessState.READY_ONE_SIDE, ProcessState.READY_ALL));</span><br><span class="line">configList.add(<span class="keyword">new</span> <span class="title class_">ProcessEventConfig</span>(ProcessEvent.CHAT, ProcessState.READY_ALL, ProcessState.CHAT));</span><br><span class="line">configList.add(<span class="keyword">new</span> <span class="title class_">ProcessEventConfig</span>(ProcessEvent.FORBID_ALL, ProcessState.CHAT, ProcessState.END));</span><br><span class="line"></span><br><span class="line">Map&lt;ProcessEvent, ProcessEventConfig&gt; eventResultStateConfigMap = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(ProcessEvent.class);</span><br><span class="line"></span><br><span class="line">configList.forEach(eventConfig -&gt; eventResultStateConfigMap.put(eventConfig.getEvent(), eventConfig));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>触发状态变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">fire</span><span class="params">(ProcessEvent event, Process process)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ProcessEventConfig</span> <span class="variable">config</span> <span class="operator">=</span> Optional.ofNullable(eventResultStateConfigMap.get(event)).orElseThrow(() -&gt; ExceptionCodeEnum.AGRS_INVALID.newException(<span class="string">&quot;不存在该事件&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process.getStatus() != config.getFromState().getVal()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process.setRemark(config.desc());</span><br><span class="line">        process.setStatus(config.getToState().getVal());</span><br><span class="line"></span><br><span class="line">				<span class="comment">//DB改变状态</span></span><br><span class="line">				<span class="comment">/*update table set status=$&#123;status&#125; WHERE id=&#123;id&#125; AND status=$&#123;beforeStatus&#125;*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">suc</span> <span class="operator">=</span> processManager.updateStatus(process, config.getFromState().getVal());</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">               <span class="comment">//变更成功，业务逻辑    </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/20/20220220-nba-xuan-xiu-chou-qian-ju-ti-shi-ru-he-cao-zuo-de/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/20/20220220-nba-xuan-xiu-chou-qian-ju-ti-shi-ru-he-cao-zuo-de/" itemprop="url">nba选秀抽签具体是如何操作的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-20T20:26:21+08:00">
                2022-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52895544">nba选秀抽签具体是如何操作的？</a></p>
<ul>
<li>14个乒乓球分别贴上1-14数字，随机滚出4个，加起来是1001可能，其中11、12、13、14这个组合不算，剩下1000种可能。</li>
</ul>
<p><img src="/2022/02/20/20220220-nba-xuan-xiu-chou-qian-ju-ti-shi-ru-he-cao-zuo-de/nba%E9%80%89%E7%A7%80%E6%8A%BD%E7%AD%BE.jpg"></p>
<ul>
<li>闲来无事，使用Go粗暴模拟了一下</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">https://www.zhihu.com/question/52895544</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">14</span></span><br><span class="line">	m := <span class="number">4</span></span><br><span class="line">	nn := <span class="number">1</span></span><br><span class="line">	mm := <span class="number">1</span></span><br><span class="line">	nm := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		nn = nn * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		mm = mm * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= (n - m); i++ &#123;</span><br><span class="line">		nm = nm * i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	all_result := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">1000</span>)</span><br><span class="line">	all_result_map := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt;= <span class="number">12</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> k := j + <span class="number">1</span>; k &lt;= <span class="number">13</span>; k++ &#123;</span><br><span class="line">				<span class="keyword">for</span> l := k + <span class="number">1</span>; l &lt;= <span class="number">14</span>; l++ &#123;</span><br><span class="line">					<span class="comment">//fmt.Printf(&quot;%d -&gt; %d -&gt; %d -&gt; %d\n&quot;, i, j, k, l)</span></span><br><span class="line">					<span class="keyword">if</span> i == <span class="number">11</span> &amp;&amp; j == <span class="number">12</span> &amp;&amp; k == <span class="number">13</span> &amp;&amp; l == <span class="number">14</span> &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					all_result[count] = fmt.Sprintf(<span class="string">&quot;%d-%d-%d-%d&quot;</span>, i, j, k, l)</span><br><span class="line">					count++</span><br><span class="line">					all_result_map[fmt.Sprintf(<span class="string">&quot;%d-%d-%d-%d&quot;</span>, i, j, k, l)] = count</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	weight_arr := [<span class="number">14</span>]<span class="type">int</span>&#123;<span class="number">250</span>, <span class="number">199</span>, <span class="number">156</span>, <span class="number">119</span>, <span class="number">88</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>&#125;</span><br><span class="line">	all_weight := <span class="number">0</span></span><br><span class="line">	source_map := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> num, weight := <span class="keyword">range</span> weight_arr &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; weight; i++ &#123;</span><br><span class="line">			source_map[i+<span class="number">1</span>+all_weight] = num + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		all_weight = all_weight + weight</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	模拟前三顺位</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	all_hit_result := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	all_hit_result_second_round := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	all_hit_result_third_round := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	r := rand.New(rand.NewSource(time.Now().Unix()))</span><br><span class="line">	<span class="keyword">for</span> xx := <span class="number">0</span>; xx &lt; <span class="number">1000000</span>; xx++ &#123;</span><br><span class="line"></span><br><span class="line">		hit_map := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> round := <span class="number">0</span>; round &lt; <span class="number">3</span>; round++ &#123;</span><br><span class="line">			all_ball := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">			chosen_ball := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">				hit := r.Intn(<span class="number">14</span> - i)</span><br><span class="line">				chosen_ball[i] = all_ball[hit]</span><br><span class="line">				index := hit</span><br><span class="line">				all_ball = <span class="built_in">append</span>(all_ball[:index], all_ball[index+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			sort.Ints(chosen_ball)</span><br><span class="line">			result := fmt.Sprintf(<span class="string">&quot;%d-%d-%d-%d&quot;</span>, chosen_ball[<span class="number">0</span>], chosen_ball[<span class="number">1</span>], chosen_ball[<span class="number">2</span>], chosen_ball[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> result == <span class="string">&quot;11-12-13-14&quot;</span> &#123;</span><br><span class="line">				round--</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			result_rank := source_map[all_result_map[result]]</span><br><span class="line"></span><br><span class="line">			value := hit_map[result_rank]</span><br><span class="line">			<span class="keyword">if</span> value == <span class="number">1</span> &#123;</span><br><span class="line">				round--</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> round == <span class="number">0</span> &#123;</span><br><span class="line">				all_hit_result[result_rank<span class="number">-1</span>]++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> round == <span class="number">1</span> &#123;</span><br><span class="line">				all_hit_result_second_round[result_rank<span class="number">-1</span>]++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> round == <span class="number">2</span> &#123;</span><br><span class="line">				all_hit_result_third_round[result_rank<span class="number">-1</span>]++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			hit_map[result_rank] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;第一轮&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, resut_hit := <span class="keyword">range</span> all_hit_result &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d -&gt; %d\n&quot;</span>, i+<span class="number">1</span>, resut_hit)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;第二轮&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, resut_hit := <span class="keyword">range</span> all_hit_result_second_round &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d -&gt; %d\n&quot;</span>, i+<span class="number">1</span>, resut_hit)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;第三轮&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, resut_hit := <span class="keyword">range</span> all_hit_result_third_round &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d -&gt; %d\n&quot;</span>, i+<span class="number">1</span>, resut_hit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		模拟100万次</span></span><br><span class="line"><span class="comment">		第一轮</span></span><br><span class="line"><span class="comment">	1 -&gt; 249512</span></span><br><span class="line"><span class="comment">	2 -&gt; 198836</span></span><br><span class="line"><span class="comment">	3 -&gt; 155714</span></span><br><span class="line"><span class="comment">	4 -&gt; 118849</span></span><br><span class="line"><span class="comment">	5 -&gt; 88395</span></span><br><span class="line"><span class="comment">	6 -&gt; 63352</span></span><br><span class="line"><span class="comment">	7 -&gt; 43285</span></span><br><span class="line"><span class="comment">	8 -&gt; 28016</span></span><br><span class="line"><span class="comment">	9 -&gt; 16892</span></span><br><span class="line"><span class="comment">	10 -&gt; 11093</span></span><br><span class="line"><span class="comment">	11 -&gt; 7894</span></span><br><span class="line"><span class="comment">	12 -&gt; 7004</span></span><br><span class="line"><span class="comment">	13 -&gt; 6100</span></span><br><span class="line"><span class="comment">	14 -&gt; 5058</span></span><br><span class="line"><span class="comment">	第二轮</span></span><br><span class="line"><span class="comment">	1 -&gt; 215647</span></span><br><span class="line"><span class="comment">	2 -&gt; 188267</span></span><br><span class="line"><span class="comment">	3 -&gt; 157704</span></span><br><span class="line"><span class="comment">	4 -&gt; 125474</span></span><br><span class="line"><span class="comment">	5 -&gt; 96543</span></span><br><span class="line"><span class="comment">	6 -&gt; 71033</span></span><br><span class="line"><span class="comment">	7 -&gt; 49195</span></span><br><span class="line"><span class="comment">	8 -&gt; 32360</span></span><br><span class="line"><span class="comment">	9 -&gt; 19803</span></span><br><span class="line"><span class="comment">	10 -&gt; 13185</span></span><br><span class="line"><span class="comment">	11 -&gt; 9521</span></span><br><span class="line"><span class="comment">	12 -&gt; 8252</span></span><br><span class="line"><span class="comment">	13 -&gt; 7031</span></span><br><span class="line"><span class="comment">	14 -&gt; 5985</span></span><br><span class="line"><span class="comment">	第三轮</span></span><br><span class="line"><span class="comment">	1 -&gt; 177455</span></span><br><span class="line"><span class="comment">	2 -&gt; 171603</span></span><br><span class="line"><span class="comment">	3 -&gt; 155736</span></span><br><span class="line"><span class="comment">	4 -&gt; 133323</span></span><br><span class="line"><span class="comment">	5 -&gt; 106458</span></span><br><span class="line"><span class="comment">	6 -&gt; 81193</span></span><br><span class="line"><span class="comment">	7 -&gt; 58185</span></span><br><span class="line"><span class="comment">	8 -&gt; 38863</span></span><br><span class="line"><span class="comment">	9 -&gt; 24146</span></span><br><span class="line"><span class="comment">	10 -&gt; 15550</span></span><br><span class="line"><span class="comment">	11 -&gt; 11508</span></span><br><span class="line"><span class="comment">	12 -&gt; 10064</span></span><br><span class="line"><span class="comment">	13 -&gt; 8634</span></span><br><span class="line"><span class="comment">	14 -&gt; 7282</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/08/20220208-java11-ji-chu-yuan-li-he-shi-jian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/08/20220208-java11-ji-chu-yuan-li-he-shi-jian/" itemprop="url">Java11基础原理和实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-08T00:08:24+08:00">
                2022-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、为什么选择java11"><a href="#一、为什么选择java11" class="headerlink" title="一、为什么选择java11"></a>一、为什么选择java11</h1><p>Java 11 是 Java 8 之后的首个 LTS 版本（Long-term support 长期支持版本），所以有不少开发者表示会选择升级至 Java 11。</p>
<p><img src="/2022/02/08/20220208-java11-ji-chu-yuan-li-he-shi-jian/java11.png"></p>
<p>1、目前相对来说，Java 8 太旧，Java 17 太新，Java11 刚刚好；<br>2、支持以类路径方式运行，适合过渡阶段升级；<br>3、其他原因（下文会说明）</p>
<h1 id="二、模块系统"><a href="#二、模块系统" class="headerlink" title="二、模块系统"></a>二、模块系统</h1><p>模块系统是Java 9的旗舰功能，使用java9，有必要了解一下。</p>
<h2 id="java9之前存在哪些痛点"><a href="#java9之前存在哪些痛点" class="headerlink" title="java9之前存在哪些痛点"></a>java9之前存在哪些痛点</h2><h3 id="1、没有封装"><a href="#1、没有封装" class="headerlink" title="1、没有封装"></a>1、没有封装</h3><p>类一旦公开，意味着没有封装。</p>
<p>如果将一个类设置为protected，那么就可以防止其他类访问该类，除非这些类与该类位于相同的包中。但这样做会产生一个有趣的问题：如果想从组件的另一个包中访问该类，同时仍然防止其他类使用该类，那么应该怎么做呢？事实是无法做到。</p>
<p>让类公开，意味着对系统中的所有类型都是公开的，也就意味着没有封装。</p>
<p>Java在过去经历过相当多的安全漏洞。这些漏洞都有一个共同的特点：不知何故，攻击者可以绕过JVM的安全沙盒并访问JDK中的敏感类。从安全的角度来看，在JDK中对危险的内部类进行强封装是一个很大的改进。同时，减少运行时中可用类的数量会降低攻击面。在应用程序运行时中保留大量暂时不使用的类是一种不恰当的做法。而通过使用模块化JDK，可以确定应用程序所需的模块。</p>
<h3 id="2、编译时无法感知依赖缺失或类重复"><a href="#2、编译时无法感知依赖缺失或类重复" class="headerlink" title="2、编译时无法感知依赖缺失或类重复"></a>2、编译时无法感知依赖缺失或类重复</h3><p>Java确实使用了显式的import语句。但不幸的是，从严格意义上讲，这些导入是编译时结构，一旦将代码打包到JAR中，就无法确定哪些JAR包含当前JAR运行所需的类型。</p>
<p>在Java 9出现之前，JAR文件似乎是最接近模块的，它们拥有名称、对相关代码进行了分组并且提供了定义良好的公共接口。</p>
<p>（1）依赖缺失<br>所有类按照-classpath参数定义的顺序加载类。由于类会延迟加载，JVM无法在应用程序启动时有效地验证类路径的完整性，即无法预先知道类路径是否是完整的，或者是否应该添加另一个JAR。</p>
<p>（2）类重复<br>当类路径上有重复类时，则会出现更为隐蔽的问题。出现相同库的两个版本（如Guava 19和Guava 18）是非常常见的，这两个库JAR以一种未定义的顺序压缩到类路径中。库类的任一版本都可能会被首先加载。此外，有些类还可能会使用来自（可能不兼容的）其他版本的类。此时就会导致运行时异常。</p>
<h2 id="关于类重复"><a href="#关于类重复" class="headerlink" title="关于类重复"></a>关于类重复</h2><p>目前存在以下方法缓解或解决</p>
<h3 id="1、通过插件检查类重复"><a href="#1、通过插件检查类重复" class="headerlink" title="1、通过插件检查类重复"></a>1、通过插件检查类重复</h3><p>在编译时，检测类是否重复，比如使用插件 maven enforcer plugin，但本质上是通过解压全部jar包，检查所有文件是否存在重复类来判断的，效率可想而知。</p>
<h3 id="2、通过构建工具保证只存在一个版本的jar包"><a href="#2、通过构建工具保证只存在一个版本的jar包" class="headerlink" title="2、通过构建工具保证只存在一个版本的jar包"></a>2、通过构建工具保证只存在一个版本的jar包</h3><p>构建工具冲突失败策略设置如gradle中</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span>.all &#123;</span><br><span class="line">    resolutionStrategy &#123;  failOnVersionConflict() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设置仅仅是针对jar包冲突，不能保证不同名的jar包是否存在相同的类。</p>
<p>处理jar包冲突有两种策略：</p>
<p>1）强制指定版本：版本冲突太多，指定版本的情况，后续有新的版本间接依赖也无法直接发现。<br>2）取最高版本：同样有可能引起高版本导致不兼容的问题。</p>
<p>要彻底解决，只有项目依赖完全模块化。</p>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>Maven、Gradle等构建工具，在运行时没有任何作用。Maven构建了想要运行的工件，但是最后仍然需要配置Java运行时，以便运行正确的模块路径和类路径。虽然手动配置模块路径比类路径要容易得多，但它仍然是重复的工作，因为相关信息已经在pom.xml文件中了。</p>
<h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><p>模块化 可以 在编译时和运行时获得所有这些信息所带来的优势。这可以防止对来自其他非引用模块的代码的意外依赖。通过检查（传递）依赖关系，工具链可以知道运行模块需要哪些附加模块并进行优化。</p>
<p>Java平台模块系统带来了如下最重要的好处：</p>
<p>1．可靠的配置在编译或运行代码之前，模块系统会检查给定的模块组合是否满足所有依赖关系，从而导致更少的运行时错误。<br>2．强封装型模块显式地选择了向其他模块公开的内容，从而防止对内部实现细节的意外依赖。<br>3．可扩展开发显式边界能够让开发团队并行工作，同时可创建可维护的代码库。只有显式导出的公共类型是共享的，这创建了由模块系统自动执行的边界。<br>4．安全性在JVM的最深层次上执行强封装，从而减少Java运行时的攻击面，同时无法获得对敏感内部类的反射访问。<br>5．优化由于模块系统知道哪些模块是在一起的，包括平台模块，因此在JVM启动期间不需要考虑其他代码。同时，其也为创建模块分发的最小配置提供了可能性。此外，还可以在一组模块上应用整个程序的优化。</p>
<p>在模块出现之前，这样做是非常困难的，因为没有可用的显式依赖信息，一个类可以引用类路径中任何其他类。</p>
<p>此外还有：<br>（1）JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性。<br>在JDK9之前，JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石。这不仅是违反了单一职责原则，同样程序在编译的时候会将很多无用的类也一并打包，造成臃肿。在JDK9中，整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。<br>（2）经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作</p>
<h2 id="模块系统的基础"><a href="#模块系统的基础" class="headerlink" title="模块系统的基础"></a>模块系统的基础</h2><p>本质上就是一个jar包切成多模块（更细的jar包）来引用</p>
<h3 id="1、module-info-java描述文件-关键字说明"><a href="#1、module-info-java描述文件-关键字说明" class="headerlink" title="1、module-info.java描述文件 关键字说明"></a>1、module-info.java描述文件 关键字说明</h3><p>requires代表依赖的模块，只有依赖的模块存在才能通过编译并运行.需要注意的是，所有模块均自动隐式依赖java.base模块，不需要显示声明<br>exports指出需要暴露的包，如果某个包没有被exports，那么其他模块是无法访问的。</p>
<p>Readability:指的是必须exports的包才可被其他模块访问<br>Accessibility:指的是即使是exports的包，其中的类的可访问下也要基于java的访问修饰符，仅有public修饰的才可被其他模块访问</p>
<p>Implied Readability(隐式Readability, requires transitive):<br>Readability默认情况下是不会被传递的<br>requires transitive，传递性依赖生效</p>
<p>由于requires transitive的存在，就可以支持聚合模块。有些聚合模块可以没有任何代码，就一个module-info.java描述文件，比如java.se, java.se.ee模块<br>不建议直接引用java.se模块，因为它就相当于java9以前版本的rt.jar的内容。</p>
<p>Qualified Exports(有限制的exports)<br>比如我只想exports某个包给部分模块,而不是所有模块</p>
<h3 id="2、模块化基础"><a href="#2、模块化基础" class="headerlink" title="2、模块化基础"></a>2、模块化基础</h3><p>（1）模块拥有一个名称，并对相关的代码以及可能的其他资源进行分组，同时使用一个模块描述符进行描述。模块描述符保存在一个名为module-info.java的文件中。<br>（2）模块描述符还可以包含exports语句。强封装性是模块的默认特性。只有当显式地导出一个包时（比如示例中的java.util.prefs），才可以从其他模块中访问该包<br>可访问性和可读性的结合可以确保在模块系统中实现强封装性。<br>（3）其他模块无法使用未导出包中的任何类型——即使包中的类型是公共的。这是对Java语言可访问性规则的根本变化。<br>（4）Java 9出现之后，public意味着仅对模块中的其他包公开。只有当导出包包含了公开类型时，其他模块才可以使用这些类型。这就是强封装的意义所在。</p>
<p>在模块出现之前，强封装实现类的唯一方法是将这些类放置到单个包中，并标记为私有。这种做法使得包变得非常笨重，实际上，将类公开只是为了实现不同包之间的访问。通过使用模块，可以以任何方式构建包，并仅导出模块使用者真正必须访问的包。如果愿意的话，还可以将导出的包构成模块的API。</p>
<p>（5）模块提供了导出包的显式信息，从而能够高效地对模块路径进行索引。当从给定的包中查找类型时，Java运行时和编译器可以准确地知道从模块路径中解析哪个模块。而在以前，对整个类路径进行扫描是找到任意类型的唯一方法。</p>
<p>在解析过程中还会完成一些额外的检查。例如，具有相同名称的两个模块在启动时（而不是在运行过程出现类加载失败时）会产生错误。此外，还会检查导出包的唯一性。</p>
<p>模块解析过程以及额外的检查确保了应用程序在一个可靠的环境中运行，降低了运行时失败的可能性。</p>
<p>（6）通过使用未命名模块，尚未模块化的代码可以继续在JDK 9上运行。<br>当将代码放在类路径上时，会自动使用未命名模块。这也意味着需要构建一个正确的类路径。可一旦使用了未命名模块，前面讨论的模块系统所带来的保障和好处也就没有了。</p>
<p>当在Java 9中使用类路径时，还需要注意两件事情。首先，由于平台是模块化的，因此对内部实现类进行了强封装。</p>
<p>（7）模块系统执行的另一个检查是循环依赖。<br>在编译时，模块之间的可读性关系必须是非循环的。而在模块中，仍然可以在类之间创建循环关系</p>
<p>（8）通过使用ServiceLoader API可在模块描述符和代码中表示服务<br>使用这个功能可以对代码的实现进行良好的封装</p>
<h3 id="3、以非模块化方式开发和运行应用"><a href="#3、以非模块化方式开发和运行应用" class="headerlink" title="3、以非模块化方式开发和运行应用"></a>3、以非模块化方式开发和运行应用</h3><p>在java9中也是允许你以非模块化方式开发和运行应用的(也就是说，模块化开发是可选的)，如果你的应用中没有module-info.java，那么这就是一个unnamed module. java9对于unnamed module的处理方式就是所有的jdk模块均直接可用(模块图中是以java.se模块作为root模块的，也意味着单独处于java.se.ee下的一些包，比如JAXB API是无法访问到的)。</p>
<p>但是需要注意的是，在java8以及之前的版本中，我们可以访问jdk中的一些不推荐访问的内部类，比如com.sun.image.codec.jpeg,但在java9模块化之后被强封装了，所以在java9中无法使用这些内部类，也就是说无法通过编译，但是java9为了保持兼容性，允许之前引用这些内部类的已有的jar或已编译的类正确运行。换言之，就是java9不允许源码中引用这些类，无法通过编译，但是之前版本中引用这些类的已编译class文件是允许正常运行的。</p>
<h1 id="三、迁移"><a href="#三、迁移" class="headerlink" title="三、迁移"></a>三、迁移</h1><p>（1）为了便于将基于类路径的应用程序迁移到Java 9，在对平台模块中的类应用深度反射时，或者使用反射来访问非导出包中的类型时，JVM默认显示警告</p>
<p>（2）那些在JDK 8和更早的版本上运行没有任何问题的代码现在会在控制台上显示一个醒目的警告——即使是在生产环境中也是如此。这表明严重破坏了强封装。除了这个警告之外，应用程序仍然照常运行。如警告消息所示，在下一个Java版本中行为将发生变化。将来，即使是类路径上的代码，JDK也会强制执行平台模块的强封装。</p>
<p>（3）可以使用–add-opens标志授予对模块中特定包的类路径深度反射访问。同样，当类路径上的代码尝试访问非导出包中的类型时，可以使用–add-exports来强制导出包。</p>
<p>（4）为了使逐步迁移成为可能，可以混合使用类路径和模块路径。但这不是一种理想的情况，因为只能部分受益于Java模块系统的优点。但是，“小步”迁移是非常有帮助的。</p>
<h2 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h2><p>Java模块系统提供了一个有用的功能来处理非模块的代码：自动模块。只需将现有的JAR文件从类路径移动到模块路径，而不改变其内容，就可以创建一个自动模块。这样一来，JAR就转换为一个模块，同时模块系统动态生成模块描述符。相比之下，显式模块始终有一个用户自定义的模块描述符。</p>
<p>自动模块的行为不同于显式模块。自动模块具有以下特征：</p>
<p>（1）不包含module-info.class；<br>（2）它有一个在META-INF&#x2F;MANIFEST.MF中指定或者来自其文件名的模块名称。<br>（3）通过requires transitive请求所有其他已解析模块。<br>（4）导出所有包。<br>（5）读取路径（或者更准确地讲，读取前面所讨论的未命名模块）。<br>（6）它不能与其他模块拆分包。</p>
<p>自动模块并不是一个设计良好的模块。虽然请求所有的模块并导出所有的包听起来不像是正确的模块化，但至少是可用的。</p>
<p>自动模块中仍然没有明确的信息来告诉模块系统真正需要哪些模块，这意味着JVM在启动时不会警告自动模块的依赖项丢失。</p>
<p>作为开发人员，负责确保模块路径（或类路径）包含所有必需的依赖项。这与使用类路径没有太大区别。</p>
<p>模块图中的所有模块都需要通过自动模块传递。这实际上意味着，如果请求一个自动模块，那么就可以“免费”获得所有其他模块的隐式可读性。</p>
<p>当使用自动模块时，也会遇到拆分包。在大型应用程序中，由于依赖关系管理不善，通常会发现拆分包。拆分包始终是一个错误，因为它们在类路径上不能可靠地工作。</p>
<h2 id="未命名模块"><a href="#未命名模块" class="headerlink" title="未命名模块"></a>未命名模块</h2><p>模块路径上的非模块化JAR变成了自动模块。而类路径变成了未命名模块。</p>
<p>类路径上的所有代码都是未命名模块的一部分。</p>
<p>存在一个很大的限制：未命名模块本身只能通过自动模块读取（只有自动模块可以读取类路径）</p>
<p>当读取未命名模块时自动模块和显式模块之间的区别。显式模块只能读取其他显式模块和自动模块。而自动模块可读取所有模块，包括未命名模块。</p>
<p>未命名模块的可读性只是一种在混合类路径&#x2F;模块路径迁移方案中有助于自动模块的机制。</p>
<p>JVM为什么没有那么“聪明”呢？它有权访问自动模块中的所有代码，那么为什么不分析依赖关系呢？如果想要分析这些代码是否调用其他模块，JVM需要对所有代码执行字节码分析。虽然这不难实现，但却是一个昂贵的操作，可能会大量增加大型应用程序的启动时间。而且，这样的分析不会发现通过反射产生的依赖关系。由于存在这些限制，JVM不可能也永远不会这样做。相反，JDK附带了另一个工具jdeps，它可以执行字节码分析。</p>
<p>现代构建工具通常有一个“在重复依赖项上失败”的设置，这使得依赖关系管理问题变得更加清晰，从而迫使尽早解决这些问题。强烈建议使用这个设置。关于该问题，Java模块系统比类路径要严格得多。当它检测到一个包从模块路径上的两个模块导出时，就会拒绝启动。相比于以前使用类路径时所遇到的不可靠情况，这种快速失败（fail-fast）机制要好得多。在开发过程中失败好过在生产过程中失败，尤其是当一些不幸的用户碰到一个由于模糊的类路径问题而被破坏的代码路径时。但这也意味着我们必须处理这些问题。盲目地将所有JAR从类路径移至模块路径可能导致在生成的自动模块之间出现拆分包。而这些拆分包将被模块系统所拒绝。</p>
<p>为了使迁移变得容易一些，当涉及自动模块和未命名模块时，上述规则存在一个例外，即承认很多类路径是不正确的，并且包含拆分包。当（自动）模块和未命名模块都包含相同的包时，将使用来自（自动）模块的包，而未命名模块中的包被忽略。</p>
<p>如果在迁移到Java 9时遇到了拆分包问题，那么是无法绕过的。即使从用户角度来看基于类路径的应用程序可以正确工作，你也必须处理这些问题。</p>
<p>拆分包会导致无法以模块系统的方式启动服务</p>
<h2 id="未命名模块（unnamed-module）和自动模块（automatic-module）总结"><a href="#未命名模块（unnamed-module）和自动模块（automatic-module）总结" class="headerlink" title="未命名模块（unnamed module）和自动模块（automatic module）总结"></a>未命名模块（unnamed module）和自动模块（automatic module）总结</h2><p>（1）一个未经模块化改造的 jar 文件是转为未命名模块还是自动模块，取决于这个 jar 文件出现的路径，如果是类路径，那么就会转为未命名模块，如果是模块路径，那么就会转为自动模块。注意，自动模块也属于命名模块的范畴，其名称是模块系统基于 jar 文件名自动推导得出的<br>（2）两者还有一个关键区别，分裂包规则适用于自动模块，但对未命名模块无效，也即多个未命名模块可以导出同一个包，但自动模块不允许。<br>（3） 未命名模块和自动模块存在的意义在于，无论传入的 jar 文件是否一个合法的模块（包含 module descriptor），Java 内部都可以统一的以模块的方式进行处理，这也是 Java 9 兼容老版本应用的架构原理。运行老版本应用时，所有 jar 文件都出现在类路径下，也就是转为未命名模块，对于未命名模块而言，默认导出所有包并且依赖所有模块，因此应用可以正常运行。<br>（4）基于未命名模块和自动模块，相应的就产生了两种老版本应用的迁移策略，或者说模块化策略。<br>（5）等所有 jar 包都完成模块化改造，应用改为 -m 方式启动，这也标志着应用已经迁移为真正的 Java 9 应用<br>（6）-cp 和 -m 可以同时存在 并运行？？可以（类路径和模块系统可以混合运行）</p>
<h2 id="java9-自动模块-的意义"><a href="#java9-自动模块-的意义" class="headerlink" title="java9 自动模块 的意义"></a>java9 自动模块 的意义</h2><p>（1）个人理解，只是为了让开发者能像模块一样使用起来，引入。实际上封装性方面和类路径没任何区别。<br>（2）未命名模块和自动模块存在的意义在于，无论传入的 jar 文件是否一个合法的模块（包含 module descriptor），Java 内部都可以统一的以模块的方式进行处理，这也是 Java 9 兼容老版本应用的架构原理。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>（1）如何用最快的速度判别它是不是一个模块？它又是如何定义的？<br>试试看 jar -d -f <jar_file>。<br>（2）通过JDK11内置jdeps工具查找过期以及废弃API以及对应的替换<br><code>./jdk-11.0.10.jdk/Contents/Home/bin/jdeps --jdk-internals ./build/libs/service.jar</code><br><code>./jdk-11.0.10.jdk/Contents/Home/bin/jdeps --jdk-internals -R --class-path ./build/deploy/* ./build/libs/*</code><br><code>jdeps --jdk-internals -R --class-path &#39;libs/*&#39; $project</code><br>libs是你的所有依赖的目录，$project是你的项目jar包<br>（3）我们可以在线上使用OpenJDK，开发时，使用任意的JDK。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87157172">https://zhuanlan.zhihu.com/p/87157172</a></jar_file></p>
<h2 id="库迁移"><a href="#库迁移" class="headerlink" title="库迁移"></a>库迁移</h2><p>迁移库和迁移应用程序之间最大的区别在于库被许多应用程序使用。这些应用程序可能运行在不同版本的Java上，所以库通常需要在各种Java版本上工作。期望库的用户在你迁移库的同时切换到Java 9是不现实的。</p>
<p>库的迁移过程由以下步骤组成：</p>
<p>1）确保库可以作为自动模块在Java 9上运行。<br>2）使用Java 9编译器编译库（主要使用满足需求的最低Java版本），而不使用新的Java 9功能。<br>3）添加一个模块描述符，并将库转换为显式模块。<br>4）重构库的结构，以便增加封装性，识别API，并尽可能分割成多个模块（可选）。<br>5）开始使用库中的Java 9功能，同时保持向后兼容Java 9的早期版本。</p>
<p>库管理需要使用java8编译，模块描述需要用java9编译，且不能使用新特性，否则java8编译不过</p>
<p>项目模块化后，很多第三库（基于反射的），深度反射项目代码，或jdk，可能不能用，要进行特殊处理</p>
<p>历史解决jar包冲突问题得改造成模块化</p>
<h1 id="四、模块系统实践例子"><a href="#四、模块系统实践例子" class="headerlink" title="四、模块系统实践例子"></a>四、模块系统实践例子</h1><h2 id="1、相同模块不同版本，新版废弃方法"><a href="#1、相同模块不同版本，新版废弃方法" class="headerlink" title="1、相同模块不同版本，新版废弃方法"></a>1、相同模块不同版本，新版废弃方法</h2><p>结论：运行时才会报错</p>
<p>module_2-1.0  依赖 module_1-1.0 printInfo.print2()方法，项目依赖 module_1-2.0 printInfo.print3()；<br>build的时候并不能识别到错误，只有运行时才会发现错误 java.lang.NoSuchMethodError: com.kxw.module1.info.PrintInfo.print2()V</p>
<h2 id="2、不同模块含重复类"><a href="#2、不同模块含重复类" class="headerlink" title="2、不同模块含重复类"></a>2、不同模块含重复类</h2><p>结论：不同模块可以存在相同类，在引入时指定模块，可以正确加载到对应类</p>
<p>（1）如果同时引入两个不同模块（不管是直接还是间接），编译时会检测引入的模块是否包含可读的相同路径<br>编译报错：错误: 未命名的模块同时从 com.kxw.module.four 和 com.kxw.module.three 读取程序包 com.kxw.module.config</p>
<p>（2）如果模块存在相同类，但是却没有通过export声明，仅内部使用，那么编译时将无法检测，但运行时报 （两个模块都没有export的情况，结果一样）<br>Error occurred during initialization of boot layer<br>java.lang.LayerInstantiationException: Package com.kxw.module.config in both module com.kxw.module.three and</p>
<p>没声明（export）的情况下，运行时怎么检测有相同的package？<br>报：Checks for split packages between modules defined to the built-in class loaders.<br> ModuleBootstrap#checkSplitPackages 会检查所有module的package是否重复，通过String other &#x3D; packageToModule.putIfAbsent(p, name);来实现</p>
<p>结论：只要是一个模块，且被引入，有相同包名都可以在启动时被检测出来并报错 （为什么编译时不做的呢？main方法不明确？还是要指定主模块？）</p>
<p>注意：类路径加载的模块都是未命名模块，且不会因为包冲突而报错 </p>
<h1 id="五、classloader的变化"><a href="#五、classloader的变化" class="headerlink" title="五、classloader的变化"></a>五、classloader的变化</h1><h2 id="1、类加载器变化概览"><a href="#1、类加载器变化概览" class="headerlink" title="1、类加载器变化概览"></a>1、类加载器变化概览</h2><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>（1）任意一个 ClassLoader 在尝试加载一个类的时候，都会先尝试调用其父类的相关方法去加载类，如果其父类不能加载该类，则交由子类去完成。 这样的好处：对于任意使用者自定义的 ClassLoader，都会先去尝试让 jvm 的 Bootstrap ClassLoader 去尝试加载(自定义的 ClassLoader 都继承了它们)。那么就能保证 jvm 的类会被优先加载，限制了使用者对 jvm 系统的影响。</p>
<p>（2）jdk9中的双亲委派机制仍然存在，只是在委派之前会优先寻找模块所属的加载器进行加载。</p>
<h3 id="jdk9之前"><a href="#jdk9之前" class="headerlink" title="jdk9之前"></a>jdk9之前</h3><p>Boostrap -&gt; Extension -&gt; Application</p>
<p>（1）bootstrap classloader加载rt.jar，jre&#x2F;lib&#x2F;endorsed （用来加载 jvm 自身需要的类，c++ 实现，用来加载 rt.jar）<br>（2）ext classloader加载jre&#x2F;lib&#x2F;ext （ 在 jdk9 中已经被移除。）<br>（3）application classloader加载-cp指定的类 (负责加载ClassPath路径下的类)</p>
<h3 id="jdk9及之后"><a href="#jdk9及之后" class="headerlink" title="jdk9及之后"></a>jdk9及之后</h3><p>Application -&gt; Platform -&gt; Boostrap</p>
<p>（1）bootstrap classloader加载lib&#x2F;modules 中的核心模块 （主要用来加载 java.base 中的核心系统类）<br>（2）ext classloader被废弃，新增platform classloader，加载lib&#x2F;modules的非核心模块 （用来加载 jdk 中的非核心模块类）<br>（3）application classloader加载-cp，-mp指定的类 （用来加载一般的应用类）</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>JDK9开始，AppClassLoader父类不再是 URLClassLoader；而是BuiltinClassLoader</p>
<p>之前对于动态加载的类，我们总是通过将这个类通过反射调用URLClassLoader加到classpath里面进行加载。这么加载在JDK11中已经无法实现，并且这样加载的类不能卸载。 对于动态加载的类，我们在OpenJDK11中只能自定义类加载器去加载，而不是通过获取APPClassLoader去加载。同时，这么做也有助于你随时能将动态加载的类卸载，因为并没有加载到APPClassLoader。</p>
<p>建议使用自定义的类加载器继承SecureClassLoader去加载类：java.security.SecureClassLoader</p>
<h3 id="BuiltinClassLoader"><a href="#BuiltinClassLoader" class="headerlink" title="BuiltinClassLoader"></a>BuiltinClassLoader</h3><p>BuiltinClassLoader 是 jdk9 中代替 URLClassLoader 的加载器，是 PlatformClassLoader 与 AppClassLoader 的父类。其继承了 SecureClassLoader，其核心的方法主要是 loadClassOrNull(…) 方法</p>
<h3 id="如何自定义加载器"><a href="#如何自定义加载器" class="headerlink" title="如何自定义加载器"></a>如何自定义加载器</h3><p>（1）java9之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArthasClassloader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArthasClassloader</span><span class="params">(URL[] urls)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(urls, ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span> (loadedClass != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> loadedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先从parent（SystemClassLoader）里加载系统类，避免抛出ClassNotFoundException</span></span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; (name.startsWith(<span class="string">&quot;sun.&quot;</span>) || name.startsWith(<span class="string">&quot;java.&quot;</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name, resolve);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line"><span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">resolveClass(aClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> aClass;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name, resolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）java9之后</p>
<p>TODO</p>
<h2 id="2、扩展机制"><a href="#2、扩展机制" class="headerlink" title="2、扩展机制"></a>2、扩展机制</h2><p>（1）版本9之前的Java SE允许扩展机制，可以通过将JAR放置在系统属性java.ext.dirs指定的目录中来扩展运行时映像。 如果未设置此系统属性，则使用jre\lib\ext目录作为其默认值。 该机制通过扩展类加载器（这是引导类加载器的子类）和系统类加载器的父级加载了该目录中的所有JAR。 它加载所有应用程序类。 这些JAR的内容对于在此运行时映像上编译或运行的所有应用程序都可见。</p>
<p>（2）Java SE 9不支持扩展机制。 如果需要类似的功能，可以将这些JAR放在类路径的前面。 使用名为JAVA_HOME\lib\ext的目录或设置名为java.ext.dirs的系统属性会导致JDK 9中的错误。</p>
<p>（3）在JDK 9之前，扩展类加载器和应用程序类加载器是java.net.URLClassLoader类的一个实例。 在JDK 9中，平台类加载器（以前的扩展类加载器）和应用程序类加载器是内部JDK类的实例。 如果你的代码依赖于URLClassLoader类的特定方法，代码可能会在JDK 9中崩溃。</p>
<h2 id="3、类加载器的加载流程"><a href="#3、类加载器的加载流程" class="headerlink" title="3、类加载器的加载流程"></a>3、类加载器的加载流程</h2><p><img src="/2022/02/08/20220208-java11-ji-chu-yuan-li-he-shi-jian/java11_classloader.png"></p>
<h3 id="在JDK-9之前"><a href="#在JDK-9之前" class="headerlink" title="在JDK 9之前"></a>在JDK 9之前</h3><p>a. JDK使用三个类加载器来加载类<br>b. JDK类加载器以分层方式工作 —— 引导类加载器位于层次结构的顶部。 类加载器将类加载请求委托给上层类加载器。</p>
<p>例如，如果应用程序类加载器需要加载一个类，它将请求委托给扩展类加载器，扩展类加载器又将请求委托给引导类加载器。 如果引导类加载器无法加载类，扩展类加载器将尝试加载它。 如果扩展类加载器无法加载类，则应用程序类加载器尝试加载它。 如果应用程序类加载器无法加载它，则抛出ClassNotFoundException异常。</p>
<p>c. 引导类加载器是扩展类加载器的父类。 扩展类加载器是应用程序类加载器的父类。 引导类加载器没有父类。 默认情况下，应用程序类加载器将是你创建的其他类加载器的父类。</p>
<h3 id="在JDK-9之前的类加载机制"><a href="#在JDK-9之前的类加载机制" class="headerlink" title="在JDK 9之前的类加载机制"></a>在JDK 9之前的类加载机制</h3><p>（1）【Boostrap】引导类加载器加载由Java平台组成的引导类，包括JAVA_HOME\lib\rt.jar中的类和其他几个运行时JAR。 它完全在虚拟机中实现。 可以使用-Xbootclasspath&#x2F;p和-Xbootclasspath&#x2F;a命令行选项来附加引导目录。 可以使用-Xbootclasspath选项指定引导类路径，该选项将替换默认的引导类路径。 在运行时，sun.boot.class.path系统属性包含引导类路径的只读值。 JDK通过null表示这个类加载器。 也就是说，你不能得到它的引用。 例如，Object类由引导类加载器加载，并且Object.class.getClassLoader()表达式将返回null。</p>
<p>（2）【Extension】扩展类加载器用于通过java.ext.dirs系统属性指定的目录中的位于JAR中的扩展机制加载可用的类。要获得扩展类加载器的引用，需要获取应用程序类加载器的引用，并在该引用上使用getParent()方法。</p>
<p>（3）【Application】应用程序类加载器从由CLASSPATH环境变量指定的应用程序类路径或命令行选项-cp或-classpath加载类。应用程序类加载器也称为系统类加载器，这是一种误称，它暗示它加载系统类。可以使用ClassLoader类的静态方法getSystemClassLoader()获取对应用程序类加载器的引用。</p>
<h3 id="在JDK-9及之后"><a href="#在JDK-9及之后" class="headerlink" title="在JDK 9及之后"></a>在JDK 9及之后</h3><p>a. JDK9保持三级分层类加载器架构以实现向后兼容。但是，从模块系统加载类的方式有一些变化。<br>b. 在JDK 9中，应用程序类加载器【Application】可以委托给平台类加载器【Platform】以及引导类加载器【Boostrap】；平台类加载器【Platform】可以委托给引导类加载器【Boostrap】和应用程序类加载器【Application】。</p>
<p>（1）在JDK 9中，引导类加载器是由类库和代码在虚拟机中实现的(不再是c++实现)。 为了向后兼容，它在程序中仍然由null表示。 例如，Object.class.getClassLoader()仍然返回null。 但是，并不是所有的Java SE平台和JDK模块都由引导类加载器加载。 举几个例子，引导类加载器加载的模块是java.base，java.logging，java.prefs和java.desktop。 其他Java SE平台和JDK模块由平台类加载器和应用程序类加载器加载，这在下面介绍。 JDK 9中不再支持用于指定引导类路径，-Xbootclasspath和-Xbootclasspath&#x2F;p选项以及系统属性sun.boot.class.path。-Xbootclasspath&#x2F;a选项仍然受支持，其值存储在jdk.boot.class.path.append的系统属性中。</p>
<p>（2）JDK 9不再支持扩展机制。 但是，它将扩展类加载器保留在名为平台类加载器的新名称下。 ClassLoader类包含一个名为getPlatformClassLoader()的静态方法，该方法返回对平台类加载器的引用。 下表包含平台类加载器加载的模块列表。 平台类加载器用于另一目的。 默认情况下，由引导类加载器加载的类将被授予所有权限。 但是，几个类不需要所有权限。 这些类在JDK 9中已经被取消了特权，并且它们被平台类加载器加载以提高安全性。<br>下面是JDK 9中由平台加载器加载的模块列表。</p>
<p>（3）应用程序类加载器加载在模块路径上找到的应用程序模块和一些提供工具或导出工具API的JDK模块，如下表所示。 仍然可以使用ClassLoader类的getSystemClassLoader()的静态方法来获取应用程序类加载器的引用。</p>
<h3 id="在JDK-9及之后的的类加载机制"><a href="#在JDK-9及之后的的类加载机制" class="headerlink" title="在JDK 9及之后的的类加载机制"></a>在JDK 9及之后的的类加载机制</h3><p>三个内置的类加载器一起协作来加载类。</p>
<p>（1）当应用程序类加载器需要加载类时，它将搜索定义到所有类加载器的模块。 如果有合适的模块定义在这些类加载器中，则该类加载器将加载类，这意味着应用程序类加载器现在可以委托给引导类加载器和平台类加载器。 如果在为这些类加载器定义的命名模块中找不到类，则应用程序类加载器将委托给其父类，即平台类加载器。 如果类尚未加载，则应用程序类加载器将搜索类路径。 如果它在类路径中找到类，它将作为其未命名模块的成员加载该类。 如果在类路径中找不到类，则抛出ClassNotFoundException异常。</p>
<p>（2）当平台类加载器需要加载类时，它将搜索定义到所有类加载器的模块。 如果一个合适的模块被定义为这些类加载器中，则该类加载器加载该类。 这意味着平台类加载器可以委托给引导类加载器以及应用程序类加载器。 如果在为这些类加载器定义的命名模块中找不到一个类，那么平台类加载器将委托给它的父类，即引导类加载器。</p>
<p>（3）当引导类加载器需要加载一个类时，它会搜索自己的命名模块列表。 如果找不到类，它将通过命令行选项-Xbootclasspath&#x2F;a指定的文件和目录列表进行搜索。 如果它在引导类路径上找到一个类，它将作为其未命名模块的成员加载该类。</p>
<p>JDK 9包含一个名为-Xlog::modules的选项，用于在虚拟机加载时记录调试或跟踪消息，可以看到类加载器及其加载的模块和类。其格式如下：</p>
<p><code>-Xlog:modules=&lt;debug|trace&gt;</code><br><code>java -Xlog:modules=trace --module-path lib --module com.jdojo.prime.client/com.jdojo.prime.client.Main &gt; test.txt</code></p>
<h3 id="JDK-9各类加载器对应加载的模块"><a href="#JDK-9各类加载器对应加载的模块" class="headerlink" title="JDK 9各类加载器对应加载的模块"></a>JDK 9各类加载器对应加载的模块</h3><p>（1）bootstrap classloader加载lib&#x2F;modules</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br></pre></td></tr></table></figure>
<p>（2）platform classloader，加载lib&#x2F;modules</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.activation* jdk.accessibility</span><br><span class="line">java.compiler* jdk.charsets</span><br><span class="line">java.corba* jdk.crypto.cryptoki</span><br><span class="line">java.scripting jdk.crypto.ec</span><br><span class="line">java.se jdk.dynalink</span><br><span class="line">java.se.ee jdk.incubator.httpclient</span><br><span class="line">java.security.jgss jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio jdk.jsobject</span><br><span class="line">java.sql jdk.localedata</span><br><span class="line">java.sql.rowset jdk.naming.dns</span><br><span class="line">java.transaction* jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* jdk.security.auth</span><br><span class="line">java.xml.crypto jdk.security.jgss</span><br><span class="line">java.xml.ws* jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* jdk.zipfs</span><br></pre></td></tr></table></figure>
<p>（3）application classloader加载-cp，-mp指定的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk.aot jdk.jdeps</span><br><span class="line">jdk.attach jdk.jdi</span><br><span class="line">jdk.compiler jdk.jdwp.agent</span><br><span class="line">jdk.editpad jdk.jlink</span><br><span class="line">jdk.hotspot.agent jdk.jshell</span><br><span class="line">jdk.internal.ed jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat jdk.pack</span><br><span class="line">jdk.internal.le jdk.policytool</span><br><span class="line">jdk.internal.opt jdk.rmic</span><br><span class="line">jdk.jartool jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc jdk.xml.bind*</span><br><span class="line">jdk.jcmd jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure>
<h2 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h2><p>（1）如果你想访问classpath下的内容，你可以读取环境变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pathSeparator</span> <span class="operator">=</span> System</span><br><span class="line">.getProperty(<span class="string">&quot;path.separator&quot;</span>);</span><br><span class="line">String[] classPathEntries = System</span><br><span class="line">.getProperty(<span class="string">&quot;java.class.path&quot;</span>)</span><br><span class="line">.split(pathSeparator);</span><br></pre></td></tr></table></figure>
<p>（2）设置虚拟机参数为”-XX:+TraceClassLoading”来获取类加载信息<br>（3）如何判断类是有未命名模块加载，还是正常模块加载的 ：clazz.getModule()</p>
<h1 id="六、垃圾回收器"><a href="#六、垃圾回收器" class="headerlink" title="六、垃圾回收器"></a>六、垃圾回收器</h1><h2 id="JDK-11-默认使用G1"><a href="#JDK-11-默认使用G1" class="headerlink" title="JDK 11 默认使用G1"></a>JDK 11 默认使用G1</h2><p>G1会比CMS有更多的内存消耗，多了两个内存结构：</p>
<p>Remembered Sets：每个区块Region都有一个与之对应的Remembered Set来记录不同区块间对象引用（其他收集器只是记录新生代、老年代间互相引用）。用来避免全堆扫描<br>Collection Sets：将要被回收区块对象的集合，GC时收集器将这些区块对象复制到其他区块中</p>
<h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p>
<p>停顿时间不超过10ms；<br>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；<br>支持8MB~4TB级别的堆（未来支持16TB）。</p>
<p>从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。</p>
<p>对吞吐量优先的场景，ZGC可能并不适合。<br>ZGC作为下一代垃圾回收器，性能非常优秀。ZGC垃圾回收过程几乎全部是并发，实际STW停顿时间极短，不到10ms。这得益于其采用的着色指针和读屏障技术。</p>
<p>后续考虑在生产环境使用ZGC。</p>
<h1 id="七、新特性"><a href="#七、新特性" class="headerlink" title="七、新特性"></a>七、新特性</h1><h2 id="1、HttpClient-API"><a href="#1、HttpClient-API" class="headerlink" title="1、HttpClient API"></a>1、HttpClient API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">.uri(URI.create(<span class="string">&quot;http://openjdk.java.net/&quot;</span>))</span><br><span class="line">.build();</span><br><span class="line">client.sendAsync(request, BodyHandlers.ofString())</span><br><span class="line">.thenApply(HttpResponse::body)</span><br><span class="line">.thenAccept(System.out::println)</span><br><span class="line">.join();</span><br></pre></td></tr></table></figure>
<h2 id="2、使用Stream-dropWhile-简化代码"><a href="#2、使用Stream-dropWhile-简化代码" class="headerlink" title="2、使用Stream dropWhile 简化代码"></a>2、使用Stream dropWhile 简化代码</h2><p>获取列表从lastId开始到结尾的子集</p>
<p>java8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (UserDynamicSortSetMemberWithScoreBO bo : sortSetKeyList) &#123;</span><br><span class="line"><span class="keyword">if</span> (bo.getId() == lastId) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sortSetKeyList.stream()</span><br><span class="line">.skip(index + <span class="number">1</span>)</span><br><span class="line">.limit(DynamicConfig.feedListPageSize())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>java9</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> sortSetKeyList.stream()</span><br><span class="line">.dropWhile(v -&gt; !v.getId().equals(lastId))</span><br><span class="line">.skip(<span class="number">1</span>)</span><br><span class="line">.limit(DynamicConfig.feedListPageSize())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="3、Optional-ifPresentOrElse"><a href="#3、Optional-ifPresentOrElse" class="headerlink" title="3、Optional.ifPresentOrElse"></a>3、Optional.ifPresentOrElse</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optional.ifPresentOrElse( x -&gt; System.out.println(<span class="string">&quot;Value: &quot;</span> + x),() -&gt;</span><br><span class="line">System.out.println(<span class="string">&quot;Not Present.&quot;</span>));</span><br></pre></td></tr></table></figure>


<h1 id="八、迁移实践"><a href="#八、迁移实践" class="headerlink" title="八、迁移实践"></a>八、迁移实践</h1><h2 id="目标1：可运行"><a href="#目标1：可运行" class="headerlink" title="目标1：可运行"></a>目标1：可运行</h2><p>由于项目历史沉重（代码不兼容或依赖未模块化），先使用旧方式运行（类路径而不是模块系统）</p>
<p>1、目标：用最简单快速的方式使用java11编译和运行代码<br>2、收益：使用属于Java 9-11 新的API、工具和性能改进。<br>3、未使用Java 9的旗舰功能——模块系统，仍使用类路径方式运行服务</p>
<h2 id="目标2：使用模块系统运行"><a href="#目标2：使用模块系统运行" class="headerlink" title="目标2：使用模块系统运行"></a>目标2：使用模块系统运行</h2><p>模块化改造，在现有的项目中如何发挥模块化的作用</p>
<h3 id="自动模块会exports所有包，导致分包问题，不同模块包含相同包"><a href="#自动模块会exports所有包，导致分包问题，不同模块包含相同包" class="headerlink" title="自动模块会exports所有包，导致分包问题，不同模块包含相同包"></a>自动模块会exports所有包，导致分包问题，不同模块包含相同包</h3><p>解决的方法：<br>（1）改代码，去除这种不规范（难，第三方包很多这种）<br>（2）把这种包放在未命名模块</p>
<h3 id="由于完全模块化分包的问题无法解决，所以要混合两种方式运行项目"><a href="#由于完全模块化分包的问题无法解决，所以要混合两种方式运行项目" class="headerlink" title="由于完全模块化分包的问题无法解决，所以要混合两种方式运行项目"></a>由于完全模块化分包的问题无法解决，所以要混合两种方式运行项目</h3><p>gradle对混合两种（类路径和模块系统）的支持不足<br>直接命令行使用混合两种运行是可以的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./jdk-11.0.10.jdk/Contents/Home/bin/java --add-opens=java.base/jdk.internal.loader=ALL-UNNAMED -cp &quot;build/deploy/*&quot; -p &quot;build/module/*&quot; --add-modules &quot;com.xx.xx.xx&quot; com.xx.xx.xx.Application</span><br></pre></td></tr></table></figure>


<h2 id="目标3：使用java17"><a href="#目标3：使用java17" class="headerlink" title="目标3：使用java17"></a>目标3：使用java17</h2><h3 id="1、Gradle-7-3-is-the-first-version-fully-supporting-Java-17"><a href="#1、Gradle-7-3-is-the-first-version-fully-supporting-Java-17" class="headerlink" title="1、Gradle 7.3 is the first version fully supporting Java 17"></a>1、Gradle 7.3 is the first version fully supporting Java 17</h3><h3 id="2、Spring-Boot-2-5-5是Spring-Boot-第一个支持Java-17的版本"><a href="#2、Spring-Boot-2-5-5是Spring-Boot-第一个支持Java-17的版本" class="headerlink" title="2、Spring Boot 2.5.5是Spring Boot 第一个支持Java 17的版本"></a>2、Spring Boot 2.5.5是Spring Boot 第一个支持Java 17的版本</h3><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><ul>
<li>新版本jdk现在基本都是规定时间内免费，比如半年或三年，一般情况下直接用openjdk就足够了。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1598291">OpenJDK和Oracle JDK有什么区别和联系</a></li>
<li><a target="_blank" rel="noopener" href="https://www.fokyl.com/news/openjdk%20oracle%20jdk%20.html">openjdk与Oraclejdk的区别</a><ul>
<li>在2006年11月13日的JavaOne大会上，Sun公司（当时还没被收购）宣布计划要把Java开源，在随后的一年多时间内，它陆续地将JDK的各个部分在GPL v2（GNU General Public License v2）协议下公开了源码，并建立了OpenJDK组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有权不属于Sun公司，Sun本身也无权进行开源处理）外，OpenJDK几乎拥有了当时SunJDK 的全部代码。</li>
<li>但是随着JDK版本的不断发布，Oracle失去了维护OpenJDK的耐心，因为不赚钱啊。RedHat从Oracle手上接过OpenJDK的管理权利和维护职责。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19646618">https://www.zhihu.com/question/19646618</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/353325963">https://www.zhihu.com/question/353325963</a><ul>
<li>OpenJDK 实际上不适合拿来和 OracleJDK 进行对比，OpenJDK 不提供 LTS 服务，而 OracleJDK 每三年都会推出一个 LTS 版进行长期支持。</li>
</ul>
</li>
<li>从 11+ 版本开始 -XX:+UseContainerSupport 已经自动开启, 可以自适应内存pod的内存限制,不用通过<code>-Xms -Xmx</code> 来设置</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>[Java 9模块化开发_核心原则与实践]</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34378888/article/details/112584392">模块化加载_Java9模块化的类加载机制实现剖析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/eMac/article/details/107131444">【JDK 11】关于 Java 模块系统，看这一篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/IcanFixIt/p/7131676.html">Java 9 揭秘（8. JDK 9重大改变）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87157172">从JDK8升级到JDK11，看这篇就足够了</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47685388/load-class-from-exploded-module-using-custom-classloader">Load class from exploded module using custom classloader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-classloaders">Class Loaders in Java</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60764/how-to-load-jar-files-dynamically-at-runtime">How to load JAR files dynamically at Runtime?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46112809/is-it-possible-to-load-and-unload-jdk-and-custom-modules-dynamically-in-java-9">Is it possible to load and unload jdk and custom modules dynamically in Java 9?</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903666932006926">聊聊java9的classloader</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020110723">JVM_类加载机制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ag5u2EPObx7bZr7hkcrOTg">新一代垃圾回收器ZGC的探索与实践</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/17/20220117-nio-zong-jie-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/17/20220117-nio-zong-jie-bi-ji/" itemprop="url">NIO总结笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-17T14:55:32+08:00">
                2022-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-I-x2F-O"><a href="#Java-I-x2F-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><table>
<thead>
<tr>
<th>I&#x2F;O</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<ul>
<li>I&#x2F;O 与 NIO 一个比较重要的区别是我们使用 I&#x2F;O 的时候往往会引入多线程，每个连接使用一个单独的线程，而 NIO 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。而由于 NIO 的非阻塞需要一直轮询，比较消耗系统资源，所以异步非阻塞模式 AIO 就诞生了。</li>
</ul>
<h3 id="5-种-I-x2F-O模型"><a href="#5-种-I-x2F-O模型" class="headerlink" title="5 种 I&#x2F;O模型"></a>5 种 I&#x2F;O模型</h3><ol>
<li>blocking I&#x2F;O</li>
<li>nonblocking I&#x2F;O</li>
<li>I&#x2F;O multiplexing (select and poll)</li>
<li>signal driven I&#x2F;O (SIGIO)</li>
<li>asynchronous I&#x2F;O (the POSIX aio_functions)。</li>
</ol>
<ul>
<li>不同的操作系统对上述模型支持不同，UNIX 支持 IO 多路复用。不同系统叫法不同，freebsd 里面叫 kqueue，Linux 叫 epoll。而 Windows2000 的时候就诞生了 IOCP 用以支持 asynchronous I&#x2F;O。</li>
<li>Java 是一种跨平台语言，为了支持异步 I&#x2F;O，诞生了 NIO，Java1.4 引入的 NIO1.0 是基于 I&#x2F;O 复用的，它在各个平台上会选择不同的复用方式。Linux 用的 epoll，BSD 上用 kqueue，Windows 上是重叠 I&#x2F;O。</li>
<li>IO多路复用，Java NIO的核心类库多路复用器Selector就是基于epoll的多路复用技术实现。</li>
<li>IO复用的系统调用方式：select，pselect，poll，epoll（IO复用属于同步IO）</li>
<li>同步阻塞BIO，同步非阻塞NIO，异步非阻塞AIO<br> 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！</li>
</ul>
<h3 id="Java-I-x2F-O-的相关方法"><a href="#Java-I-x2F-O-的相关方法" class="headerlink" title="Java I&#x2F;O 的相关方法"></a>Java I&#x2F;O 的相关方法</h3><ol>
<li>同步并阻塞 (I&#x2F;O 方法)：服务器实现模式为一个连接启动一个线程，每个线程亲自处理 I&#x2F;O 并且一直等待 I&#x2F;O 直到完成，即客户端有连接请求时服务器端就需要启动一个线程进行处理。但是如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善这个缺点。I&#x2F;O 的局限是它是面向流的、阻塞式的、串行的一个过程。对每一个客户端的 Socket 连接 I&#x2F;O 都需要一个线程来处理，而且在此期间，这个线程一直被占用，直到 Socket 关闭。在这期间，TCP 的连接、数据的读取、数据的返回都是被阻塞的。也就是说这期间大量浪费了 CPU 的时间片和线程占用的内存资源。此外，每建立一个 Socket 连接时，同时创建一个新线程对该 Socket 进行单独通信 (采用阻塞的方式通信)。这种方式具有很快的响应速度，并且控制起来也很简单。在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况；</li>
<li>同步非阻塞 (NIO 方法)：服务器实现模式为一个请求启动一个线程，每个线程亲自处理 I&#x2F;O，但是另外的线程轮询检查是否 I&#x2F;O 准备完毕，不必等待 I&#x2F;O 完成，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程进行处理。NIO 则是面向缓冲区，非阻塞式的，基于选择器的，用一个线程来轮询监控多个数据传输通道，哪个通道准备好了 (即有一组可以处理的数据) 就处理哪个通道。服务器端保存一个 Socket 连接列表，然后对这个列表进行轮询，如果发现某个 Socket 端口上有数据可读时，则调用该 Socket 连接的相应读操作；如果发现某个 Socket 端口上有数据可写时，则调用该 Socket 连接的相应写操作；如果某个端口的 Socket 连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到大幅度提高；</li>
<li>异步非阻塞 (AIO 方法，JDK7 发布)：服务器实现模式为一个有效请求启动一个线程，客户端的 I&#x2F;O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，每个线程不必亲自处理 I&#x2F;O，而是委派操作系统来处理，并且也不需要等待 I&#x2F;O 完成，如果完成了操作系统会另行通知的。该模式采用了 Linux 的 epoll 模型。</li>
</ol>
<ul>
<li>在连接数不多的情况下，传统 I&#x2F;O 模式编写较为容易，使用上也较为简单。但是随着连接数的不断增多，传统 I&#x2F;O 处理每个连接都需要消耗一个线程，而程序的效率，当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少的。所以传统阻塞式 I&#x2F;O 的瓶颈在于不能处理过多的连接。非阻塞式 I&#x2F;O 出现的目的就是为了解决这个瓶颈。非阻塞 IO 处理连接的线程数和连接数没有联系，例如系统处理 10000 个连接，非阻塞 I&#x2F;O 不需要启动 10000 个线程，你可以用 1000 个，也可以用 2000 个线程来处理。因为非阻塞 IO 处理连接是异步的，当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求“事件”，并把这个“事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还，这样一个线程就可以异步的处理多个事件。而阻塞式 I&#x2F;O 的线程的大部分时间都被浪费在等待请求上了。</li>
</ul>
<h3 id="AIO-相关的类和接口"><a href="#AIO-相关的类和接口" class="headerlink" title="AIO 相关的类和接口"></a>AIO 相关的类和接口</h3><ul>
<li><code>java.nio.channels.AsynchronousChannel</code>：标记一个 Channel 支持异步 IO 操作；</li>
<li><code>java.nio.channels.AsynchronousServerSocketChannel</code>：ServerSocket 的 AIO 版本，创建 TCP 服务端，绑定地址，监听端口等；</li>
<li><code>java.nio.channels.AsynchronousSocketChannel</code>：面向流的异步 Socket Channel，表示一个连接；</li>
<li><code>java.nio.channels.AsynchronousChannelGroup</code>：异步 Channel 的分组管理，目的是为了资源共享。一个 AsynchronousChannelGroup 绑定一个线程池，这个线程池执行两个任务：处理 IO 事件和派发 CompletionHandler。AsynchronousServerSocketChannel 创建的时候可以传入一个 AsynchronousChannelGroup，那么通过 AsynchronousServerSocketChannel 创建的 AsynchronousSocketChannel 将同属于一个组，共享资源；</li>
<li><code>java.nio.channels.CompletionHandler</code>：异步 IO 操作结果的回调接口，用于定义在 IO 操作完成后所作的回调工作。AIO 的 API 允许两种方式来处理异步操作的结果：返回的 Future 模式或者注册 CompletionHandler，推荐用 CompletionHandler 的方式，这些 handler 的调用是由 AsynchronousChannelGroup 的线程池派发的。这里线程池的大小是性能的关键因素。</li>
</ul>
<h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>常用的Reactor线程模型有三种，分别如下：</p>
<ol>
<li>Reactor单线程模型；</li>
<li>Reactor多线程模型；</li>
<li>主从Reactor多线程模型    <ul>
<li>Netty的线程模型并非固定不变，通过在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。</li>
</ul>
</li>
</ol>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/netty-threading-model">http://www.infoq.com/cn/articles/netty-threading-model</a></li>
<li>主从Reactor线程模型</li>
<li>Netty线程开发最佳实践<ul>
<li>2.4.1. 时间可控的简单业务直接在IO线程上处理<br>  如果业务非常简单，执行时间非常短，不需要与外部网元交互、访问数据库和磁盘，不需要等待其它资源，则建议直接在业务ChannelHandler中执行，不需要再启业务的线程或者线程池。避免线程上下文切换，也不存在线程并发问题。</li>
<li>2.4.2. 复杂和时间不可控业务建议投递到后端业务线程池统一处理<br>  对于此类业务，不建议直接在业务ChannelHandler中启动线程或者线程池处理，建议将不同的业务统一封装成Task，统一投递到后端的业务线程池中进行处理。<br>  过多的业务ChannelHandler会带来开发效率和可维护性问题，不要把Netty当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和Netty的架构分层。</li>
<li>2.4.3. 业务线程避免直接操作ChannelHandler<br>  对于ChannelHandler，IO线程和业务线程都可能会操作，因为业务通常是多线程模型，这样就会存在多线程操作ChannelHandler。为了尽量避免多线程并发问题，建议按照Netty自身的做法，通过将操作封装成独立的Task由NioEventLoop统一执行，而不是业务线程直接操作<br>  <code>ctx.executor().execute(new Runnable()&#123;&#125;)</code><br>  如果你确认并发访问的数据或者并发操作是安全的，则无需多此一举，这个需要根据具体的业务场景进行判断，灵活处理。</li>
</ul>
</li>
</ul>
<h3 id="Netty的“零拷贝”"><a href="#Netty的“零拷贝”" class="headerlink" title="Netty的“零拷贝”"></a>Netty的“零拷贝”</h3><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。</li>
<li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</li>
<li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
</ul>
<h3 id="Netty-灵活的TCP参数配置能力"><a href="#Netty-灵活的TCP参数配置能力" class="headerlink" title="Netty - 灵活的TCP参数配置能力"></a>Netty - 灵活的TCP参数配置能力</h3><ul>
<li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；</li>
<li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
<li>软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。</li>
</ul>
<h3 id="心跳实现"><a href="#心跳实现" class="headerlink" title="心跳实现"></a>心跳实现</h3><ul>
<li>使用TCP协议层的Keeplive机制，但是该机制默认的心跳时间是2小时，依赖操作系统实现不够灵活</li>
<li>应用层实现自定义心跳机制，比如Netty实现心跳机制<ul>
<li>服务端添加IdleStateHandler心跳检测处理器，并添加自定义处理Handler类实现userEventTriggered()方法作为超时事件的逻辑处理</li>
</ul>
</li>
</ul>
<h3 id="Netty中比较常用的帧解码器"><a href="#Netty中比较常用的帧解码器" class="headerlink" title="Netty中比较常用的帧解码器"></a>Netty中比较常用的帧解码器</h3><ol>
<li>固定长度帧解码器 - FixedLengthFrameDecoder<ul>
<li>适用场景：每个上层数据包的长度，都是固定的，比如 100。在这种场景下，只需要把这个解码器加到 pipeline 中，Netty 会把底层帧，拆分成一个个长度为 100 的数据包 (ByteBuf)，发送到下一个 channelHandler入站处理器。</li>
</ul>
</li>
<li>行分割帧解码器 - LineBasedFrameDecoder<ul>
<li>适用场景：每个上层数据包，使用换行符或者回车换行符做为边界分割符。发送端发送的时候，每个数据包之间以换行符&#x2F;回车换行符作为分隔。在这种场景下，只需要把这个解码器加到 pipeline 中，Netty 会使用换行分隔符，把底层帧分割成一个一个完整的应用层数据包，发送到下一站。前面的例子，已经对这个解码器进行了演示。</li>
</ul>
</li>
<li>自定义分隔符帧解码器 - DelimiterBasedFrameDecoder<ul>
<li>DelimiterBasedFrameDecoder 是LineBasedFrameDecoder的通用版本。不同之处在于，这个解码器，可以自定义分隔符，而不是局限于换行符。如果使用这个解码器，在发送的时候，末尾必须带上对应的分隔符。</li>
</ul>
</li>
<li>自定义长度帧解码器 - LengthFieldBasedFrameDecoder<ul>
<li>这是一种基于灵活长度的解码器。在数据包中，加了一个长度字段（长度域），保存上层包的长度。解码的时候，会按照这个长度，进行上层ByteBuf应用包的提取。</li>
<li>LengthFieldPrepender(编码)：如果协议中的第一个字段为长度字段，netty提供了LengthFieldPrepender编码器，它可以计算当前待发送消息的二进制字节长度，将该长度添加到ByteBuf的缓冲区头中</li>
</ul>
</li>
</ol>
<h3 id="Netty-API"><a href="#Netty-API" class="headerlink" title="Netty API"></a>Netty API</h3><h4 id="JDK-ByteBuffer-VS-Netty-ByteBuf"><a href="#JDK-ByteBuffer-VS-Netty-ByteBuf" class="headerlink" title="JDK ByteBuffer VS Netty ByteBuf"></a>JDK ByteBuffer VS Netty ByteBuf</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013828625/article/details/79845512">https://blog.csdn.net/u013828625/article/details/79845512</a></li>
<li>Netty中的ByteBuf则完全对JDK中的ByteBuffer的缺点进行了改进</li>
<li>网络数据的基本单位永远是 byte(字节)。Java NIO 提供 ByteBuffer 作为字节的容器，但该类过于复杂，有点难用。ByteBuf是Netty当中的最重要的工具类，它与JDK的ByteBuffer原理基本上相同，也分为堆内与堆外俩种类型，但是ByteBuf做了极大的优化，具有更简单的API，更多的工具方法和优秀的内存池设计。</li>
<li>ByteBuf 维护俩不同索引：一个用于读取，一个用于写入：从 ByteBuf 读取时，其 readerIndex 将会被递增已经被读取的字节数；当写入 ByteBuf 时，writerIndex 也会被递增</li>
</ul>
<h4 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ffaiss/p/9843442.html">SimpleChannelInboundHandler与ChannelInboundHandlerAdapter</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/97235">Netty随记之ChannelInboundHandlerAdapter、SimpleChannelInboundHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lemon-flm/p/7813914.html">Netty——高级发送和接收数据handler处理器</a></li>
<li>每一个Handler都一定会处理出站或者入站（也可能两者都处理）数据，例如对于入站的Handler可能会继承SimpleChannelInboundHandler或者ChannelInboundHandlerAdapter，而SimpleChannelInboundHandler又是继承于ChannelInboundHandlerAdapter，最大的区别在于SimpleChannelInboundHandler会对没有外界引用的资源进行一定的清理，并且入站的消息可以通过泛型来规定。</li>
<li>对于两者关系：<br><code>public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter</code></li>
<li><code>public void channelRead(ChannelHandlerContext ctx, Object msg) </code> , msg 是ByteBuf类型（未decode转化类型的情况），使用 SimpleChannelInboundHandler 会被自动释放</li>
</ul>
<ol>
<li>ChannelInboundHandlerAdapter<ul>
<li>ChannelInboundHandlerAdapter是ChannelInboundHandler的一个简单实现，默认情况下不会做任何处理，只是简单的将操作通过fire*方法传递到ChannelPipeline中的下一个ChannelHandler中让链中的下一个ChannelHandler去处理。</li>
<li>需要注意的是信息经过channelRead方法处理之后不会自动释放（因为信息不会被自动释放所以能将消息传递给下一个ChannelHandler处理）。</li>
</ul>
</li>
<li>SimpleChannelInboundHandler<ul>
<li>SimpleChannelInboundHandler支持泛型的消息处理，默认情况下消息处理完将会被自动释放，无法提供fire*方法传递给ChannelPipeline中的下一个ChannelHandler,如果想要传递给下一个ChannelHandler需要调用ReferenceCountUtil#retain方法。</li>
<li>channelRead0方法在将来将会重命名为messageReceived</li>
</ul>
</li>
</ol>
<h4 id="channelRead-和channelReadComplete"><a href="#channelRead-和channelReadComplete" class="headerlink" title="channelRead()和channelReadComplete()"></a>channelRead()和channelReadComplete()</h4><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000018753423">channelRead()和channelReadComplete() 方法的区别是什么？</a></li>
<li>channelRead表示接收消息，可以看到msg转换成了ByteBuf，然后打印，也就是把Client传过来的消息打印了一下，你会发现每次打印完后，channelReadComplete也会调用，如果你试着传一个超长的字符串过来，超过1024个字母长度，你会发现channelRead会调用多次，而channelReadComplete只调用一次。</li>
</ul>
<h4 id="ctx-write-vd-ctx-channel-write"><a href="#ctx-write-vd-ctx-channel-write" class="headerlink" title="ctx.write() vd ctx.channel().write()"></a>ctx.write() vd ctx.channel().write()</h4><ul>
<li>Any difference between ctx.write() and ctx.channel().write() in netty?:<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20366418/any-difference-between-ctx-write-and-ctx-channel-write-in-netty">https://stackoverflow.com/questions/20366418/any-difference-between-ctx-write-and-ctx-channel-write-in-netty</a></li>
<li>Yes there is… Channel.write(..) always start from the tail of the ChannelPipeline and so pass through all the ChannelOutboundHandlers. ChannelHandlerContext.write(…) starts from the current position of the ChannelHandler which is bound to the ChannelHandlerContext and so only pass those ChannelOutboundHandlers that are in front of it.</li>
</ul>
<h4 id="自定义消息协议"><a href="#自定义消息协议" class="headerlink" title="自定义消息协议"></a>自定义消息协议</h4><ul>
<li><p>len : 表示消息的长度,通常用4个字节保存</p>
</li>
<li><p>head : 消息头部</p>
</li>
<li><p>body : 消息内容</p>
</li>
<li><p>在实际的项目中,消息格式可能会增加一些标志,例如,开始标记,结束标志,消息序列号,消息的协议类型(json或者二进制等)</p>
</li>
</ul>
<h3 id="Netty-没用JDK1-7的AIO"><a href="#Netty-没用JDK1-7的AIO" class="headerlink" title="Netty 没用JDK1.7的AIO"></a>Netty 没用JDK1.7的AIO</h3><ul>
<li>为什么Netty不用AIO而用NIO?</li>
</ul>
<pre>
According to the book the main reasons were:
1. Not faster than NIO (epoll) on unix systems (which is true)
There is no daragram suppport
2. Unnecessary threading model (too much abstraction without usage)
3. I agree that AIO will not easily replace NIO, but it is useful for windows developers nonetheless.
<https: 2515 github.com netty issues>
We obviously did not consider Windows as a serious platform so far, and that's why we were neglecting NIO.2 AIO API which was implemented using IOCP on Windows. (On Linux, it wasn't any faster because it was using the same OS facility - epoll.)
</https:></pre>

<h3 id="Netty-Epoll"><a href="#Netty-Epoll" class="headerlink" title="Netty-Epoll"></a>Netty-Epoll</h3><ul>
<li>Selector 实现原理:<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2b71ea919d49">http://www.jianshu.com/p/2b71ea919d49</a></li>
</ul>
<ul>
<li>epoll的两种工作模式：<ul>
<li>LT：level-trigger，水平触发模式，只要某个socket处于readable&#x2F;writable状态，无论什么时候进行epoll_wait都会返回该socket。<br>  当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。<br>  当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。<br>  ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
</li>
<li>在Linux系统中JDK NIO使用的是 LT ，而Netty epoll使用的是 ET。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>JDK中有自带的ByteBuffer类，但是netty中的 ByteBuf 算是对Byte Buffer的重新实现。他们没有关联关系。</li>
<li>netty推荐使用<code>io.netty.buffer.Unpooled</code>来进行Buff的创建工作。Unpooled是一个工具类，可以为ByteBuf分配空间、拷贝或者封装操作</li>
<li>DirectBuffer：使用 DirectBuffer 是一种更加接近系统底层的方法，所以，它的速度比普通的 ByteBuffer 更快。DirectBuffer 相对于 ByteBuffer 而言，读写访问速度快很多，但是创建和销毁 DirectBuffer 的花费却比 ByteBuffer 高。</li>
<li>Netty的并发处理能力主要体现在两个方面：<ol>
<li>利用Java语言自身的多线程机制实现消息的并行处理；</li>
<li>利用Java NIO类库的Selector实现多路复用，一个NIO线程可以同时并发处理成百上千个通信链路，实现海量客户端的并发接入和处理。</li>
</ol>
</li>
<li>netty.pipeline执行顺序：在给定的示例配置中，当事件进入到入站时，处理程序计算顺序为(代码行：从上到下)。当一个事件出站时，顺序是(代码行：从下到上)。</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/netty-high-performance">Netty系列之Netty高性能之道</a>  </li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/linsongbin1/article/details/77915686">Netty实战-自定义解码器处理半包消息</a></li>
<li>TODO nio-demo&#x2F;docs</li>
<li>TODO nio_demo&#x2F;netty-definitive-guide&#x2F;netty-definitive-guide-notes.md</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/" itemprop="url">如何做数据库迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-14T11:26:02+08:00">
                2022-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先抛出以下问题：<br>把MHA-1集群的Database-C 迁到 MHA-2 集群中，有没有简单高效的方案?<br><img src="/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/migration.png"></p>
<hr>
<ul>
<li>方案1、在两个MHA集群，在建一套MHA3。MHA2的主作为MHA1的从？这样MH3切换的时候，应用服务就可以直接感知切到新库了；</li>
<li>方案2、先把C同步到2集群，然后做otter同步</li>
</ul>
<hr>
<ul>
<li>方案1： 存在的问题：<ul>
<li>中间再搞一套MHA，不是运维麻烦，而是多了一套中间库，可能会导致MHA的切换逻辑紊乱。</li>
</ul>
</li>
<li>方案2： <ul>
<li>业务方的服务要自行选择数据源进行切换 （流量低且数据一致性要求不高，考虑通过开关切换；否则需考虑停服等其他方案）</li>
<li>otter双向同步，业务最好同时只写一边（要注意旧库是否有自增主键；同步冲突策略设置，默认会冲突会同步中断）</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/27/20211027-raft-xue-xi-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/27/20211027-raft-xue-xi-bi-ji/" itemprop="url">raft学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-27T10:42:07+08:00">
                2021-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>Raft将共识问题分解三个子问题：</p>
<ol>
<li>Leader election 领导选举：有且仅有一个leader节点，如果leader宕机，通过选举机制选出新的leader；</li>
<li>Log replication 日志复制：leader从客户端接收数据更新&#x2F;删除请求，然后日志复制到follower节点，从而保证集群数据的一致性；</li>
<li>Safety 安全性：通过安全性原则来处理一些特殊case，保证Raft算法的完备性；</li>
</ol>
</li>
<li><p>所以，Raft算法核心流程可以归纳为：</p>
<ul>
<li>首先选出leader，leader节点负责接收外部的数据更新&#x2F;删除请求；</li>
<li>然后日志复制到其他follower节点，同时通过安全性的准则来保证整个日志复制的一致性；</li>
<li>如果遇到leader故障，followers会重新发起选举出新的leader；</li>
</ul>
</li>
<li><p>Raft规定：只有拥有最新提交日志的follower节点才有资格成为leader节点。具体做法：candidate竞选投票时会携带最新提交日志，follower会用自己的日志和candidate做比较。</p>
</li>
<li><p>因为日志提交需要超过半数的节点同意，所以针对日志同步落后的follower（还未同步完全部日志，导致落后于其他节点）在竞选leader的时候，肯定拿不到超过半数的票，也只有那些完成同步的才有可能获取超过半数的票成为leader。</p>
</li>
<li><p>日志更新判断方式是比较日志项的term和index：</p>
<ul>
<li>如果TermId不同，选择TermId最大的；</li>
<li>如果TermId相同，选择Index最大的；</li>
</ul>
</li>
<li><p>Raft对日志提交有额外安全机制：leader只能提交当前任期Term的日志，旧任期Term（以前的数据）只能通过当前任期Term的数据提交来间接完成提交。简单的说，日志提交有两个条件需要满足：</p>
<ul>
<li>当前任期；</li>
<li>复制结点超过半数；</li>
</ul>
</li>
<li><p>Raft在日志项提交上增加了限制：只有当前任期且复制超过半数的日志才可以提交。</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/obnZm2Lhf_rKla2AxbrBlg">分布式一致性算法Raft</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zMnqOCUVvRLQuJUwvM3QRA">Raft 一致性算法论文中文译文</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/12/20211012-cqrs-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/12/20211012-cqrs-bi-ji/" itemprop="url">CQRS笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-12T18:37:20+08:00">
                2021-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/backend-development-cqrs/">后端开发实践系列——简单可用的CQRS编码实践</a></li>
<li></li>
</ul>
<h3 id="个人认为："><a href="#个人认为：" class="headerlink" title="个人认为："></a>个人认为：</h3><ol>
<li>清除消息业务：写时只记录一个”清除时间”，读时只读取”清除时间”之后的数据，这是一种CQRS (避免写时操作太多数据，QPS不高，但单个请求需要操作多条数据的情况)</li>
<li>消息通知业务：写时只写在redis，定时任务从redis批量获取数据逐步写入的数据库（QPS高，但单个请求却不多，可以批量操作的情况）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/12/20211012-fen-bu-shi-li-lun-xiang-guan-zheng-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/12/20211012-fen-bu-shi-li-lun-xiang-guan-zheng-li/" itemprop="url">分布式理论相关整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-12T17:46:33+08:00">
                2021-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>分布式存储系统通常通过维护多个副本来进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题：维护多个副本的一致性。</li>
<li>一致性（consensus）,它是构建具有容错性（fault-tolerant）的分布式系统的基础。 在一个具有一致性的性质的集群里面，同一时刻所有的结点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致。集群具有自动恢复的性质，当少数结点失效的时候不影响集群的正常工作，当大多数集群中的结点失效的时候，集群则会停止服务（不会返回一个错误的结果）。</li>
<li>一致性协议就是用来保证即使在部分(确切地说是小部分)副本宕机的情况下，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。</li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><ul>
<li>[分布式架构的套路](&lt;<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vJJWpIZ-bTzVl9E3wPLlEw">https://mp.weixin.qq.com/s/vJJWpIZ-bTzVl9E3wPLlEw</a>)<ul>
<li>1、纯负载均衡形式。<br>硬件层面的 F5、软件层面的 nginx</li>
<li>2、领导选举型<br>整个集群的消息都会转发到集群的领导这里，是一种 master-slavers，区别只是这个 master 是被临时选举出来的，一旦 master 宕机，集群会立刻选举出一个新的领导，继续对外提供服务。<br>ElasticSearch，zookeeper、Raft</li>
<li>3、区块链型<br>整个集群的每一个节点都可以进行记录，但是记录的内容要得到整个集群 N 个机器的认可才是合法的。典型的应用有 Bit Coin，以及 Hyperledger。</li>
<li>4、master-slaver型<br>整个集群以某台 master 为中枢，进行集群的调度。交互是这样，一般会把所有的管理类型的数据放到 master 上，而把具体的数据放到 slaver 上，实际进行调用的时候，client 先调用 master 获取数据所存放的 server 的 信息，再自行跟 slave 进行交互。典型的系统有 Hadoop。集群，HBase 集群，Redis 集群等。</li>
<li>5、规则型一致性Hash<br>这种架构类型一般出现在数据库分库分表的设计中。按照规则进行分库分表，在查询之前使用规则引擎进行库和表的确认，再对具体的应用进行访问。为什么要用一致性 Hash ？其实用什么都可以，只是对于这类应用来说一致性 Hash 比较常见而已。</li>
</ul>
</li>
</ul>
<h3 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a>副本一致性</h3><ol>
<li>强一致性(strong consistency)</li>
<li>单调一致性(monotonic consistency):任何时刻,任何用户一旦读到某个数据在某次更新后的值, 这个用户不会再读到比这个值更旧的值。</li>
<li>会话一致性(session consistency)：在同一个会话内，系统保证读己所写的一致性。</li>
<li>最终一致性(eventual consistency):如果没有更新，最终系统会返回最后更新的值。换句话说，如果系统在持续更新，则永远无法达到一致性。</li>
<li>弱一致性(week consistency)：系统并不保证后续读操作获得更新值的时间点;弱一致性系统 一般很难在实际中使用,使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li>
<li>因果一致性：和写进程具有因果关系的进程将会读取到更新的数据，写进程保证取代上次更更新。</li>
<li>读己所写一致性：进程永远读取自己上次更新写入的最新值，而不可能读取到任何历史数据。这是传统操作系统默认的一致性行为。</li>
</ol>
<h3 id="分布式系统中的一致性模型"><a href="#分布式系统中的一致性模型" class="headerlink" title="分布式系统中的一致性模型"></a>分布式系统中的一致性模型</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_yJqXUIQ7ka8f46j3VCbuQ">分布式系统中的一致性模型</a></li>
<li>一致性模型是所有被允许的操作记录的集合。当我们运行一个程序，经过一系列集合中允许的操作，特定的执行结果总是一致的。如果程序意外地执行了非集合中的操作，我们就称执行记录是非一致的。如果任意可能的执行操作都在这个被允许的操作集合内，那么系统就满足一致性模型。</li>
<li>现实往往没有那么理想化：在几乎每个实际的系统中，进程之间都有一定的距离。一个没有被缓存的值（指没有被CPU的local cache缓存），通常在距离CPU30厘米的DIMM内存条上。光需要整整一个纳秒来传播这么长的距离，实际的内存访问会比光速慢得多。位于不同数据中心某台计算机上的值可以相距几千公里——意味着需要几百毫秒的传播时间。我们没有更快传播数据的方法，否则就违反了物理定律。（物理定律都违反了，就更别谈什么现代计算机体系了。）</li>
<li>这意味着我们的操作不再是瞬时的。某些操作也许快到可以被近乎认为是瞬时的，但是通常来说，操作是耗时的。我们调用对一个变量的写操作；写操作传播到内存，或其他计算机，或月球；内存改变状态；一个确认信息回传；这样我们才知道这个操作真实的发生了。</li>
<li>在分布式系统中，操作的耗时被放大了，我们必须使一致性模型更宽松：允许这些有歧义的顺序发生。</li>
<li>我们该如何确定宽松的程度？我们必须允许所有可能的顺序吗？或许我们还是应该强加一些合理性约束？</li>
</ul>
<ol>
<li>线性一致性（Linearizability）<ul>
<li>线性一致性模型提供了这样的保证：1.对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进。2.所有的读总能返回最近的写操作的值。</li>
</ul>
</li>
<li>顺序一致性（Sequential consistency）<ul>
<li>如果我们允许进程在时间维度发生偏移，从而它们的操作可能会在调用之前或是完成之后生效，但仍然保证一个约束——任意进程中的操作必须按照进程中定义的顺序（即编程的定义的逻辑顺序）发生。这样我们就得到了一个稍弱的一致性模型：顺序一致性。</li>
<li>顺序一致性放松了对一致性的要求：1. 不要求操作按照真实的时间序发生。2. 不同进程间的操作执行先后顺序也没有强制要求，但必须是原子的。3. 单个进程内的操作顺序必须和编码时的顺序一致。</li>
<li>如果我在Twitter上写了一条推文，或是在Facebook发布了一篇帖子，都会耗费一定的时间渗透进一层层的缓存系统。不同的用户将在不同的时间看到我的信息，但每个用户都以同一个顺序看到我的操作。一旦看到，这篇帖子便不会消失。如果我写了多条评论，其他人也会按顺序的看见，而非乱序。</li>
</ul>
</li>
<li>因果一致性（Casual consistency）<ul>
<li>我们不必对一个进程中的每个操作都施加顺序约束。只有因果相关的操作必须按顺序发生。同样拿帖子举例子：一篇帖子下的所有评论必须以同样的顺序展示给所有人，并且只有帖子可见后，帖子下的回复才可见（也就是说帖子和帖子下的评论有因果关系）。如果我们将这些因果关系编码成类似“我依赖于操作X”的形式，作为每个操作明确的一部分，数据库就可以将这些操作延迟直到它们的依赖都就绪后才可见。</li>
<li>因果一致性比同一进程下对每个操作严格排序的一致性（即顺序一致性）来的更宽松——属于同一进程但不同因果关系链的操作能以相对的顺序执行（也就是说按因果关系隔离，无因果关系的操作可以并发执行），这能防止许多不直观的行为发生。</li>
</ul>
</li>
<li>串行一致性（Serializable consistency）<ul>
<li>如果我们说操作记录的发生等效于某些单一的原子序，但和调用时间与完成时间无关，那么我们就得到了名为串行一致性的一致性模型。这一模型比你想象的更强大同时也更脆弱。</li>
<li>因为串行一致性允许对操作顺序执行任意的重排（只要操作顺序是原子序的）， 它在实际的场景中并不是十分有用。大多数宣称提供了串行一致性的数据库实际上提供的是强串行一致性，它有着和线性一致性一样的时间边界。让事情更复杂的是，大多数SQL数据库宣称的串行一致性等级比实际的更弱，比如可重复读，游标稳定性，或是快照隔离性。</li>
<li>关于线性一致性和串行一致性，看似十分相似，其实不然。串行一致性是数据库领域的概念，是针对事务而言的，描述对一组事务的执行效果等同于某种串行的执行，没有ordering的概念，而线性一致性来自并行计算领域，描述了针对某种数据结构的操作所表现出的顺序特征。串行一致性是对多操作，多对象的保证，对总体的操作顺序无要求；线性一致性是对单操作，单对象的保证，所有操作遵循真实时间序</li>
</ul>
</li>
<li>FIFO 一致性（FIFO consistency, 又称 PRAM consistency, pipelined RAM consistency）。<ul>
<li>FIFO 一致性不会考虑多个进程之间的操作排序。对任意一个进程的写操作 1 与写操作 2，若写操作 1 先于写操作 2 完成，那么任何进程不可以先读到写操作 2 的值，再读到写操作 1 的值。</li>
</ul>
</li>
</ol>
<ul>
<li>强一致（strict consistency），通常是指线性一致性或顺序一致性。线性一致性与顺序一致性之间的区别，也可以被理解为系统模型的区别，即系统中是否存在绝对时间。弱于顺序一致性的一致性级别都可被称为弱一致，而最终一致性是弱一致性的一种形式。</li>
</ul>
<h3 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a>衡量分布式系统的指标</h3><ul>
<li>性能</li>
<li>可用性</li>
<li>可扩展性</li>
<li>一致性</li>
</ul>
<h3 id="基本副本协议"><a href="#基本副本协议" class="headerlink" title="基本副本协议"></a>基本副本协议</h3><ul>
<li>副本控制协议分为两大类:“中心化(centralized)副本控制协议”和“去中心化(decentralized) 副本控制协议”。</li>
</ul>
<ol>
<li>中心化副本控制协议<ul>
<li>primary-secondary 协议</li>
</ul>
</li>
<li>去中心化副本控制协议(去中心化协议没有因为中心化节点异常而带来的停服务等问题。)</li>
</ol>
<h3 id="NWR-机制"><a href="#NWR-机制" class="headerlink" title="NWR 机制"></a>NWR 机制</h3><ul>
<li>首先看看这三个字母在分布式系统中的含义：<ul>
<li>N：有多少份数据副本；</li>
<li>W：一次成功的写操作至少有w份数据写入成功；</li>
<li>R：一次成功的读操作至少有R份数据读取成功。</li>
</ul>
</li>
<li>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N的时候，读取操作和写入操作成功的数据一定会有交集，这样就可以保证一定能够读取到最新版本的更新数据，数据的强一致性得到了保证，如果R+W&lt;&#x3D;N，则无法保证数据的强一致性，因为成功写和成功读集合可能不存在交集，这样读操作无法读取到最新的更新数值，也就无法保证数据的强一致性。</li>
<li>版本的新旧需要版本控制算法来判别，比如向量时钟。</li>
<li>当然R或者W不能太大，因为越大需要操作的副本越多，耗时越长。</li>
</ul>
<h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a>Quorum 机制</h3><ul>
<li>Quorum机制其实就是NWR机制。</li>
</ul>
<ol>
<li>Write-all-read-one(简称 WARO).<ul>
<li>WARO 读服务的可用性较高,但更新服务的可用性不高,甚至虽然使用了 副本,但更新服务的可用性等效于没有副本。WARO 牺牲了更新服务的可用性,最大程度的增强读服务的可用性。</li>
</ul>
</li>
<li>Quorum 机制</li>
</ol>
<ul>
<li>将 WARO 的条件进行松弛,从而使得可以在读写服务可用性之间做折中,得出 Quorum 机制。</li>
<li>在 Quorum 机制下,当某次更新操作 wi 一旦在所有 N 个副本中的 W 个副本上都成功,则就称 该更新操作为“成功提交的更新操作”,称对应的数据为“成功提交的数据”。</li>
<li>仅仅依赖 quorum 机制是无法保证强一致性的。因为仅有 quorum 机制时无法确 定最新已成功提交的版本号,除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数 据集群管理,否则很难确定最新成功提交的版本号。</li>
<li>Quorum 机制的三个系统参数 N、W、R 控制了系统的可用性,也是系统对用户的服务承诺:数 据最多有 N 个副本,但数据更新成功 W 个副本即返回用户成功。对于一致性要求较高的 Quorum 系 统,系统还应该承诺任何时候不读取未成功提交的数据,即读取到的数据都是曾经在 W 个副本上成 功的数据。</li>
</ul>
<hr>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5626889.html">分布式系统理论之Quorum机制</a></p>
</li>
<li><p>在分布式系统中有个CAP理论，对于P（分区容忍性）而言，是实际存在 从而无法避免的。因为，分布系统中的处理不是在本机，而是网络中的许多机器相互通信，故网络分区、网络通信故障问题无法避免。<br>因此，只能尽量地在C 和 A 之间寻求平衡。对于数据存储而言，为了提高可用性（Availability），采用了副本备份，比如对于HDFS，默认每块数据存三份。某数据块所在的机器宕机了，就去该数据块副本所在的机器上读取（从这可以看出，数据分布方式是按“数据块”为单位分布的）</p>
</li>
<li><p>但是，问题来了，当需要修改数据时，就需要更新所有的副本数据，这样才能保证数据的一致性（Consistency）。因此，就需要在 C(Consistency) 和 A(Availability) 之间权衡。</p>
</li>
<li><p>Quorum机制，就是这样的一种权衡机制，一种将“读写转化”的模型。在介绍Quorum之前，先看一个极端的情况：WARO机制。<br>WARO(Write All Read one)是一种简单的副本控制协议，当Client请求向某副本写数据时(更新数据)，只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</p>
<ul>
<li>①写操作很脆弱，因为只要有一个副本更新失败，此次写操作就视为失败了。②读操作很简单，因为，所有的副本更新成功，才视为更新成功，从而保证所有的副本一致。<br>  这样，只需要读任何一个副本上的数据即可。假设有N个副本，N-1个都宕机了，剩下的那个副本仍能提供读服务；但是只要有一个副本宕机了，写服务就不会成功。</li>
<li>WARO牺牲了更新服务的可用性，最大程度地增强了读服务的可用性。而Quorum就是更新服务和读服务之间进行一个折衷。</li>
<li>Quorum机制是“抽屉原理”的一个应用。定义如下：假设有N个副本，更新操作wi 在W个副本中更新成功之后，才认为此次更新操作wi 成功。称成功提交的更新操作对应的数据为：“成功提交的数据”。对于读操作而言，至少需要读R个副本才能读到此次更新的数据。其中，W+R&gt;N ，即W和R有重叠。一般，W+R&#x3D;N+1</li>
<li>5(3+3,5+1);7(4+4,5+3,7+1);9(5+5,7+3,9+1)</li>
</ul>
</li>
<li><p>1）如何读取最新的数据？—在已经知道最近成功提交的数据版本号的前提下，最多读R个副本就可以读到最新的数据了。<br>2）如何确定 最高版本号 的数据是一个成功提交的数据？—继续读其他的副本，直到读到的 最高版本号副本 出现了W次。</p>
</li>
<li><p>一般一个Quorum的节点数目不大于9个，故无法简单地将一致性系统节点直接部署在多个地域，系统需要能持续地水平拓展，来满足服务、资源的拓展需求</p>
</li>
</ul>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><ul>
<li>Consistency (一致性):CAP 理论中的副本一致性特指强一致性(1.3.4 );</li>
<li>Availiablity(可用性):指系统在出现异常时已经可以提供服务;</li>
<li>Tolerance to the partition of network (分区容忍):指系统可以对网络分区(1.1.4.2 )这种异常情 况进行容错处理;</li>
<li>协议分析<br>1. Lease 机制牺牲了部分异常情况下的 A,从而获得了完全的 C 与很好的 P。<br>2. Quorum 机制,在 CAP 三大因素中都各做了折中,有一定的 C,有较好 的 A,也有较好的 P,是一种较为平衡的分布式协议。<br>3. 两阶段提交系统具有完全的 C,很糟糕的 A,很糟糕的 P。<br>4. Paxos 协议 ,在 CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的 C,较好的 A,较好的 P。Paxos 的 A 与 P 的属性与 Quorum 机制类似,因为 Paxos 的协议本 身就具有 Quorum 机制的因素。</li>
<li>CAP中的三个因素并不对等，P是基础，CA之间需要tradeoff。系统设计不是三选二的取舍。</li>
<li>延迟作为可用性的指标和体现，系统设计通常需要在C和延迟之间tradeoff。</li>
<li>总结：P是一个自然的事实，CA是强需求。三者并不对等。</li>
<li>在数据库领域，CAP也正是ACID和BASE长期博弈(tradeoff)的结果。</li>
<li>ACID伴随数据库的诞生定义了系统基本设计思路，所谓先入为主。2000年左右，随着互联网的发展，高可用的话题被摆上桌面，所以提出了BASE。从此C和A的取舍消长此起彼伏，其结晶就是CAP理论。</li>
<li>从ACID和BASE来说，ACID是为了保证一致性而诞生，因而侧重一致性；BASE是为了高可用系统的设计而诞生，因而侧重可用性。在分解C和A的情况时，肯定要涉及P，所以CAP理论统一了这一切。如果非要说酸碱，或者说酸碱平衡，那就是平衡于CAP理论。</li>
<li>CAP并不与ACID中的A（原子性）冲突，值得讨论的是ACID中的C（一致性）和I（隔离性）。ACID的C指的是事务不能破坏任何数据库规则，如键的唯一性。与之相比，CAP的C仅指单一副本这个意义上的一致性，因此只是ACID一致性约束的一个严格的子集。如果系统要求ACID中的I（隔离性），那么它在分区期间最多可以在分区一侧维持操作。事务的可串行性（serializability）要求全局的通信，因此在分区的情况下不能成立。</li>
<li>CA系统才是真正的难点。宣称是CA系统的，目前有两家：一家是Google的Spanner，一家是Alibaba的OceanBase。</li>
<li>对P的分解需要从网络开始。网络包含了基础设施，光速限制以及软件配置与升级等。Google通过建设自己广域网获得高可靠的基础设施支撑，对于Google Spanner的CA系统，CAP之父曾总结说网络才是根本。</li>
<li>CAP理论：一致性与性能之间的trade-off</li>
</ul>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/V1sJcSjff1wbAoQVpLgUMA">请不要再称数据库是CP或者AP</a></li>
<li>一致性（Consistency）在CAP中是可线性化的意思（linearizability）。而这个是非常特殊（而且非常强）的一致性。尤其是虽然ACID中的C也是一致性（Consistency），但是和这里的一致性没有任何关系。</li>
<li>Alice还有Bob，他们在同一个房间，都在看他们的手机查2014年世界杯的决赛结果。就在最终结果刚发布之后，Alice刷新了页面，看到了宣布冠军，而且很兴奋地告诉了Bob。Bob马上也重新加载了他手机上的页面，但是他的请求被送到了一个数据库的拷贝，还没有拿到最新的数据，结果他的手机上显示决赛还正在进行。</li>
<li>如果Alice和Bob同时刷新，拿到了不一样的结果，并不会太让人意外。因为他们不知道具体服务器到底是先处理了他们中哪一个请求。但是Bob知道他刷新页面是在Alice告诉了他最终结果_之后_的。所以他预期他查询的结果一定比Alice的更新。事实是，他却拿到了旧的结果。这就违反了可线性化。</li>
<li>ZooKeeper默认设置既不是一致的（CP）也不是可用的（AP），只是“P”。但是你有选择通过用sync命令来让它成为CP。并且在正确的设置下，读操作（不包括写）其实是CAP可用的。</li>
</ul>
<h3 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a>Lease 机制</h3><ul>
<li>Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出 lease,则无论接受方是否收到,也无论后续接收方处于何种状态,只要 lease 不过期,颁发者一 定严守承诺;另一方面,接收方在 lease 的有效期内可以使用颁发者的承诺,但一旦 lease 过期,接 收方一定不能继续使用颁发者的承诺。</li>
<li>Lease 机制依赖于有效期,这就要求颁发者和接收者的时钟是同步的。对于这种时钟不同步,实践中的通常做法是 将颁发者的有效期设置得比接收者的略大,只需大过时钟误差就可以避免对 lease 的有效性的影响。</li>
</ul>
<hr>
<ul>
<li>master给各个slave分配不同的数据，每个节点的数据都具有有效时间比如1小时，在lease时间内，客户端可以直接向slave请求数据，如果超过时间客户端就去master请求数据。一般而言，slave可以定时主动向master要求续租并更新数据，master在数据发生变化时也可以主动通知slave，不同方式的选择也在于可用性与一致性之间进行权衡。</li>
<li>租约机制也可以解决主备之间网络不通导致的双主脑裂问题，亦即：主备之间本来心跳连线的，但是突然之间网络不通或者暂停又恢复了或者太繁忙无法回复，这时备机开始接管服务，但是主机依然存活能对外服务，这是就发生争夺与分区，但是引入lease的话，老主机颁发给具体server的lease必然较旧，请求就失效了，老主机自动退出对外服务，备机完全接管服务。</li>
</ul>
<h3 id="Split-Brain"><a href="#Split-Brain" class="headerlink" title="Split Brain"></a>Split Brain</h3><ul>
<li>如何避免“Split Brain”(脑裂)问题？<ul>
<li>Split Brain 是指在同一时刻有两个认为自己处于 Active 状态的 NameNode。</li>
</ul>
</li>
<li>Raft是一种一致性算法， gossip是广播协议</li>
<li>为 Raft 引入 leader lease 机制解决集群脑裂时的 stale read 问题：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/072380e12657">https://www.jianshu.com/p/072380e12657</a><ul>
<li>这种方法牺牲了一定的可用性（在脑裂时部分客户端的可用性）换取了一致性的保证。</li>
<li>多数派的网络分区挂了，岂不是直接不可写？</li>
</ul>
</li>
</ul>
<h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><ul>
<li>拜占庭将军问题提供了对分布式共识问题的一种情景化描述，是分布式系统领域最复杂的模型。此外, 它也为我们理解和分类现有的众多分布式一致性协议和算法提供了框架。现有的分布式一致性协议和算法主要可分为两类：<br>  1. 一类是故障容错算法(Crash Fault Tolerance, CFT)， 即非拜占庭容错算法，解决的是分布式系统中存在故障，但不存在恶意攻击的场景下的共识问题。也就是说，在该场景下可能存在消息丢失，消息重复，但不存在消息被篡改或伪造的场景。一般用于局域网场景下的分布式系统，如分布式数据库。属于此类的常见算法有Paxos算法、Raft算法、ZAB协议等。<br>  2. 一类是拜占庭容错算法，可以解决分布式系统中既存在故障，又存在恶意攻击场景下的共识问题。一般用于互联网场景下的分布式系统，如在数字货币的区块链技术中。属于此类的常见算法有PBFT算法、PoW算法。</li>
</ul>
<h3 id="CAP软件分类"><a href="#CAP软件分类" class="headerlink" title="CAP软件分类"></a>CAP软件分类</h3><ul>
<li>CP: MongoDB、HBase、Zookeeper; (paxos、raft、zab、2PC协议)</li>
<li>AP: Eureka、Couch DB、Cassandra、Amazon Dynamo</li>
<li>Raft (etcd)、ZAB(Zookeeper)</li>
</ul>
<h3 id="故障处理如何做？有以下模型可以考虑"><a href="#故障处理如何做？有以下模型可以考虑" class="headerlink" title="故障处理如何做？有以下模型可以考虑"></a>故障处理如何做？有以下模型可以考虑</h3><ul>
<li><p>Fail-Fast：从字面含义看就是“快速失败”，尽可能的发现系统中的错误，使系统能够按照事先设定好的错误的流程执行，对应的方式是“fault-tolerant（容错）”。只发起一次调用，失败立即报错,通常用于非幂等性的写操作。 如果有机器正在重启，可能会出现调用失败 。</p>
</li>
<li><p>Fail-Over：含义为“失效转移”，是一种备份操作模式，当主要组件异常时，其功能转移到备份组件。其要点在于有主有备，且主故障时备可启用，并设置为主。如Mysql的双Master模式，当正在使用的Master出现故障时，可以拿备Master做主使用。阿里同学认为这里可以指失败自动切换。当出现失败，重试其它服务器，通常用于读操作（推荐使用）。 重试会带来更长延迟。</p>
</li>
<li><p>Fail-Safe：含义为“失效安全”，即使在故障的情况下也不会造成伤害或者尽量减少伤害。维基百科上一个形象的例子是红绿灯的“冲突监测模块”当监测到错误或者冲突的信号时会将十字路口的红绿灯变为闪烁错误模式，而不是全部显示为绿灯。有时候来指代“自动功能降级” (Auto-Degrade)。阿里的同学认为失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。调用信息丢失 可用于生产环境Monitor。</p>
</li>
<li><p>Fail-Back：Fail-over之后的自动恢复，在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复。阿里的同学认为失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作 不可靠，重启丢失。可用于生产环境 Registry。</p>
</li>
<li><p>Forking  并行调用多个服务器，只要一个成功即返回，通常用于实时性要求较高的读操作。 需要浪费更多服务资源 。</p>
</li>
<li><p>Broadcast广播调用，所有提供逐个调用，任意一台报错则报错。通常用于更新提供方本地状态速度慢，任意一台报错则报错。</p>
</li>
<li><p>上述故障模型是从系统设计的角度出发的，根据不同的需要设计不同故障处理方案。现在看来，系统的外延已经扩大。系统的容错性，或者分区容错能力，不能仅仅使用事先和事中的方案解决，系统的容错性还包括事后处理。</p>
</li>
<li><p>分布式系统(Distributed System)资料:<a target="_blank" rel="noopener" href="https://github.com/ty4z2008/Qix/blob/master/ds.md">https://github.com/ty4z2008/Qix/blob/master/ds.md</a></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html">学习笔记：The Log（我所读过的最好的一篇分布式技术文章）</a></li>
<li>《分布式系统原理介绍刘杰》</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5626889.html">分布式系统理论之Quorum机制</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650738983&idx=4&sn=6d59ee01f70f2bff3df373dd9381e31f&chksm=bea760f489d0e9e">一文读懂拜占庭将军问题</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UfbMFXxJqRhLDXUntKVE8A">详解分布式一致性机制</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/90RAmLZcTshlm-MBjTlP0A">CAP理论与分布式系统设计</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IbBC38rhhQ-mEfw3yf9AVA">深度介绍分布式系统原理与设计</a>!!</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/05-ko4KyeHOTkrAbl8dQwQ">跨地域场景下，如何解决分布式系统的一致性？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KbNNU246BAeJmLoWbKie6g">左耳朵耗子：分布式系统架构经典资料</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/L7Zjbbub2D6pWto0TZ2qug">如何系统性的学习分布式系统？</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/17/20210917-tong-guo-pan-duan-ding-dan-zhuang-tai-shi-fou-ke-yi-bi-mian-bing-fa-dao-zhi-de-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/17/20210917-tong-guo-pan-duan-ding-dan-zhuang-tai-shi-fou-ke-yi-bi-mian-bing-fa-dao-zhi-de-wen-ti/" itemprop="url">通过判断订单状态是否可以避免并发导致的问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-17T17:17:35+08:00">
                2021-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>首先重温一个问题：<a target="_blank" rel="noopener" href="https://kingson4wu.github.io/2020/07/05/20200705-RPC%E5%8F%AF%E4%BB%A5%E5%92%8C%E4%BA%8B%E5%8A%A1%E7%BB%91%E5%AE%9A%E5%90%97/">RPC可以和事务绑定吗？</a></p>
</li>
<li><p>有以下业务场景：</p>
<ul>
<li>用户扣钱成功之后，可以玩一局游戏；如果用户没成功玩游戏，需要将已扣的钱退回给用户。</li>
</ul>
</li>
<li><p>服务架构：服务A(游戏服务)，服务B(用户资产服务)。</p>
</li>
<li><p>游戏订单状态：1（初始状态）；2（扣费成功）；3（退费成功）；4（不存在）</p>
</li>
<li><p>实现基本流程如下：</p>
</li>
<li><p>流程1:</p>
<pre>
玩游戏请求----------> 服务A
           [无事务] 
           [1.插入游戏订单（订单状态：1）]
           [2.RPC进行扣费]------------------------------------------------>服务B
           [3.更新游戏订单状态（1-> 2）(DB操作)] 
           （订单状态为2的可以参与游戏）</pre></li>
</ul>
<p></p>
<ul>
<li>流程2 （针对扣费成功但超时返回的情况）:<pre>
定时任务补偿----------> 服务A
           [无事务] 
           [1.查询订单状态为1的订单]
           [2.RPC查询扣费订单是否存在]------------------------------->服务B
           [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
           [3_2.存在 -- RPC取消扣费] ---------------------------------------->服务B
           [4.更新游戏订单状态（1-> 3）(DB操作)]</pre></li>
</ul>
<p></p>
<ul>
<li>流程1 和 流程2 在并发执行的时候会存在 用户退费成功但仍然可以玩游戏的问题：<ul>
<li>执行流程1中步骤2</li>
<li>执行流程2中步骤3_2</li>
<li>执行流程1中步骤3</li>
</ul>
</li>
</ul>
<h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h3><ul>
<li>加入订单时间校验：超过n分钟后的订单才允许退款（可以很大避免以上问题的发生，因为一个请求基本不可能执行几分钟还没结束）</li>
</ul>
<pre>
定时任务补偿----------> 服务A
             [无事务] 
             [0.查询订单状态为1的订单]
    新增判断 -   [1.查询订单创建时间是否超过n分钟，不满足暂不退款，中断执行] 
             [2.RPC查询扣费订单是否存在]------------------------------->服务B
             [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
             [3_2.存在 -- RPC取消扣费] ---------------------------------------->服务B
             [4.更新游戏订单状态（1-> 3）(DB操作)]
</pre>

<ul>
<li>该方案的缺点<ul>
<li>如果设置的订单退款超时时间太长，会导致用户被误扣的钱长时间未退款，引起投诉</li>
<li>设置足够合理的超时时间就一定能避免这个问题的发生了吗？不会存在极端情况，请求执行时间过长？</li>
</ul>
</li>
</ul>
<h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h3><ul>
<li>回到本文的标题。</li>
<li>通过和RPC绑事务的方式，也可以解决这个问题（不用通过配置时间差），本质是通过数据库锁的方式来解决。</li>
</ul>
<pre>
定时任务补偿----------> 服务A
             [1.查询订单状态为1的订单]
             [2.RPC查询扣费订单是否存在]------------------------------->服务B
             [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
             [新建事务] 
             [3_2.存在 -- 更新订单状态（1-> 3）(DB操作)]
             [ if （row = UPDATE order SET status = 3 WHERE status = 1) > 0 ]
             [4. RPC取消扣费] ---------------------------------------->服务B
             [5_1. 调用成功 - 提交事务]
             [5_1. 调用失败 - 异常回滚事务]
</pre>

<ol>
<li>扣费的时候，update order set status &#x3D; ’成功‘ where status &#x3D; ’初始状态‘ ；update raw &#x3D;&#x3D; 1 时， 执行RPC 冻结， 否则抛异常回滚事务</li>
<li>定时任务补偿退款的时候，update order set status &#x3D; ’取消冻结成功‘ where status &#x3D; ’初始状态‘ ；update row &#x3D;&#x3D; 1 时， 执行RPC 取消冻结， 否则抛异常回滚事务<ul>
<li>实际情况会比描述的复杂，因为status的最终值设置是根据RPC的结果来的，而不是一开始就能确定的；解决方案<ol>
<li>新加字段，统一 update 未执行 到 已执行， 通过新字段来判断是否执行db成功</li>
</ol>
</li>
</ul>
<ol start="2">
<li>select for update， 查的时候锁住该行数据</li>
<li>其他？</li>
</ol>
</li>
</ol>
<h3 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h3><ul>
<li>方案1和方案2的结合</li>
</ul>
<ol>
<li>1分钟后才执行流程2退费</li>
<li>流程2中【3_1】 和【4】绑事务，【4】变成update order set status&#x3D;3 where status&#x3D;1</li>
<li>流程1中【3】，变成 update order set status&#x3D;2 where status&#x3D;1</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/17/20210917-duo-idc-xia-wei-fu-wu-shu-ju-ru-he-tong-bu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/17/20210917-duo-idc-xia-wei-fu-wu-shu-ju-ru-he-tong-bu/" itemprop="url">多IDC下微服务数据如何同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-17T14:51:20+08:00">
                2021-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>最近公司出现跨机房调用redis超时导致的故障，借此简单记录一下微服务依赖的相关组件使用规范。</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li>每个服务的每个IDC对应一套Redis集群，原则上：<ul>
<li>不同服务不共用一套redis：避免业务相互影响，key定义冲突等问题；</li>
<li>不跨机房读写redis：避免不必要的时延等</li>
</ul>
</li>
<li>同个服务不同IDC的redis数据怎么同步？<ul>
<li>通过消息队列异地通知</li>
<li>如果一定要双写，异地IDC的同步尽量异步</li>
<li>如果一定要跨IDC读Redis，要控制好超时时间和降级</li>
</ul>
</li>
</ol>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>看具体业务选择合适的部署方式</li>
<li>数据不要求强一致，可覆盖的业务（比如用户基础信息），可以采用双活架构，MySQL使用双主架构，通过otter 同步数据</li>
<li>要求强一致，不可覆盖的业务（比如用户资产），可以采用主备架构，MySQL跨IDC搭建主从。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/9/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">143</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">156</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
