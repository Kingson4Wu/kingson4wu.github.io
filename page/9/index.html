<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="google-site-verification=n4yVkaTfu2KtQ8fiQ3Ri60FPAbRF74oxrDOkOXWjhSs" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="Kingson Wu的技术博客，分享编程、架构、AI等技术笔记和个人思考">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="https://kingson4wu.github.io/page/9/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="Kingson Wu的技术博客，分享编程、架构、AI等技术笔记和个人思考">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta property="article:tag" content="技术博客,编程,架构,软件开发,AI,人工智能,后端开发,Java,Go,系统设计">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kingson4wu.github.io/page/9/"/>





  <title>拉巴力的纸皮箱 - 技术博客 | 记录学习笔记和思考</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-4QEGQ2DGGT', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">技术博客 | 记录学习笔记和思考</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/09/07/20220907-tcp-lian-jie-zhong-de-ge-chong-zhuang-tai/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/07/20220907-tcp-lian-jie-zhong-de-ge-chong-zhuang-tai/" itemprop="url">TCP连接中的各种状态</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-07T20:36:01+08:00">
                2022-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2022/09/07/20220907-tcp-lian-jie-zhong-de-ge-chong-zhuang-tai/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<p><img src="/2022/09/07/20220907-tcp-lian-jie-zhong-de-ge-chong-zhuang-tai/TCP%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.png"></p>
<h2 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h2><ul>
<li>CLOSED：无连接是活动的或正在进行</li>
<li>LISTEN：服务器在等待进入呼叫</li>
<li>SYN_RECV：一个连接请求已经到达，等待确认</li>
<li>SYN_SENT：应用已经开始，打开一个连接</li>
<li>ESTABLISHED：正常数据传输状态</li>
<li>FIN_WAIT1：应用说它已经完成</li>
<li>FIN_WAIT2：另一边已同意释放</li>
<li>ITMED_WAIT：等待所有分组死掉</li>
<li>CLOSING：两边同时尝试关闭</li>
<li>TIME_WAIT：另一边已初始化一个释放</li>
<li>LAST_ACK：等待所有分组死掉</li>
</ul>
<h3 id="flags-标志"><a href="#flags-标志" class="headerlink" title="flags 标志"></a>flags 标志</h3><ul>
<li>S(SYN)</li>
<li>F(FIN)</li>
<li>P(PUSH)</li>
<li>R(RST)</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机上的TCP连接状态"><a href="#查看主机上的TCP连接状态" class="headerlink" title="查看主机上的TCP连接状态"></a>查看主机上的TCP连接状态</h3><ul>
<li><code>netstat –an</code></li>
<li><code>netstat –an |grep &#39;CLOSE_WAIT&#39;</code></li>
<li><code>ss -t -n|grep 5000</code></li>
</ul>
<h3 id="统计当前各种状态的连接的数量的命令"><a href="#统计当前各种状态的连接的数量的命令" class="headerlink" title="统计当前各种状态的连接的数量的命令"></a>统计当前各种状态的连接的数量的命令</h3><ul>
<li><code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code></li>
</ul>
<h3 id="查看指定端口的连接"><a href="#查看指定端口的连接" class="headerlink" title="查看指定端口的连接"></a>查看指定端口的连接</h3><ul>
<li><code>netstat -an | awk &#39;NR==2 || $4~/65016/&#39;</code>（client）</li>
<li><code>netstat -an | awk &#39;NR==2 || $5~/8080/&#39;</code>（server）</li>
</ul>
<h3 id="Linux-netstat命令详解"><a href="#Linux-netstat命令详解" class="headerlink" title="Linux netstat命令详解"></a>Linux netstat命令详解</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html</a></li>
</ul>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><ul>
<li><p>想知道我们可以通过哪几个网卡抓包，可以使用-D参数 : <code>tcpdump –D</code></p>
</li>
<li><p>将抓包结果存放在文件中(可以用Wireshark打开查看) : <code>tcpdump –w google.cap</code></p>
</li>
<li><p>其中http协议的数据包都给过滤出来: <code>tcpdump –r google.cap http</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhuimengle/p/5737848.html">http://www.cnblogs.com/zhuimengle/p/5737848.html</a></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="http://elf8848.iteye.com/blog/1739571">TCP&#x2F;IP TIME_WAIT状态原理</a></li>
</ul>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunhua_lee/article/details/40513677">tcp 三次握手和四次断连深入分析：连接状态和socket API的关系</a><ul>
<li>close函数其实本身不会导致tcp协议栈立刻发送fin包，而只是将socket文件的引用计数减1，当socket文件的引用计数变为0的时候，操作系统会自动关闭tcp连接，此时才会发送fin包。</li>
<li>这也是多进程编程需要特别注意的一点，父进程中一定要将socket文件描述符close，否则运行一段时间后就可能会出现操作系统提示too many open files</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/09/07/20220907-time-wait-jie-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/07/20220907-time-wait-jie-xi/" itemprop="url">TIME_WAIT解析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-07T13:30:37+08:00">
                2022-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2022/09/07/20220907-time-wait-jie-xi/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpeg"></p>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><ul>
<li>通信双方建立TCP连接后，主动关闭(FIN)连接的一方就会进入TIME_WAIT状态<ul>
<li>客户端主动关闭连接时，发送最后一个ack后，会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态</li>
</ul>
</li>
</ul>
<h2 id="TIME-WAIT状态存在的理由"><a href="#TIME-WAIT状态存在的理由" class="headerlink" title="TIME_WAIT状态存在的理由"></a>TIME_WAIT状态存在的理由</h2><ol>
<li><p>可靠地实现TCP全双工连接的终止</p>
<ul>
<li>TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。</li>
<li>因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。</li>
<li>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIMEWAIT状态停留的时间为2倍的MSL。这样可尽可能让TCP再次发送最后的ACK以防这个ACK丢失(另一端超时并重发最后的FIN)。</li>
<li>总结：尽量避免主动关闭方ack丢失导致被关闭方异常（理论上从应用层看，被关闭方需要对这种异常进行处理，因为万一主动关闭方断电了呢）</li>
</ul>
</li>
<li><p>允许老的重复分节在网络中消逝</p>
<ul>
<li>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，基本可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。</li>
<li>IP包的最大生存时间记录在其TTL字段中，即MSL，超过将过期丢弃</li>
</ul>
</li>
</ol>
<h2 id="MSL时间"><a href="#MSL时间" class="headerlink" title="MSL时间"></a>MSL时间</h2><ul>
<li>MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。<br>TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段  </li>
<li>TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。</li>
<li>为什么需要2MSL？<ul>
<li>第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，同时让旧的数据包基本在网络中消失；</li>
<li>第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失（主要目的）</li>
<li>问题：重传的FIN报文会重传多少次？<ul>
<li>重发次数由 tcp_orphan_retries 参数控制</li>
</ul>
</li>
<li>所以如果最后一个ack丢了，且对端又重试发FIN，那么还是无法避免FIN包没过期，所以2MSL只是尽可能，但这时旧的数据包基本消失了</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>TIME_WAIT主动关闭方的状态  </li>
<li>TIME_WAIT存在的原因<ol>
<li>防止主动关闭方最后的ACK丢失，确保远程TCP接收到连接中断的请求</li>
<li>允许老的重复数据包在网络中过期</li>
</ol>
</li>
</ul>
<h2 id="TIME-WAIT产生的场景"><a href="#TIME-WAIT产生的场景" class="headerlink" title="TIME_WAIT产生的场景"></a>TIME_WAIT产生的场景</h2><ul>
<li>进入TIME_WAIT状态的一般情况下是客户端。</li>
<li>大多数服务器端一般执行被动关闭，服务器不会进入TIME_WAIT状态。<br>但在服务器端关闭某个服务再重新启动时，服务器是会进入TIME_WAIT状态的。<br>可以使用SO_REUSEADDR选项来复用端口。</li>
</ul>
<pre>
举例：
1.客户端连接服务器的80服务，这时客户端会启用一个本地的端口访问服务器的80，访问完成后关闭此连接，立刻再次访问服务器的
80，这时客户端会启用另一个本地的端口，而不是刚才使用的那个本地端口。原因就是刚才的那个连接还处于TIME_WAIT状态。
2.客户端连接服务器的80服务，这时服务器关闭80端口，立即再次重启80端口的服务，这时可能不会成功启动，原因也是服务器的连
接还处于TIME_WAIT状态。
</pre>

<h2 id="作为客户端和服务器"><a href="#作为客户端和服务器" class="headerlink" title="作为客户端和服务器"></a>作为客户端和服务器</h2><ol>
<li>服务端提供服务时，一般监听一个端口就够了；</li>
<li>客户端则是使用一个本地的空闲端口（大于1024），与服务器的端口建立连接；<ul>
<li>如果使用短连接请求，那么客户端将会产生大量TIME_WAIT状态的端口（本地最多就能承受6万个TIME_WAIT状态的连接就无端口可用了，后续的短连接就会产生address already in use : connect的异常）</li>
<li>因此，作为短连接请求的压测服务器，不能在短时间连续使用；</li>
<li>一般来说一台机器可用Local Port 3万多个，如果是短连接的话，一个连接释放后默认需要60秒回收，30000&#x2F;60 &#x3D;500 这是大概的理论TPS值</li>
</ul>
</li>
<li>一个提供高并发的服务器，同时依赖第三方服务（间接看来服务端也作为第三方服务的客户端），怎么应对 ？<ul>
<li>一般情况都是启用keepalive选项，避免短连接服务（一般依赖方也不会多达几千个，即调用的ip和端口不一样）</li>
<li>启用SO_REUSEADDR选项</li>
</ul>
</li>
<li>大多数服务器端一般执行被动关闭，服务器不会进入TIME_WAIT状态</li>
</ol>
<h2 id="如何复用TIME-WAIT端口"><a href="#如何复用TIME-WAIT端口" class="headerlink" title="如何复用TIME_WAIT端口"></a>如何复用TIME_WAIT端口</h2><ol>
<li>应用层发出请求前指定，如何Java HttpClient中设置reuseaddr<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpClient.setHttpRequestRetryHandler(<span class="keyword">new</span> <span class="title class_">DefaultHttpRequestRetryHandler</span>());</span><br><span class="line">httpClient.setReuseStrategy(<span class="keyword">new</span> <span class="title class_">DefaultConnectionReuseStrategy</span>());</span><br><span class="line">httpClient.setKeepAliveStrategy(<span class="keyword">new</span> <span class="title class_">DefaultConnectionKeepAliveStrategy</span>());</span><br></pre></td></tr></table></figure></li>
<li>调整内核参数（net.ipv4.tcp_tw_reuse）</li>
</ol>
<h2 id="总结避免TIME-WAIT的方法"><a href="#总结避免TIME-WAIT的方法" class="headerlink" title="总结避免TIME_WAIT的方法"></a>总结避免TIME_WAIT的方法</h2><ol>
<li>使用长连接（基本大部分业务场景都可以）</li>
<li>避免主动关闭</li>
<li>关闭的时候使用RST的方式 （比如程序中设置socket的SO_LINGER选项）(应用层貌似不是很方便实现)</li>
<li>TIME_WAIT状态的TCP允许重用</li>
<li>增大可用端口范围，默认是 net.ipv4.ip_local_port_range &#x3D; 32768 61000 （即对同一个服务器的ip+port可创建28233个连接）（只能缓解问题，不能根本解决问题）</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/elf8848-1739571">TCP&#x2F;IP TIME_WAIT状态原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/kerry/105233">发现大量的TIME_WAIT解决办法</a></li>
<li>[《TCP IP详解卷一》18.6.1]</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LNWv5I-klJCBCX4e84WbTQ">为什么 TCP 协议有 TIME_WAIT 状态</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joker1937/articles/12487776.html">TCP四次挥手为何需要TIME_WAIT以及为何是2MSL？</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398890723">TCP 才不傻：三次握手和四次挥手的异常处理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.helloworld.net/p/4875307437">tcp短连接TIME_WAIT问题解决方法大全</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/09/07/20220907-ni-ji-de-she-zhi-tcp-nodeplay-ma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/07/20220907-ni-ji-de-she-zhi-tcp-nodeplay-ma/" itemprop="url">你记得设置TCP_NODEPLAY吗？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-07T13:26:22+08:00">
                2022-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>有接触过TCP服务器实现的同学都会知道，需要注意TCP_NODELAY参数，为什么呢？</p>
</li>
<li><p>若没有开启TCP_NODELAY，那么在发送小包的时候，可能会出现这样的现象：<br>通过 TCP socket 分多次发送较少的数据时，比如小于 1460 或者 100 以内，对端可能会很长时间收不到数据，导致本端应用程序认为超时报错。</p>
</li>
</ul>
<h2 id="Nagle算法（Nagle‘s-Algorithm）"><a href="#Nagle算法（Nagle‘s-Algorithm）" class="headerlink" title="Nagle算法（Nagle‘s Algorithm）"></a>Nagle算法（Nagle‘s Algorithm）</h2><ul>
<li><p>TCP&#x2F;IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP&#x2F;IP希望每次都能够以MSS尺寸的数据块来发送数据）。</p>
</li>
<li><p>Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p>
</li>
<li><p>Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p>
</li>
<li><p>举个例子，一开始client端调用socket的write操作将一个int型数据(称为A块)写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入一个int型数据（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后）(ACK延迟机制的超时时间)，B块才被发送。</p>
</li>
<li><p>Nagle算法的改进在于：如果发送端欲多次发送包含少量字符的数据包（一般情况下，后面统一称长度小于MSS的数据包为小包，与此相对，称长度等于MSS的数据包为大包，为了某些对比说明，还有中包，即长度比小包长，但又不足一个MSS的包），则发送端会先将第一个小包发送出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据，或者积攒到了一定数量的数据（比如缓存的字符数据已经达到数据包报文段的最大长度）等多种情况才将其组成一个较大的数据包发送出去。<br> TCP在三次握手建立连接过程中，会在SYN报文中使用MSS（Maximum Segment Size）选项功能，协商交互双方能够接收的最大段长MSS值。</p>
</li>
</ul>
<h2 id="ACK延迟机制-TCP-Delayed-Acknoledgement"><a href="#ACK延迟机制-TCP-Delayed-Acknoledgement" class="headerlink" title="ACK延迟机制(TCP Delayed Acknoledgement)"></a>ACK延迟机制(TCP Delayed Acknoledgement)</h2><ul>
<li>TCP&#x2F;IP中不仅仅有Nagle算法(Nagle‘s Algorithm)，还有一个ACK延迟机制(TCP Delayed Ack) 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。</li>
<li>也就是如果一个 TCP 连接的一端启用了Nagle算法，而另一端启用了ACK延时机制，而发送的数据包又比较小，则可能会出现这样的情况：发送端在等待接收端对上一个packet的Ack才发送当前的packet，而接收端则正好延迟了此Ack的发送，那么这个正要被发送的packet就会同样被延迟。当然Delayed Ack是有个超时机制的，而默认的超时正好就是40ms。</li>
<li>现代的 TCP&#x2F;IP 协议栈实现，默认几乎都启用了这两个功能，那岂不每次都会触发这个延迟问题？事实不是那样的。仅当协议的交互是发送端连续发送两个packet，然后立刻read的时候才会出现问题。</li>
</ul>
<h2 id="总结：问题出现的三个条件"><a href="#总结：问题出现的三个条件" class="headerlink" title="总结：问题出现的三个条件"></a>总结：问题出现的三个条件</h2><ol>
<li>发送小包（仅当协议的交互是发送端连续发送两个 packet，然后立刻 read 的 时候才会出现问题。）</li>
<li>发送方启用了Nagle算法（发送方未接收到上一个包的ack，且待发送的是小包，则会等待）</li>
<li>接收方启用了ACK延时机制 且没及时准备好数据（希望响应ack可以和响应的数据一起发送，等待本端响应数据的准备）</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>开启TCP_NODELAY：禁用Nagle算法，禁止后当然就不会有它引起的一系列问题了。</li>
<li>优化协议：连续 write 小数据包，然后 read 其实是一个不好的网络编程模式，这样的连续 write 其实应该在应用层合并成一次 write。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="另一个问题的例子-HTTP服务"><a href="#另一个问题的例子-HTTP服务" class="headerlink" title="另一个问题的例子(HTTP服务)"></a>另一个问题的例子(HTTP服务)</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1621142">神秘的40毫秒延迟与TCP_NODELAY</a></p>
</li>
<li><p>接口响应时间在client端开启keepalive后连续请求时由0ms变成40ms</p>
</li>
<li><p>因为设计的一些不足，我没能做到把 短小的 HTTP Body 连同 HTTP Headers 一起发送出去，而是分开成两次调用实 现的，之后进入 epoll_wait 等待下一个 Request 被发送过来（相当于阻塞模 型里直接 read）。正好是 write-write-read 的模式</p>
</li>
<li><p>那么 write-read-write-read 会不会出问题呢？维基百科上的解释是不会：</p>
<ul>
<li>“The user-level solution is to avoid write-write-read sequences on sockets. write-read-write-read is fine. write-write-write is fine. But write-write-read is a killer. So, if you can, buffer up your little writes to TCP and send them all at once. Using the standard UNIX I&#x2F;O package and flushing write before each read usually works.”</li>
<li>我的理解是这样的：因为第一个 write 不会被缓冲，会立刻到达接收端，如果是 write-read-write-read 模式，此时接收端应该已经得到所有需要的数据以进行 下一步处理。接收端此时处理完后发送结果，同时也就可以把上一个packet 的 Ack 可以和数据一起发送回去，不需要 delay，从而不会导致任何问题。</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/majianfei1023/article/details/51558941">TCP_NODELAY和Nagle算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/09/06/20220906-you-liao-tcp-de-keepalive-ying-yong-ceng-huan-xu-yao-shi-xian-bao-huo-luo-ji-ma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/06/20220906-you-liao-tcp-de-keepalive-ying-yong-ceng-huan-xu-yao-shi-xian-bao-huo-luo-ji-ma/" itemprop="url">有了TCP的keepalive，应用层还需要实现保活逻辑吗？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-06T22:02:39+08:00">
                2022-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>对于实时性高的业务，基本都需要在应用层自行实现保活逻辑，应用层的心跳协议是必不可少的</li>
</ul>
<h2 id="TCP-keepalive-的-问题"><a href="#TCP-keepalive-的-问题" class="headerlink" title="TCP keepalive 的 问题"></a>TCP keepalive 的 问题</h2><ol>
<li>检测周期长，开启后默认是2h（系统内核参数 tcp_keepalive_time），这就意味着服务端可能维持着一个死连接；</li>
<li>TCP keepalive 是由操作系统负责探查，即便进程死锁，或阻塞等，操作系统也会收发 TCP keepalive 消息，无法及时感知客户端已经实际已经下线；</li>
</ol>
<h2 id="应用层实现心跳的基本做法"><a href="#应用层实现心跳的基本做法" class="headerlink" title="应用层实现心跳的基本做法"></a>应用层实现心跳的基本做法</h2><ol>
<li>服务端和客户端都开启tcp keepalive</li>
<li>客户端定时发心跳包到服务端</li>
<li>服务端根据自定义的规则，在一定时间内收不到心跳包的时，断开客户端的连接。</li>
</ol>
<h2 id="应用层实现心跳保活逻辑的好处"><a href="#应用层实现心跳保活逻辑的好处" class="headerlink" title="应用层实现心跳保活逻辑的好处"></a>应用层实现心跳保活逻辑的好处</h2><ol>
<li>可以在发送心跳包的同时顺带业务或指令数据，这样服务端获得客户端的详细状态，同时可以更好满足业务场景</li>
<li>可以灵活控制探查客户端的时间和策略，更快下线有异常的连接，减少服务端不必要的负担</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.zhihu.com/question/35013918">在以TCP为连接方式的服务器中，为什么在服务端设计当中需要考虑心跳？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.felix021.com/blog/read.php?2076">闲说HeartBeat心跳包和TCP协议的KeepAlive机制</a></li>
<li><a target="_blank" rel="noopener" href="http://www.nowamagic.net/academy/detail/23350382">TCP协议的KeepAlive机制与HeartBeat心跳包</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/09/05/20220905-guan-yu-http-xiang-guan-xie-yi-de-yi-xie-zong-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/05/20220905-guan-yu-http-xiang-guan-xie-yi-de-yi-xie-zong-jie/" itemprop="url">关于HTTP相关协议的一些总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-05T22:01:12+08:00">
                2022-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="粗浅概括"><a href="#粗浅概括" class="headerlink" title="粗浅概括"></a>粗浅概括</h2><ul>
<li>HTTP - TCP</li>
<li>HTTPS - TCP + TLS </li>
<li>SPDY -&gt; TCP + TLS + 多路复用、头部压缩等特性 –&gt; 发展成 HTTP&#x2F;2<ul>
<li>SPDY是Speedy的音，是更快的意思</li>
</ul>
</li>
<li>HTTP&#x2F;2 - TCP + TLS(理论上可选) + 多路复用、头部压缩等特性</li>
<li>QUIC - UDP –&gt; 发展成 HTTP&#x2F;3</li>
<li>HTTP&#x2F;3 - UDP</li>
</ul>
<h2 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h2><ul>
<li>RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>请求-响应模式（半双工）</li>
</ul>
<ul>
<li>安全问题</li>
</ul>
<h3 id="“队头堵塞”-（线头阻塞）（Head-of-line-blocking）（HOLB）"><a href="#“队头堵塞”-（线头阻塞）（Head-of-line-blocking）（HOLB）" class="headerlink" title="“队头堵塞” （线头阻塞）（Head-of-line blocking）（HOLB）"></a>“队头堵塞” （线头阻塞）（Head-of-line blocking）（HOLB）</h3><ul>
<li>HTTP 1.1 默认启用长TCP连接，但所有的请求-响应都是按序进行的(串行发送和接收)</li>
<li>HTTP 1.1 的管道机制：客户端可以同时发送多个请求，但服务端也需要按请求的顺序依次给出响应的；</li>
<li>客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求(排队等待)，这称为”队头堵塞”</li>
</ul>
<h3 id="管道机制-Pipelining"><a href="#管道机制-Pipelining" class="headerlink" title="管道机制(Pipelining)"></a>管道机制(Pipelining)</h3><ul>
<li>在管道机制下，服务端如何控制按顺序返回响应的？<ul>
<li>HTTP是应用层协议，当然由各个应用程序按照规范自行实现了</li>
<li>比如使用nginx，或jetty等，若服务端需要支持管道机制，都要底层逻辑自行实现，避免暴露给业务层</li>
<li>那么因为要按顺序响应，那么当最前的请求的处理较慢时，同样会对服务端产生阻塞。</li>
</ul>
</li>
<li>Pipelining需要客户端和服务端同时支持</li>
<li>几乎所有的浏览器都是默认关闭或者不支持Pipelining的：对性能的提高有限、大文件会阻塞优先级更高的小文件等</li>
<li>只有GET和HEAD要求可以进行管线化，而POST则有所限制</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li><p>HTTPS（HTTP over TLS&#x2F;SSL）,TLS&#x2F;SSL(会话层)</p>
</li>
<li><p>SSL（Secure Socket Layer）是安全套接层，TLS（Transport Layer Security）是传输层安全协议，建立在SSL3.0协议规范，是 SSL3.0 的后续版本。</p>
</li>
<li><p>TLS可以用在TCP上，也可以用在无连接的UDP报文上。协议规定了身份认证、算法协商、密钥交换等的实现。</p>
</li>
<li><p>SSL是TLS的前身，现在已不再更新</p>
</li>
</ul>
<h3 id="jks、pfx和cer-证书文件"><a href="#jks、pfx和cer-证书文件" class="headerlink" title="jks、pfx和cer 证书文件"></a>jks、pfx和cer 证书文件</h3><ul>
<li>jks是JAVA的keytools证书工具支持的证书私钥格式。</li>
<li>pfx是微软支持的私钥格式。</li>
<li>cer是证书的公钥。</li>
</ul>
<h3 id="权威证书颁发的公钥匙一般是预装的"><a href="#权威证书颁发的公钥匙一般是预装的" class="headerlink" title="权威证书颁发的公钥匙一般是预装的"></a>权威证书颁发的公钥匙一般是预装的</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yungyu16/p/13329305.html">SSL&#x2F;TLS协议详解(中)——证书颁发机构</a></p>
</li>
<li><p>当我们安装浏览器或操作系统时，将会附有一组证书颁发机构，例如DigiCert。当浏览器自带DigiCert时，这意味着浏览器具有DigiCert的公钥，网站可以向DigiCert索取证书和签名。因此，DigiCert将使用DigiCerts私钥在服务器证书上进行加密签名。当我们发起连接时，服务器将发送嵌入了其公钥的证书。由于浏览器具有DigiCert的公钥，因此可以在服务器证书上验证DigiCert的签名，同时也说明证书上写的服务器的公钥是可信的。</p>
</li>
<li><p>根据RSA的加密原理，如果用CA的公钥解密成功，说明该证书的确是用CA的私钥加密的，可以认为被验证方是可信的。</p>
</li>
</ul>
<h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><ul>
<li>全双工</li>
<li>二进制格式传输、多路复用、header压缩、服务端推送、优先级和依赖关系、重置、流量控制</li>
</ul>
<h3 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用(Multiplexing)"></a>多路复用(Multiplexing)</h3><ul>
<li>客户端发送多个请求和服务端给出多个响应的顺序不受限制, 避免”队头堵塞” </li>
<li>每个数据流都有一个唯一的编号，从而让请求和响应对应起来</li>
<li>客户端和服务器 可以发生信号取消某个数据流，并保持这个连接</li>
<li>客户端还可以提升提升某个数据流优先级</li>
</ul>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li>HTTP&#x2F;2 沒规定一定要使用加密（例如 SSL），但目前大部分浏览器的 HTTP&#x2F;2 都需要在 HTTPs上运行</li>
<li>gRPC 虽然使用 HTTP&#x2F;2，但默认并没有需要配置加密证书</li>
</ul>
<h3 id="重用连接（针对浏览器）"><a href="#重用连接（针对浏览器）" class="headerlink" title="重用连接（针对浏览器）"></a>重用连接（针对浏览器）</h3><ul>
<li>使用HTTP1.1协议，浏览器为了快速，针对同一域名设置了一定的并发数，稍微加快速度</li>
<li>使用HTTP&#x2F;2，浏览器针对同一个域名的资源，只建立一个tcp连接通道</li>
</ul>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><ul>
<li>头部压缩也存在一些缺点 ，不管是Client还是Server，都要维护索引表，以确定每个索引值对应HTTP header的信息，通过占用更多内存换取数据量传输的减少（空间换时间）。</li>
</ul>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyogMagLsm2jh2pgg0Symw">Chrome将禁用HTTP&#x2F;2服务器推送（Server Push）支持</a><ul>
<li>这功能逻辑本身就有问题，比如资源存放在单个业务服务器上，并行推送多个静态资源只会降低响应速度，性能不升反降。而对于前后端分离的业务来说，HTTP&#x2F;2 本身就支持多路复用，server push 只能稍微降低浏览器解析 html 的时间，对现代浏览器来说性能提升可以忽略不计。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul>
<li><p>HTTP&#x2F;1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</p>
</li>
<li><p>HTTP&#x2F;2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</p>
</li>
<li><p>QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</p>
</li>
<li><p>HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成：HTTP3.0基于UDP的安全可靠的HTTP2.0协议。</p>
</li>
<li><p>在网络条件较差的情况下，HTTP&#x2F;3在增强网页浏览体验方面的效果非常好 </p>
</li>
<li><p>TCP从来就不适合处理有损无线环境中的数据传输</p>
</li>
<li><p>TCP中的行头阻塞</p>
</li>
</ul>
<h3 id="TCP的限制"><a href="#TCP的限制" class="headerlink" title="TCP的限制"></a>TCP的限制</h3><ol>
<li>TCP可能会间歇性地挂起数据传输<ul>
<li>TCP流的行头阻塞（HoL）: 序列号较低的数据段丢包问题，导致阻塞</li>
</ul>
</li>
<li>TCP不支持流级复用</li>
<li>TCP会产生冗余通信<ul>
<li>TCP连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。</li>
</ul>
</li>
</ol>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul>
<li>选择UDP作为底层传输层协议。抛弃TCP的缺点（TCP传输确认、重传慢启动等），同时。此外QUIC是用户层协议，不需要每次协议升级时修改内核；</li>
<li>流复用和流控：解决了行头阻塞问题。</li>
<li>灵活的拥塞控制机制、更好的错误处理能力、更快的握手</li>
<li>新的HTTP头压缩机制，称为QPACK，是对HTTP&#x2F;2中使用的HPACK的增强（QUIC流是不按顺序传递的，在不同的流中可能包含不同的HTTP头）</li>
</ul>
<h3 id="采用HTTP-x2F-3的限制"><a href="#采用HTTP-x2F-3的限制" class="headerlink" title="采用HTTP&#x2F;3的限制"></a>采用HTTP&#x2F;3的限制</h3><ul>
<li>不仅涉及到应用层的变化，还涉及到底层传输层的变化</li>
<li>UDP会话会被防火墙的默认数据包过滤策略所影响</li>
<li>中间层，如防火墙、代理、NAT设备等需要兼容</li>
<li>需迫使中间层厂商标准化</li>
<li>HTTP&#x2F;3在现有的UDP之上，以QUIC的形式在传输层处理，增加了HTTP&#x2F;3在整个协议栈中的占用空间。这使得HTTP&#x2F;3较为笨重，不适合某些IoT设备</li>
<li>NGINX和Apache等主流web服务器需要支持</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="HTTP-与-TCP-backlog关系"><a href="#HTTP-与-TCP-backlog关系" class="headerlink" title="HTTP 与 TCP backlog关系"></a>HTTP 与 TCP backlog关系</h3><ol>
<li>没直接关系</li>
<li>HTTP是应用层协议，TCP backlog 是应用程序在操作系统层接收tcp连接的队列数</li>
<li>比如tomcat，作为一个HTTP应用服务，TCP backlog对应其acceptCount的配置</li>
</ol>
<h3 id="关于-HTTP-keepalive"><a href="#关于-HTTP-keepalive" class="headerlink" title="关于 HTTP keepalive"></a>关于 HTTP keepalive</h3><ul>
<li><p>要利用HTTP的keep-alive机制，需要服务器端和客户端同时支持</p>
</li>
<li><p>HTTP是应用层协议，具体的表现行为取决于HTTP服务器以及HTTP client的实现</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kingson_Wu/article/details/72512825">wireshark抓包简单查看HTTP keep-alive原理</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kingson_Wu/article/details/80102077">继续深入理解HTTP keepalive</a></p>
</li>
</ul>
<ol>
<li>keepalive 是否开启服务端控制还是客户端控制？<ul>
<li>keepalive可以由双方共同控制，需要双方都开启才能生效，HTTP1.1客户端默认开启，客户端想关闭可以通过设置Connection: Close，服务端同样想关闭可以设置Connection: Close。双方哪方先收到Connection: Close 则由收到方关闭（前提是双方的实现都支持，比如telnet就不支持）</li>
</ul>
</li>
<li>keepalive的时间是由服务端控制还是客户端控制？<ul>
<li>时间主要还是由服务端控制，时间一到由服务端主动关闭，当然客户端如果有实现设置一定时间后，由客户端主动关闭也可以。一般的HTTPclient库都有提供相应的配置，设置关闭长期不使用的连接，如connectionManager.closeIdleConnections(readTimeout * 2, TimeUnit.MILLISECONDS);</li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/greki/blog/83350">HTTPs://my.oschina.net/greki/blog/83350</a></li>
</ul>
</li>
<li>keepalive时间一到，是由客户端主动关闭还是服务端主动关闭？<ul>
<li>哪方的时间短，由哪一方来关闭，除非双方的实现有更明确的协议</li>
</ul>
</li>
<li>如果客户端不是HTTPclient，使用telnet连接服务端？<ul>
<li>telnet客户端除了连接时进行三次握手，用来发送数据接收数据，基本无其他实现逻辑。即接收到服务器的响应之后，不会有相关HTTP协议的处理。</li>
</ul>
</li>
</ol>
<h3 id="HTTP-keepalive-VS-TCP-keepalive"><a href="#HTTP-keepalive-VS-TCP-keepalive" class="headerlink" title="HTTP keepalive VS TCP keepalive"></a>HTTP keepalive VS TCP keepalive</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385597183">HTTPs://zhuanlan.zhihu.com/p/385597183</a>; <a target="_blank" rel="noopener" href="https://juejin.cn/post/6992845852192702477">HTTPs://juejin.cn/post/6992845852192702477</a></li>
<li>HTTP 的 Keep-Alive，是由应用层（用户态）  实现的，称为 HTTP 长连接；</li>
<li>TCP 的 Keepalive，是由 TCP 层（内核态）  实现的，称为 TCP 保活机制；</li>
<li>HTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求&#x2F;响应。</li>
<li>TCP的KeepAlive机制意图在于保活、心跳，检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。</li>
<li>tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而HTTP的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。</li>
<li>总之，HTTP的Keep-Alive和TCP的KeepAlive不是一回事。</li>
</ul>
<h3 id="Chrome中HTTP下载续传原理"><a href="#Chrome中HTTP下载续传原理" class="headerlink" title="Chrome中HTTP下载续传原理"></a>Chrome中HTTP下载续传原理</h3><ul>
<li><a href="https://kingson4wu.github.io/2022/08/30/20220830-Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6%E6%9A%82%E5%81%9C%E5%92%8C%E7%BB%A7%E7%BB%AD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/">Chrome下载文件时暂停和继续是什么原理？</a></li>
</ul>
<h3 id="HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？"><a href="#HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？" class="headerlink" title="HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？"></a>HTTP连接复用时，同一个连接上的多个请求和响应如何对应上？</h3><ul>
<li>“队头堵塞”（Head-of-line blocking）：所有的请求-响应都是按序进行的（HTTP）</li>
<li>多路复用(Multiplexing)：每个数据流都有一个唯一的编号，从而让请求和响应对应起来（HTTP&#x2F;2）</li>
</ul>
<h3 id="可以外网使用HTTP-x2F-3，再转发到内网的HTTP服务？"><a href="#可以外网使用HTTP-x2F-3，再转发到内网的HTTP服务？" class="headerlink" title="可以外网使用HTTP&#x2F;3，再转发到内网的HTTP服务？"></a>可以外网使用HTTP&#x2F;3，再转发到内网的HTTP服务？</h3><ul>
<li>上层nginx使用HTTP3，下层应用服务器（如spring boot jetty等）还是使用HTTP，其实理论上是可以的。nginx转发时要由接受到的udp包改成tcp发送。（内网丢包概率一般应该比外网丢包低很多），如果采用这种转发方式，这就意味着内网无法使用四层负载转发，因为底层协议不一样（udp和tcp）</li>
<li>现在主流的代理服务Nginx&#x2F;Apache都没有实现QUIC，一些比较小众的代理服务如Caddy就实现了</li>
</ul>
<h3 id="使用HTTPS还存在中间人攻击？"><a href="#使用HTTPS还存在中间人攻击？" class="headerlink" title="使用HTTPS还存在中间人攻击？"></a>使用HTTPS还存在中间人攻击？</h3><ul>
<li><p>结论：可以避免。只要不信任不安全的HTTPs网站，就不会被中间人攻击</p>
</li>
<li><p>中间人攻击:<a target="_blank" rel="noopener" href="https://urlify.cn/zQj6f2">HTTPs://urlify.cn/zQj6f2</a></p>
</li>
<li><p>既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？<br>其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。</p>
</li>
<li><p>只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。</p>
</li>
</ul>
<pre>
Q: 为什么需要证书？
A: 防止”中间人“攻击，同时可以为网站提供身份证明。

Q: 使用 HTTPS 会被抓包吗？
A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。
</pre> 

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="cURL-发-HTTP-x2F-2请求"><a href="#cURL-发-HTTP-x2F-2请求" class="headerlink" title="cURL 发 HTTP&#x2F;2请求"></a>cURL 发 HTTP&#x2F;2请求</h3><ol>
<li>Mac OS Curl HTTP&#x2F;2 支持<br><code> brew install curl --with-ngHTTP2</code></li>
</ol>
<pre>
/usr/local/Cellar/curl/7.50.3/bin/curl --HTTP2 -kI  HTTPs://localhost:8443/user/1
HTTP/2 200
server: Jetty(9.3.10.v20160621)
date: Sun, 30 Oct 2016 02:08:46 GMT
content-type: application/json;charset=UTF-8
content-length: 23
</pre>

<ol start="2">
<li>linux:<a target="_blank" rel="noopener" href="https://www.sysgeek.cn/curl-with-HTTP2-support/">HTTPs://www.sysgeek.cn/curl-with-HTTP2-support/</a></li>
</ol>
<h3 id="HTTP-x2F-3-握手优化"><a href="#HTTP-x2F-3-握手优化" class="headerlink" title="HTTP&#x2F;3 握手优化"></a>HTTP&#x2F;3 握手优化</h3><ul>
<li>1倍时延 &#x3D; 一次单向传输时延 &#x3D; 0.5 RTT</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Xo9HgZXfn28VibIE9OFHqw">HTTPS 的 7 次握手以及 9 倍时延</a></li>
<li>HTTPS: 7 次握手以及 9 倍时延 (4.5 RTT); HTTP&#x2F;3: 3 次握手以及 5 倍时延 (2.5 RTT)<pre>
当客户端想要通过 HTTPS 请求访问服务端时，整个过程需要经过 7 次握手并消耗 9 倍的延迟。如果客户端和服务端因为物理距离上的限制，RTT 约为 40ms 时，第一次请求需要 ~180ms；不过如果我们想要访问美国的服务器，RTT 约为 200ms 时，这时 HTTPS 请求的耗时为 ~900ms，这就是一个比较高的耗时了。我们来总结一下 HTTPS 协议需要 9 倍时延才能完成通信的原因：</pre></li>
</ul>
<p>TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）；<br>TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）；<br>HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）；<br>需要注意的是，本文对往返延时的计算都基于特定的场景以及特定的协议版本，网络协议的版本在不断更新和演进，过去忽略的问题最开始都会通过补丁的方式更新，但是最后仍然会需要从底层完成重写。</p>
<p>HTTP&#x2F;3 就是一个这样的例子，它会使用基于 UDP 的 QUIC 协议进行握手，将 TCP 和 TLS 的握手过程结合起来，把 7 次握手减少到了 3 次握手，直接建立了可靠并且安全的传输通道，将原本 ~900ms 的耗时降低至 ~500ms，<br></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/XiongMaoMengNan/p/8425724.html">HTTP协议篇(一)：多路复用、数据流</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/436989">HTTP管线化(HTTP pipelining)</a></li>
<li><a target="_blank" rel="noopener" href="https://imququ.com/post/HTTP2-resource.html">HTTP&#x2F;2 资料汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codetd.com/article/10088188">HTTP，HTTPs，spdy，HTTP2等协议的主要区别详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/IgME_4ebP3d46m3tHbaT">一文看完 HTTP3 的演化历程</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/i-QUbVRVicqzMSZ9FUVCfQ">深入解读HTTP3的原理及应用</a></li>
<li><a target="_blank" rel="noopener" href="https://urlify.cn/zQj6f2">HTTPS 原理分析——带着疑问层层深入</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/08/30/20220830-chrome-xia-zai-wen-jian-shi-zan-ting-he-ji-xu-shi-shi-me-yuan-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/30/20220830-chrome-xia-zai-wen-jian-shi-zan-ting-he-ji-xu-shi-shi-me-yuan-li/" itemprop="url">Chrome下载文件时暂停和继续是什么原理？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-08-30T12:02:05+08:00">
                2022-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>这个问题很久前就研究过了，觉得挺有意思，这里总结记录一下</li>
<li>所有的文字整理来源于: <a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/392163074">https://bbs.csdn.net/topics/392163074</a>,感谢wjyiooo的耐心解答</li>
</ul>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul>
<li>Range，是在 HTTP&#x2F;1.1（<a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html%EF%BC%89%E9%87%8C%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%80%E4%B8%AA">http://www.w3.org/Protocols/rfc2616/rfc2616.html）里新增的一个</a> header field，也是现在众多号称多线程下载工具（如 FlashGet、迅雷等）实现多线程下载的核心所在。</li>
</ul>
<h2 id="chrome-版本58"><a href="#chrome-版本58" class="headerlink" title="chrome 版本58"></a>chrome 版本58</h2><ol>
<li>抓包确认，chrome点击暂停的时候会发送一系列窗口变动应答，将窗口降到5，并且不再应答ACK包。 当点击恢复的时候只是重新发送ACK给服务器，同时将窗口重新设置为256。</li>
<li>以上可以确认它的“续传”只是利用TCP滑动窗口的特性，跟断不断网没关系，也不属于真正意义的断点续传功能（一般用range头部实现）。当然如果你中断网络超过了服务器的TCP连接超时时间那么就不能续传了，而且如果关闭浏览器即使网络非常正常也不能续传（也是因为TCP连接断了）。</li>
<li>在等待足够长时间让TCP连接关掉后，chrome就可以断点续传了，原理也是头部带range。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>本地有临时下载文件</li>
<li>短时间内点继续，利用的是TCP滑动窗口的特性（与服务器未断开）</li>
<li>长时间之后点继续，再次发请求，带range头，继续下载剩余部分（与服务器断开）</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用Range进行多线程下载"><a href="#使用Range进行多线程下载" class="headerlink" title="使用Range进行多线程下载"></a>使用Range进行多线程下载</h3><ul>
<li>Http 请求头 Range:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/1995hxt/p/5692050.html">https://www.cnblogs.com/1995hxt/p/5692050.html</a></li>
</ul>
<ol>
<li>curl -H “Range: bytes&#x3D;0-1551” <a target="_blank" rel="noopener" href="http://127.0.0.1:8180/bg-upper.png">http://127.0.0.1:8180/bg-upper.png</a> -v -o 0-1151.png</li>
<li>curl -H “Range: bytes&#x3D;1552-3103” <a target="_blank" rel="noopener" href="http://127.0.0.1:8180/bg-upper.png">http://127.0.0.1:8180/bg-upper.png</a> -v -o 1552-end.png</li>
<li>合并 cat 0-1151.png 1552-end.png &gt; filename.png</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/08/05/20220805-tui-song-ji-zhu-zong-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/05/20220805-tui-song-ji-zhu-zong-jie/" itemprop="url">推送技术总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-08-05T21:57:59+08:00">
                2022-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>从客户端是手机APP的角度来理解推送（PUSH），展示的形式有两种：</p>
<ol>
<li>App 推送：消息内容通过手机通知栏（状态栏）展示</li>
<li>应用内消息：各种业务数据推送（通过定义模版或命令号等方式推送给APP内的业务使用）</li>
</ol>
</li>
<li><p>从Web端角度看理解推送，一般只有网页内消息（跟手机APP的应用内消息是一样的类型）  </p>
</li>
<li><p>APP推送：</p>
<ol>
<li>在线推送（应用级方案）：APP进程控制推送消息，理论上只要APP要获得“手机通知栏”的权限（一般通过在APP内维持长连接来进行推送，但前提是APP已经启动和运行，并且能常驻）</li>
<li>离线推送（系统级方案）：通过手机操作系统或手机厂商提供的通道进行推送。这种推送方式可以在APP未启动的情况下，推送APP的消息。</li>
<li>APP进程运行时，应该优先走在线推送，自己的推送系统更快、更有保障。</li>
</ol>
</li>
<li><p>应用场景</p>
<ul>
<li>APP推送：电商内APP（推送促销消息）</li>
<li>应用内消息：直播类APP（推送送礼特效消息）</li>
<li>APP推送和应用内消息都需要：IM类APP（推送用户聊天信息）</li>
</ul>
</li>
<li><p>从推送的实现角度看，基本可以概括为两种：主动轮询（pull 拉）和长连接 （push 推）</p>
</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul>
<li>以下实现方式没有进行严格分类，从原理上看存在相互联系</li>
</ul>
<ol>
<li><p>HTTP轮询</p>
<ol>
<li>短轮询（Polling）</li>
<li>长轮询（Long-polling）(Nacos和apollo配置中心也是用这种)</li>
</ol>
<ul>
<li>从TCP的角度看HTTP长轮询：HTTP开启keepalive，服务端保持连接并不需要发额外数据包，有数据时可以立刻推送，跟TCP长连推送无异。展示服务端有点费连接的相关资源，数据包是HTTP相比较大而已。</li>
</ul>
</li>
<li><p>SSE (Server Sent Event 服务器发送事件)</p>
<ul>
<li>sse 单通道，只能服务端向客户端发消息； webscoket 是双通道</li>
<li>实现成本较低</li>
<li>http 协议，服务端响应的是text&#x2F;event-stream类型的数据流信息</li>
<li>场景：站内信、未读消息数、状态更新、股票行情、监控数量等场景</li>
</ul>
</li>
<li><p>WebSocket</p>
</li>
<li><p>MQTT （通常结合TCP长连接一起使用）</p>
</li>
<li><p>TCP长连接（自定义消息或protobuf等格式）</p>
</li>
<li><p>系统级方案</p>
<ul>
<li>Android和IOS本身的消息推送（Android的C2DM和IOS的APNS，系统与服务器建立连接，APP向系统注册关注的消息，实现系统级消息推送）</li>
<li>国内Android无法访问Google服务器，所以国内的手机厂商比如小米、OPPO、华为等，都实现来各自的系统级推送。</li>
<li>避免维持长连接而导致的过多资源消耗，IM类要求即时的更应该接系统级推送</li>
</ul>
</li>
<li><p>第三方推送平台</p>
<ul>
<li>集成各种手机平台，各种推送类型，甚至短信等推送</li>
<li>简单来说：由专业的平台做专业的事（太麻烦了，我只是想推送了消息，帮我搞定吧。。。）</li>
</ul>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wIs5wi7rf0RFFGl7sR3J8g">7种 实现web实时消息推送的方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yihuihui/p/12622729.html">SSE 服务器发送事件详解</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/08/02/20220802-shuo-shuo-cdn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/02/20220802-shuo-shuo-cdn/" itemprop="url">说说CDN</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-08-02T21:54:30+08:00">
                2022-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul>
<li>CDN（Content Delivery Network）（内容分发网络）：提供内容给用户就近访问</li>
</ul>
<h2 id="CDN域名解析流程"><a href="#CDN域名解析流程" class="headerlink" title="CDN域名解析流程"></a>CDN域名解析流程</h2><ul>
<li>浏览器发起HTTP请求到本地DNS服务器，本地DNS服务器使用CNAME的方式，将资源域名重定向到CDN服务</li>
</ul>
<ol>
<li>用户机器（比如浏览器）-&gt; LocalDNS</li>
<li>LocalDNS -&gt; 域名授权DNS服务 (返回域名CNAME)</li>
<li>LocalDNS -&gt; 请求CNAME域名（重新走域名解析流程，DNS根服务器，域服务器等）（返回CNAME对应的ip）</li>
<li>LocalDNS -&gt; CNAME对应的CDN服务器（CDN策略，查找出最佳的CDN节点的IP地址）</li>
<li>LocalDNS返回CDN节点IP地址给浏览器</li>
<li>用户机器（比如浏览器）-&gt; CDN节点（若无缓存）</li>
<li>CDN节点 -&gt; 回源服务器拉取资源 (可选)</li>
</ol>
<ul>
<li>添加CNAME记录需要在您的域名厂商处配置；CNAME的配置和域名的解析配置一起的</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="服务接口的数据可以使用CDN来缓存？"><a href="#服务接口的数据可以使用CDN来缓存？" class="headerlink" title="服务接口的数据可以使用CDN来缓存？"></a>服务接口的数据可以使用CDN来缓存？</h3><ul>
<li>CDN不仅可以缓存静态资源（图片，视频等），对于一些数据变更不大的接口，可以适当缓存接口数据。比如配置，利用CDN缓存几分钟是合理的。</li>
</ul>
<h3 id="不能缓存数据的接口，可以使用CDN吗？"><a href="#不能缓存数据的接口，可以使用CDN吗？" class="headerlink" title="不能缓存数据的接口，可以使用CDN吗？"></a>不能缓存数据的接口，可以使用CDN吗？</h3><ul>
<li>结论：可以使用CDN，但注意GET接口响应头设置为不缓存(比如设置 Cache-Control:no-cache)</li>
</ul>
<ol>
<li>通过CDN加速回源效果（使用CDN快速传输的特性）<ul>
<li>比如一般情况下，用户访问通过普通公网，需要经过20个路由才到达服务器</li>
<li>使用CDN加速后，通过5CDN节点就到达服务器了（这里涉及服务器端在CDN的接入点、用户端CDN部署的覆盖范围是否足够大）</li>
</ul>
</li>
<li>使用CDN隐藏服务器真实IP,起到提升安全性等作用</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2000101">DNS、CDN加速和域名解析之间的关系</a></li>
<li><a href="https://kingson4wu.github.io/2020/08/20/20200820-%E5%85%B3%E4%BA%8ECDN%E7%BC%93%E5%AD%98/">关于CDN缓存总结摘要</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/08/01/20220801-dns-jie-huo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/01/20220801-dns-jie-huo/" itemprop="url">DNS解惑</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-08-01T17:00:30+08:00">
                2022-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul>
<li>DNS（Domain Name System）域名系统: 域名和IP地址映射关系</li>
<li>LocalDNS : 本地DNS服务器，一般是ISP（Internet Service Provider）提供。ISP，即是互联网服务提供商(比如电信、联通和移动三大电信运营商)；对于不同运营商间的互联互通，一般是采用BGP peering（对等）的方式进行</li>
<li>地址解析协议，即ARP（Address Resolution Protocol）是将IP地址转换为MAC地址（TCP&#x2F;IP数据链路层协议）；DNS协议则是将域名转换为IP地址（TCP&#x2F;IP应用层协议）</li>
<li>ICANN  互联网名称与数字地址分配机构（The Internet Corporation for Assigned Names and Numbers）,全世界域名的最高管理机构。</li>
<li>CNNIC：中国互联网络信息中心（China Internet Network Information Center，CNNIC）是经国家主管部门批准，于1997年6月3日组建的管理和服务机构，行使国家互联网络信息中心的职责。</li>
<li>可逆DNS（rDNS，reverse DNS）是一种把一个IP地址分解成一个域名的方法，正像域名系统（DNS）把域名分解成关联的IP地址。</li>
</ul>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><ul>
<li>不考虑每部分DNS缓存的情况下，DNS解析流程大致如下：</li>
</ul>
<ol>
<li>【递归查询】用户机器（比如浏览器）-&gt; 本地DNS服务器 </li>
<li>【迭代查询】本地DNS服务器 -&gt; DNS根服务器(返回域服务器)</li>
<li>【迭代查询】本地DNS服务器 -&gt; 域服务器(返回DNS服务器列表)</li>
<li>【迭代查询】本地DNS服务器(选择一个DNS服务器) -&gt; DNS服务器(返回域名对应的IP)（或返回其他权限服务器的IP地址，取决于域名的解析配置）</li>
<li>本地DNS服务器 -&gt; 权限服务器（可选步骤，取决于上一步的返回）</li>
<li>用户机器（根据IP发送请求访问）</li>
</ol>
<p><img src="/2022/08/01/20220801-dns-jie-huo/dns-resolution-linux-1920x994.webp"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://devconnected.com/how-to-flush-dns-cache-on-linux/">https://devconnected.com/how-to-flush-dns-cache-on-linux/</a></p>
</li>
<li><p>浏览器等各个部分一般会缓存DNS记录一段时间</p>
</li>
<li><p>本地DNS服务器（LocalDNS）使用迭代查询的方式请求；请求发起方（浏览器）使用递归查询的方式请求</p>
</li>
<li><p>递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p>
</li>
<li><p>迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</p>
</li>
<li><p>通俗地说，递归就是把一件事情交给别人，如果事情没有办完，哪怕已经办了很多，都不要把结果告诉我，我要的是你的最终结果，而不是中间结果；如果你没办完，请你找别人办完。<br>迭代则是我交给你一件事，你能办多少就告诉我你办了多少，然后剩下的事情就由我来办。</p>
</li>
</ul>
<h2 id="域名的管理"><a href="#域名的管理" class="headerlink" title="域名的管理"></a>域名的管理</h2><ul>
<li><p>.com等国际顶级域名的管理机构是ICANN；.cn等国内域名的管理机构是CNNIC</p>
</li>
<li><p>用whois可以查询域名的相关信息</p>
</li>
<li><p>域名具有管理密码和转移密码，域名转移密码又称为授权码（Authorization code）或 域名EPP代码（EPP Key）</p>
</li>
<li><p>域名其实是具有一定的层次结构的，从上到下依次为：根域名、顶级域名（top level domain，TLD）、二级域名、（三级域名）<br>先来讲讲顶级域名（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的顶级域名就是 .com。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。</p>
</li>
<li><p>ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个托管商，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，.cn 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 .cn 域名的各种政策。</p>
</li>
<li><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<a target="_blank" rel="noopener" href="http://www.xxx.com/">www.xxx.com</a> 被写成 <a target="_blank" rel="noopener" href="http://www.xxx.com.,即最后还会多出一个点.这个点就是根域名./">www.xxx.com.，即最后还会多出一个点。这个点就是根域名。</a></p>
</li>
<li><p>理论上，所有域名的查询都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商。</p>
</li>
</ul>
<h2 id="DNS服务器类别"><a href="#DNS服务器类别" class="headerlink" title="DNS服务器类别"></a>DNS服务器类别</h2><h3 id="权威-DNS"><a href="#权威-DNS" class="headerlink" title="权威 DNS"></a>权威 DNS</h3><ul>
<li>权威 DNS 指域名在域名注册商处所设置的 DNS 服务器地址。该地址决定了该域名的解析管理权（新增，删除，修改等）。比如 DNSPod 的权威服务器：*.dnspod.net, * dnsv3.com 等。当域名设置权威服务器并设置了解析记录后，客户端请求域名时，权威服务器将返回该域名的对应的解析记录信息。</li>
</ul>
<h3 id="Local-DNS"><a href="#Local-DNS" class="headerlink" title="Local DNS"></a>Local DNS</h3><ul>
<li><p>Local DNS 是 DNS 查询中的第一个节点。Local DNS 作为客户端与 DNS 域名服务器的中间人。客户端发送 DNS 查询时，Local DNS 将使用缓存的数据进行响应，或者将向根域名服务器发送请求，接着向根域名服务器发送另一个请求，然后向权威 DNS 发送最后一个请求。收到来自包含已请求 IP 地址的权威 DNS 服务器的响应后，Local DNS 将向客户端发送响应。</p>
</li>
<li><p>在此过程中，Local DNS 将缓存从权威 DNS 服务器收到的信息。当一个客户端请求的域名 IP 地址是另一个客户端最近请求的 IP 地址时，Local DNS 可绕过与域名服务器进行通信的过程，并仅从第二个客户端的缓存中为第一个客户端提供所请求的记录。</p>
</li>
</ul>
<h3 id="公共-DNS"><a href="#公共-DNS" class="headerlink" title="公共 DNS"></a>公共 DNS</h3><ul>
<li>公共DNS，指面向所有互联网用户的全球公共递归域名解析服务。和仅使用本地 LocalDNS 的传统解析服务相比，公共解析服务，一般具备更加“快速”、“稳定”、“安全”互联网访问。</li>
</ul>
<h2 id="DNS常用命令"><a href="#DNS常用命令" class="headerlink" title="DNS常用命令"></a>DNS常用命令</h2><ul>
<li>dig、 host、nslookup、traceroute、whois</li>
</ul>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><h3 id="域名提供商和电信服务提供商之间DNS的关系？"><a href="#域名提供商和电信服务提供商之间DNS的关系？" class="headerlink" title="域名提供商和电信服务提供商之间DNS的关系？"></a>域名提供商和电信服务提供商之间DNS的关系？</h3><ol>
<li>域名提供商(域名注册商)（ICANN等授权的管理机构）；电信服务提供商（ISP）</li>
<li>ISP的DNS：LocalDNS</li>
<li>域名提供商的DNS （腾讯、阿里云等），将自己的dns服务的ip直接在各个ISP中进行登记，使得ISP的DNS服务能转发过来查找，得到域名对应的ip</li>
<li>域名并不依赖平台，比如阿里万网只是个注册商，注册完域名后有相应的转移密码。转移密码有多种用途，比如可以在多个DNS服务商托管域名解析（有的域名注册商不一定有对应的DNS服务，而且在多个DNS服务商解析可以起到容灾作用）</li>
</ol>
<h3 id="运营商DNS和公共DNS"><a href="#运营商DNS和公共DNS" class="headerlink" title="运营商DNS和公共DNS"></a>运营商DNS和公共DNS</h3><ul>
<li>如何不特意去设置，我们用的就是运营商DNS（由DHCP分配）</li>
<li>目前国内电信运营商通过使用DNS劫持和DNS污染的方法，干扰用户正常上网，使得用户无法访问众多国外常用服务，因此可以使用公共DNS</li>
</ul>
<h3 id="自己创建的域名怎么让其他dns服务器解析"><a href="#自己创建的域名怎么让其他dns服务器解析" class="headerlink" title="自己创建的域名怎么让其他dns服务器解析"></a>自己创建的域名怎么让其他dns服务器解析</h3><ul>
<li>除非用户自行设置指定你的dns服务公网ip，否则只有成为认证通过的注册服务商才行</li>
<li>比如阿里云域名的解析生效，第一步是 阿里云 DNS 必须首先生效，然后等待世界各地 Local DNS 生效，可以通俗的理解为各大电信运营管理的 DNS 需要及时同步 阿里云 DNS 解析记录，才能最终生效。 网站是否能访问，直接相关的是 Local DNS， 阿里 云解析都是实时生效的，一般只需几秒即可同步到各地 Local DNS 上，但各地 Local DNS 均有缓存机制，解析的最终生效取决于各运营商刷新时间。</li>
</ul>
<h3 id="DNS解析相关疑问"><a href="#DNS解析相关疑问" class="headerlink" title="DNS解析相关疑问"></a>DNS解析相关疑问</h3><ul>
<li>DNS协议是应用层的协议，解析过程发生在用户态。</li>
<li>DNS协议既使用了UDP，也使用了TCP，使用的端口号都为 53。大多数情况下 DNS 都使用 UDP 进行传输。</li>
<li>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议；DNS区域传输的时候使用TCP协议</li>
<li>举个例子：浏览器返回某个HTTP服务<ol>
<li>浏览器调用“DNS解析模块”发出UDP请求得到域名的ip（DNS 应用层）</li>
<li>浏览器调用TCP（内核系统调用）发出HTTP请求（TCP 传输层）</li>
<li>TCP通过ARP协议得到mac地址 （ARP 数据链路层）</li>
</ol>
</li>
<li>“DNS解析模块” 是在哪里实现的？<ol>
<li>程序自行解析实现（从&#x2F;etc&#x2F;resolv.conf中取出本地dns server地址列表， 发送DNS请求(UDP报文)并获得结果）</li>
<li>调用到c标准库的getaddrinfo或getnameinfo函数<ul>
<li>要想知道getaddrinfo是如何查询信息的，可以用strace工具，追踪getaddrinfo函数 在执行时打开了哪些文件</li>
<li>resolv.conf是各种操作系统域名系统解析器（DNS Resolver）的配置文件。每当一个程序需要通过域名来访问Internet上面的其它主机时，需要利用Resolver库函数将域名转换成对应的IP，然后才可进行访问。</li>
<li>域名系统解析器（DNS Resolver）并非一个可执行程序，而是C语言的一系列库函数，用于解析resolv.conf获取域名对应的IP。</li>
</ul>
</li>
<li>操作系统中并不存在“DNS 查询”这个系统调用; 不同程序可能采用不同的策略获取名字对应的 IP 地址</li>
</ol>
</li>
</ul>
<h3 id="dns-resolver相关"><a href="#dns-resolver相关" class="headerlink" title="dns-resolver相关"></a>dns-resolver相关</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/dns/dns-resolvers">https://docs.microsoft.com/en-us/windows/win32/dns/dns-resolvers</a></li>
<li><a target="_blank" rel="noopener" href="https://datacadamia.com/os/linux/resolv.conf">https://datacadamia.com/os/linux/resolv.conf</a>    </li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/networking/dns_resolver.html">DNS Resolver Module</a><ul>
<li>The DNS resolver module provides a way for kernel services to make DNS queries by way of requesting a key of key type dns_resolver. These queries are upcalled to userspace through &#x2F;sbin&#x2F;request-key.</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2000101">DNS、CDN加速和域名解析之间的关系</a></li>
<li><a target="_blank" rel="noopener" href="https://www.vpsgongyi.net/archives/2197.html">权威DNS、Local DNS、公共DNS有什么区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyepeng/p/9835839.html">DNS用的是TCP协议还是UDP协议</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37964071/article/details/80500825">DNS（域名解析协议）详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/battzion/p/4235562.html">getaddrinfo工作原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42898476">Linux DNS 查询剖析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kingson4wu.github.io/2022/07/20/20220720-tan-tan-kua-yu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/20/20220720-tan-tan-kua-yu/" itemprop="url">谈谈跨域</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-20T21:50:26+08:00">
                2022-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>JQuery的jsonp的success与jsonpCallback的关系:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/non-clockwork-cheng/p/6637491.html">https://www.cnblogs.com/non-clockwork-cheng/p/6637491.html</a>,<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tapt/p/6524946.html">https://www.cnblogs.com/tapt/p/6524946.html</a></p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">              <span class="attr">async</span>:<span class="literal">false</span>,</span><br><span class="line">              <span class="attr">url</span>: <span class="string">&quot;http://192.168.1.102:8080/carop/jsonp&quot;</span>,</span><br><span class="line">              <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">              <span class="attr">jsonpCallback</span>:<span class="string">&quot;jsonpCallback&quot;</span>,              </span><br><span class="line">              <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="title function_">alert</span>(data.<span class="property">name</span>+<span class="string">&quot;\n &quot;</span>+data.<span class="property">tel</span>);</span><br><span class="line">              &#125;</span><br><span class="line"> &#125;); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>jsonp和jsonpcallback的使用:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangruiqi/p/7880642.html">https://www.cnblogs.com/zhangruiqi/p/7880642.html</a></p>
</li>
</ul>
<pre>
1. jsonp、jsonpCallback  jsonp跨域时可以自定义的两个参数
2. jsonp: 回掉函数名的参数名，默认callback，服务端通过它来获取到回调函数名
3. jsonpCallback: 回调函数名，默认jquery自动生成
4. 指定jsonpCallback时可以将回掉函数写在ajax外面做其他操作，不指定时不能这样做，只能在success里做操作

一般jquery跨域用到的两个方法为：$.ajax 和$.getJSON

最后，仔细安静下来，细读 json 官方文档后发现这么一段：

JSON数据是一种能很方便通过JavaScript解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。

其实jquery跨域的原理是通过外链 <script>  来实现的,然后在通过回调函数加上回调函数的参数来实现真正的跨域

Jquery 在每次跨域发送请求时都会有callback这个参数，其实这个参数的值就是回调函数名称，所以，服务器端在发送json数据时，应该把这个参数放到前面，这个参数的值往往是随机生成的，如：jsonp1294734708682，同时也可以通过 $.ajax 方法设置 jsonpcallback 方法的名称。
</pre>

<ul>
<li><p>解决跨域有几种</p>
<ol>
<li>通过jsonp跨域(需要服务端配合),原理:动态创建script.jsonp的解决方式（仅支持GET方式）</li>
<li>跨域资源共享（CORS）,服务端设置Access-Control-Allow-Origin<ul>
<li>nginx反向代理接口跨域 : <code>add_header Access-Control-Allow-Origin http://www.domain1.com; </code></li>
</ul>
</li>
<li>使用jsonp还不如响应添加Access-Control-Allow-Origin?<ul>
<li>传统的跨域请求没有好的解决方案，无非就是jsonp和iframe，随着跨域请求的应用越来越多，W3C提供了跨域请求的标准方案（Cross-Origin Resource Sharing）。IE8、Firefox 3.5 及其以后的版本、Chrome浏览器、Safari 4 等已经实现了 Cross-Origin Resource Sharing 规范，实现了跨域请求。<br>在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息。</li>
<li>说明jsonp其实已经过时?是以前  CORS没出现前的方案?</li>
</ul>
</li>
</ol>
</li>
<li><p>springboot中通过cors协议解决跨域问题：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/520playboy/p/7306008.html">https://www.cnblogs.com/520playboy/p/7306008.html</a></p>
</li>
</ul>
</script></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/10/">&gt;</a>
  </nav>





          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">180</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">224</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
