<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="拉巴力的纸皮箱" type="application/atom+xml" />






<meta name="description" content="为啥不吃三文鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="拉巴力的纸皮箱">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="拉巴力的纸皮箱">
<meta property="og:description" content="为啥不吃三文鱼">
<meta property="og:locale">
<meta property="article:author" content="Kingson Wu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/"/>





  <title>拉巴力的纸皮箱</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉巴力的纸皮箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/17/20220117-nio-zong-jie-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/17/20220117-nio-zong-jie-bi-ji/" itemprop="url">NIO总结笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-17T14:55:32+08:00">
                2022-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-I-x2F-O"><a href="#Java-I-x2F-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><table>
<thead>
<tr>
<th>I&#x2F;O</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<ul>
<li>I&#x2F;O 与 NIO 一个比较重要的区别是我们使用 I&#x2F;O 的时候往往会引入多线程，每个连接使用一个单独的线程，而 NIO 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。而由于 NIO 的非阻塞需要一直轮询，比较消耗系统资源，所以异步非阻塞模式 AIO 就诞生了。</li>
</ul>
<h3 id="5-种-I-x2F-O模型"><a href="#5-种-I-x2F-O模型" class="headerlink" title="5 种 I&#x2F;O模型"></a>5 种 I&#x2F;O模型</h3><ol>
<li>blocking I&#x2F;O</li>
<li>nonblocking I&#x2F;O</li>
<li>I&#x2F;O multiplexing (select and poll)</li>
<li>signal driven I&#x2F;O (SIGIO)</li>
<li>asynchronous I&#x2F;O (the POSIX aio_functions)。</li>
</ol>
<ul>
<li>不同的操作系统对上述模型支持不同，UNIX 支持 IO 多路复用。不同系统叫法不同，freebsd 里面叫 kqueue，Linux 叫 epoll。而 Windows2000 的时候就诞生了 IOCP 用以支持 asynchronous I&#x2F;O。</li>
<li>Java 是一种跨平台语言，为了支持异步 I&#x2F;O，诞生了 NIO，Java1.4 引入的 NIO1.0 是基于 I&#x2F;O 复用的，它在各个平台上会选择不同的复用方式。Linux 用的 epoll，BSD 上用 kqueue，Windows 上是重叠 I&#x2F;O。</li>
<li>IO多路复用，Java NIO的核心类库多路复用器Selector就是基于epoll的多路复用技术实现。</li>
<li>IO复用的系统调用方式：select，pselect，poll，epoll（IO复用属于同步IO）</li>
<li>同步阻塞BIO，同步非阻塞NIO，异步非阻塞AIO<br> 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！</li>
</ul>
<h3 id="Java-I-x2F-O-的相关方法"><a href="#Java-I-x2F-O-的相关方法" class="headerlink" title="Java I&#x2F;O 的相关方法"></a>Java I&#x2F;O 的相关方法</h3><ol>
<li>同步并阻塞 (I&#x2F;O 方法)：服务器实现模式为一个连接启动一个线程，每个线程亲自处理 I&#x2F;O 并且一直等待 I&#x2F;O 直到完成，即客户端有连接请求时服务器端就需要启动一个线程进行处理。但是如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善这个缺点。I&#x2F;O 的局限是它是面向流的、阻塞式的、串行的一个过程。对每一个客户端的 Socket 连接 I&#x2F;O 都需要一个线程来处理，而且在此期间，这个线程一直被占用，直到 Socket 关闭。在这期间，TCP 的连接、数据的读取、数据的返回都是被阻塞的。也就是说这期间大量浪费了 CPU 的时间片和线程占用的内存资源。此外，每建立一个 Socket 连接时，同时创建一个新线程对该 Socket 进行单独通信 (采用阻塞的方式通信)。这种方式具有很快的响应速度，并且控制起来也很简单。在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况；</li>
<li>同步非阻塞 (NIO 方法)：服务器实现模式为一个请求启动一个线程，每个线程亲自处理 I&#x2F;O，但是另外的线程轮询检查是否 I&#x2F;O 准备完毕，不必等待 I&#x2F;O 完成，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程进行处理。NIO 则是面向缓冲区，非阻塞式的，基于选择器的，用一个线程来轮询监控多个数据传输通道，哪个通道准备好了 (即有一组可以处理的数据) 就处理哪个通道。服务器端保存一个 Socket 连接列表，然后对这个列表进行轮询，如果发现某个 Socket 端口上有数据可读时，则调用该 Socket 连接的相应读操作；如果发现某个 Socket 端口上有数据可写时，则调用该 Socket 连接的相应写操作；如果某个端口的 Socket 连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到大幅度提高；</li>
<li>异步非阻塞 (AIO 方法，JDK7 发布)：服务器实现模式为一个有效请求启动一个线程，客户端的 I&#x2F;O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，每个线程不必亲自处理 I&#x2F;O，而是委派操作系统来处理，并且也不需要等待 I&#x2F;O 完成，如果完成了操作系统会另行通知的。该模式采用了 Linux 的 epoll 模型。</li>
</ol>
<ul>
<li>在连接数不多的情况下，传统 I&#x2F;O 模式编写较为容易，使用上也较为简单。但是随着连接数的不断增多，传统 I&#x2F;O 处理每个连接都需要消耗一个线程，而程序的效率，当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少的。所以传统阻塞式 I&#x2F;O 的瓶颈在于不能处理过多的连接。非阻塞式 I&#x2F;O 出现的目的就是为了解决这个瓶颈。非阻塞 IO 处理连接的线程数和连接数没有联系，例如系统处理 10000 个连接，非阻塞 I&#x2F;O 不需要启动 10000 个线程，你可以用 1000 个，也可以用 2000 个线程来处理。因为非阻塞 IO 处理连接是异步的，当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求“事件”，并把这个“事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还，这样一个线程就可以异步的处理多个事件。而阻塞式 I&#x2F;O 的线程的大部分时间都被浪费在等待请求上了。</li>
</ul>
<h3 id="AIO-相关的类和接口"><a href="#AIO-相关的类和接口" class="headerlink" title="AIO 相关的类和接口"></a>AIO 相关的类和接口</h3><ul>
<li><code>java.nio.channels.AsynchronousChannel</code>：标记一个 Channel 支持异步 IO 操作；</li>
<li><code>java.nio.channels.AsynchronousServerSocketChannel</code>：ServerSocket 的 AIO 版本，创建 TCP 服务端，绑定地址，监听端口等；</li>
<li><code>java.nio.channels.AsynchronousSocketChannel</code>：面向流的异步 Socket Channel，表示一个连接；</li>
<li><code>java.nio.channels.AsynchronousChannelGroup</code>：异步 Channel 的分组管理，目的是为了资源共享。一个 AsynchronousChannelGroup 绑定一个线程池，这个线程池执行两个任务：处理 IO 事件和派发 CompletionHandler。AsynchronousServerSocketChannel 创建的时候可以传入一个 AsynchronousChannelGroup，那么通过 AsynchronousServerSocketChannel 创建的 AsynchronousSocketChannel 将同属于一个组，共享资源；</li>
<li><code>java.nio.channels.CompletionHandler</code>：异步 IO 操作结果的回调接口，用于定义在 IO 操作完成后所作的回调工作。AIO 的 API 允许两种方式来处理异步操作的结果：返回的 Future 模式或者注册 CompletionHandler，推荐用 CompletionHandler 的方式，这些 handler 的调用是由 AsynchronousChannelGroup 的线程池派发的。这里线程池的大小是性能的关键因素。</li>
</ul>
<h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>常用的Reactor线程模型有三种，分别如下：</p>
<ol>
<li>Reactor单线程模型；</li>
<li>Reactor多线程模型；</li>
<li>主从Reactor多线程模型    <ul>
<li>Netty的线程模型并非固定不变，通过在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。</li>
</ul>
</li>
</ol>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/netty-threading-model">http://www.infoq.com/cn/articles/netty-threading-model</a></li>
<li>主从Reactor线程模型</li>
<li>Netty线程开发最佳实践<ul>
<li>2.4.1. 时间可控的简单业务直接在IO线程上处理<br>  如果业务非常简单，执行时间非常短，不需要与外部网元交互、访问数据库和磁盘，不需要等待其它资源，则建议直接在业务ChannelHandler中执行，不需要再启业务的线程或者线程池。避免线程上下文切换，也不存在线程并发问题。</li>
<li>2.4.2. 复杂和时间不可控业务建议投递到后端业务线程池统一处理<br>  对于此类业务，不建议直接在业务ChannelHandler中启动线程或者线程池处理，建议将不同的业务统一封装成Task，统一投递到后端的业务线程池中进行处理。<br>  过多的业务ChannelHandler会带来开发效率和可维护性问题，不要把Netty当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和Netty的架构分层。</li>
<li>2.4.3. 业务线程避免直接操作ChannelHandler<br>  对于ChannelHandler，IO线程和业务线程都可能会操作，因为业务通常是多线程模型，这样就会存在多线程操作ChannelHandler。为了尽量避免多线程并发问题，建议按照Netty自身的做法，通过将操作封装成独立的Task由NioEventLoop统一执行，而不是业务线程直接操作<br>  <code>ctx.executor().execute(new Runnable()&#123;&#125;)</code><br>  如果你确认并发访问的数据或者并发操作是安全的，则无需多此一举，这个需要根据具体的业务场景进行判断，灵活处理。</li>
</ul>
</li>
</ul>
<h3 id="Netty的“零拷贝”"><a href="#Netty的“零拷贝”" class="headerlink" title="Netty的“零拷贝”"></a>Netty的“零拷贝”</h3><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。</li>
<li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</li>
<li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
</ul>
<h3 id="Netty-灵活的TCP参数配置能力"><a href="#Netty-灵活的TCP参数配置能力" class="headerlink" title="Netty - 灵活的TCP参数配置能力"></a>Netty - 灵活的TCP参数配置能力</h3><ul>
<li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；</li>
<li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
<li>软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。</li>
</ul>
<h3 id="心跳实现"><a href="#心跳实现" class="headerlink" title="心跳实现"></a>心跳实现</h3><ul>
<li>使用TCP协议层的Keeplive机制，但是该机制默认的心跳时间是2小时，依赖操作系统实现不够灵活</li>
<li>应用层实现自定义心跳机制，比如Netty实现心跳机制<ul>
<li>服务端添加IdleStateHandler心跳检测处理器，并添加自定义处理Handler类实现userEventTriggered()方法作为超时事件的逻辑处理</li>
</ul>
</li>
</ul>
<h3 id="Netty中比较常用的帧解码器"><a href="#Netty中比较常用的帧解码器" class="headerlink" title="Netty中比较常用的帧解码器"></a>Netty中比较常用的帧解码器</h3><ol>
<li>固定长度帧解码器 - FixedLengthFrameDecoder<ul>
<li>适用场景：每个上层数据包的长度，都是固定的，比如 100。在这种场景下，只需要把这个解码器加到 pipeline 中，Netty 会把底层帧，拆分成一个个长度为 100 的数据包 (ByteBuf)，发送到下一个 channelHandler入站处理器。</li>
</ul>
</li>
<li>行分割帧解码器 - LineBasedFrameDecoder<ul>
<li>适用场景：每个上层数据包，使用换行符或者回车换行符做为边界分割符。发送端发送的时候，每个数据包之间以换行符&#x2F;回车换行符作为分隔。在这种场景下，只需要把这个解码器加到 pipeline 中，Netty 会使用换行分隔符，把底层帧分割成一个一个完整的应用层数据包，发送到下一站。前面的例子，已经对这个解码器进行了演示。</li>
</ul>
</li>
<li>自定义分隔符帧解码器 - DelimiterBasedFrameDecoder<ul>
<li>DelimiterBasedFrameDecoder 是LineBasedFrameDecoder的通用版本。不同之处在于，这个解码器，可以自定义分隔符，而不是局限于换行符。如果使用这个解码器，在发送的时候，末尾必须带上对应的分隔符。</li>
</ul>
</li>
<li>自定义长度帧解码器 - LengthFieldBasedFrameDecoder<ul>
<li>这是一种基于灵活长度的解码器。在数据包中，加了一个长度字段（长度域），保存上层包的长度。解码的时候，会按照这个长度，进行上层ByteBuf应用包的提取。</li>
<li>LengthFieldPrepender(编码)：如果协议中的第一个字段为长度字段，netty提供了LengthFieldPrepender编码器，它可以计算当前待发送消息的二进制字节长度，将该长度添加到ByteBuf的缓冲区头中</li>
</ul>
</li>
</ol>
<h3 id="Netty-API"><a href="#Netty-API" class="headerlink" title="Netty API"></a>Netty API</h3><h4 id="JDK-ByteBuffer-VS-Netty-ByteBuf"><a href="#JDK-ByteBuffer-VS-Netty-ByteBuf" class="headerlink" title="JDK ByteBuffer VS Netty ByteBuf"></a>JDK ByteBuffer VS Netty ByteBuf</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013828625/article/details/79845512">https://blog.csdn.net/u013828625/article/details/79845512</a></li>
<li>Netty中的ByteBuf则完全对JDK中的ByteBuffer的缺点进行了改进</li>
<li>网络数据的基本单位永远是 byte(字节)。Java NIO 提供 ByteBuffer 作为字节的容器，但该类过于复杂，有点难用。ByteBuf是Netty当中的最重要的工具类，它与JDK的ByteBuffer原理基本上相同，也分为堆内与堆外俩种类型，但是ByteBuf做了极大的优化，具有更简单的API，更多的工具方法和优秀的内存池设计。</li>
<li>ByteBuf 维护俩不同索引：一个用于读取，一个用于写入：从 ByteBuf 读取时，其 readerIndex 将会被递增已经被读取的字节数；当写入 ByteBuf 时，writerIndex 也会被递增</li>
</ul>
<h4 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ffaiss/p/9843442.html">SimpleChannelInboundHandler与ChannelInboundHandlerAdapter</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/97235">Netty随记之ChannelInboundHandlerAdapter、SimpleChannelInboundHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lemon-flm/p/7813914.html">Netty——高级发送和接收数据handler处理器</a></li>
<li>每一个Handler都一定会处理出站或者入站（也可能两者都处理）数据，例如对于入站的Handler可能会继承SimpleChannelInboundHandler或者ChannelInboundHandlerAdapter，而SimpleChannelInboundHandler又是继承于ChannelInboundHandlerAdapter，最大的区别在于SimpleChannelInboundHandler会对没有外界引用的资源进行一定的清理，并且入站的消息可以通过泛型来规定。</li>
<li>对于两者关系：<br><code>public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter</code></li>
<li><code>public void channelRead(ChannelHandlerContext ctx, Object msg) </code> , msg 是ByteBuf类型（未decode转化类型的情况），使用 SimpleChannelInboundHandler 会被自动释放</li>
</ul>
<ol>
<li>ChannelInboundHandlerAdapter<ul>
<li>ChannelInboundHandlerAdapter是ChannelInboundHandler的一个简单实现，默认情况下不会做任何处理，只是简单的将操作通过fire*方法传递到ChannelPipeline中的下一个ChannelHandler中让链中的下一个ChannelHandler去处理。</li>
<li>需要注意的是信息经过channelRead方法处理之后不会自动释放（因为信息不会被自动释放所以能将消息传递给下一个ChannelHandler处理）。</li>
</ul>
</li>
<li>SimpleChannelInboundHandler<ul>
<li>SimpleChannelInboundHandler支持泛型的消息处理，默认情况下消息处理完将会被自动释放，无法提供fire*方法传递给ChannelPipeline中的下一个ChannelHandler,如果想要传递给下一个ChannelHandler需要调用ReferenceCountUtil#retain方法。</li>
<li>channelRead0方法在将来将会重命名为messageReceived</li>
</ul>
</li>
</ol>
<h4 id="channelRead-和channelReadComplete"><a href="#channelRead-和channelReadComplete" class="headerlink" title="channelRead()和channelReadComplete()"></a>channelRead()和channelReadComplete()</h4><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000018753423">channelRead()和channelReadComplete() 方法的区别是什么？</a></li>
<li>channelRead表示接收消息，可以看到msg转换成了ByteBuf，然后打印，也就是把Client传过来的消息打印了一下，你会发现每次打印完后，channelReadComplete也会调用，如果你试着传一个超长的字符串过来，超过1024个字母长度，你会发现channelRead会调用多次，而channelReadComplete只调用一次。</li>
</ul>
<h4 id="ctx-write-vd-ctx-channel-write"><a href="#ctx-write-vd-ctx-channel-write" class="headerlink" title="ctx.write() vd ctx.channel().write()"></a>ctx.write() vd ctx.channel().write()</h4><ul>
<li>Any difference between ctx.write() and ctx.channel().write() in netty?:<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20366418/any-difference-between-ctx-write-and-ctx-channel-write-in-netty">https://stackoverflow.com/questions/20366418/any-difference-between-ctx-write-and-ctx-channel-write-in-netty</a></li>
<li>Yes there is… Channel.write(..) always start from the tail of the ChannelPipeline and so pass through all the ChannelOutboundHandlers. ChannelHandlerContext.write(…) starts from the current position of the ChannelHandler which is bound to the ChannelHandlerContext and so only pass those ChannelOutboundHandlers that are in front of it.</li>
</ul>
<h4 id="自定义消息协议"><a href="#自定义消息协议" class="headerlink" title="自定义消息协议"></a>自定义消息协议</h4><ul>
<li><p>len : 表示消息的长度,通常用4个字节保存</p>
</li>
<li><p>head : 消息头部</p>
</li>
<li><p>body : 消息内容</p>
</li>
<li><p>在实际的项目中,消息格式可能会增加一些标志,例如,开始标记,结束标志,消息序列号,消息的协议类型(json或者二进制等)</p>
</li>
</ul>
<h3 id="Netty-没用JDK1-7的AIO"><a href="#Netty-没用JDK1-7的AIO" class="headerlink" title="Netty 没用JDK1.7的AIO"></a>Netty 没用JDK1.7的AIO</h3><ul>
<li>为什么Netty不用AIO而用NIO?</li>
</ul>
<pre>
According to the book the main reasons were:
1. Not faster than NIO (epoll) on unix systems (which is true)
There is no daragram suppport
2. Unnecessary threading model (too much abstraction without usage)
3. I agree that AIO will not easily replace NIO, but it is useful for windows developers nonetheless.
<https: 2515 github.com netty issues>
We obviously did not consider Windows as a serious platform so far, and that's why we were neglecting NIO.2 AIO API which was implemented using IOCP on Windows. (On Linux, it wasn't any faster because it was using the same OS facility - epoll.)
</https:></pre>

<h3 id="Netty-Epoll"><a href="#Netty-Epoll" class="headerlink" title="Netty-Epoll"></a>Netty-Epoll</h3><ul>
<li>Selector 实现原理:<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2b71ea919d49">http://www.jianshu.com/p/2b71ea919d49</a></li>
</ul>
<ul>
<li>epoll的两种工作模式：<ul>
<li>LT：level-trigger，水平触发模式，只要某个socket处于readable&#x2F;writable状态，无论什么时候进行epoll_wait都会返回该socket。<br>  当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。<br>  当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。<br>  ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
</li>
<li>在Linux系统中JDK NIO使用的是 LT ，而Netty epoll使用的是 ET。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>JDK中有自带的ByteBuffer类，但是netty中的 ByteBuf 算是对Byte Buffer的重新实现。他们没有关联关系。</li>
<li>netty推荐使用<code>io.netty.buffer.Unpooled</code>来进行Buff的创建工作。Unpooled是一个工具类，可以为ByteBuf分配空间、拷贝或者封装操作</li>
<li>DirectBuffer：使用 DirectBuffer 是一种更加接近系统底层的方法，所以，它的速度比普通的 ByteBuffer 更快。DirectBuffer 相对于 ByteBuffer 而言，读写访问速度快很多，但是创建和销毁 DirectBuffer 的花费却比 ByteBuffer 高。</li>
<li>Netty的并发处理能力主要体现在两个方面：<ol>
<li>利用Java语言自身的多线程机制实现消息的并行处理；</li>
<li>利用Java NIO类库的Selector实现多路复用，一个NIO线程可以同时并发处理成百上千个通信链路，实现海量客户端的并发接入和处理。</li>
</ol>
</li>
<li>netty.pipeline执行顺序：在给定的示例配置中，当事件进入到入站时，处理程序计算顺序为(代码行：从上到下)。当一个事件出站时，顺序是(代码行：从下到上)。</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/netty-high-performance">Netty系列之Netty高性能之道</a>  </li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/linsongbin1/article/details/77915686">Netty实战-自定义解码器处理半包消息</a></li>
<li>TODO nio-demo&#x2F;docs</li>
<li>TODO nio_demo&#x2F;netty-definitive-guide&#x2F;netty-definitive-guide-notes.md</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/" itemprop="url">如何做数据库迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-14T11:26:02+08:00">
                2022-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先抛出以下问题：<br>把MHA-1集群的Database-C 迁到 MHA-2 集群中，有没有简单高效的方案?<br><img src="/2022/01/14/20220114-ru-he-zuo-shu-ju-ku-qian-yi/migration.png"></p>
<hr>
<ul>
<li>方案1、在两个MHA集群，在建一套MHA3。MHA2的主作为MHA1的从？这样MH3切换的时候，应用服务就可以直接感知切到新库了；</li>
<li>方案2、先把C同步到2集群，然后做otter同步</li>
</ul>
<hr>
<ul>
<li>方案1： 存在的问题：<ul>
<li>中间再搞一套MHA，不是运维麻烦，而是多了一套中间库，可能会导致MHA的切换逻辑紊乱。</li>
</ul>
</li>
<li>方案2： <ul>
<li>业务方的服务要自行选择数据源进行切换 （流量低且数据一致性要求不高，考虑通过开关切换；否则需考虑停服等其他方案）</li>
<li>otter双向同步，业务最好同时只写一边（要注意旧库是否有自增主键；同步冲突策略设置，默认会冲突会同步中断）</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/27/20211027-raft-xue-xi-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/27/20211027-raft-xue-xi-bi-ji/" itemprop="url">raft学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-27T10:42:07+08:00">
                2021-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>Raft将共识问题分解三个子问题：</p>
<ol>
<li>Leader election 领导选举：有且仅有一个leader节点，如果leader宕机，通过选举机制选出新的leader；</li>
<li>Log replication 日志复制：leader从客户端接收数据更新&#x2F;删除请求，然后日志复制到follower节点，从而保证集群数据的一致性；</li>
<li>Safety 安全性：通过安全性原则来处理一些特殊case，保证Raft算法的完备性；</li>
</ol>
</li>
<li><p>所以，Raft算法核心流程可以归纳为：</p>
<ul>
<li>首先选出leader，leader节点负责接收外部的数据更新&#x2F;删除请求；</li>
<li>然后日志复制到其他follower节点，同时通过安全性的准则来保证整个日志复制的一致性；</li>
<li>如果遇到leader故障，followers会重新发起选举出新的leader；</li>
</ul>
</li>
<li><p>Raft规定：只有拥有最新提交日志的follower节点才有资格成为leader节点。具体做法：candidate竞选投票时会携带最新提交日志，follower会用自己的日志和candidate做比较。</p>
</li>
<li><p>因为日志提交需要超过半数的节点同意，所以针对日志同步落后的follower（还未同步完全部日志，导致落后于其他节点）在竞选leader的时候，肯定拿不到超过半数的票，也只有那些完成同步的才有可能获取超过半数的票成为leader。</p>
</li>
<li><p>日志更新判断方式是比较日志项的term和index：</p>
<ul>
<li>如果TermId不同，选择TermId最大的；</li>
<li>如果TermId相同，选择Index最大的；</li>
</ul>
</li>
<li><p>Raft对日志提交有额外安全机制：leader只能提交当前任期Term的日志，旧任期Term（以前的数据）只能通过当前任期Term的数据提交来间接完成提交。简单的说，日志提交有两个条件需要满足：</p>
<ul>
<li>当前任期；</li>
<li>复制结点超过半数；</li>
</ul>
</li>
<li><p>Raft在日志项提交上增加了限制：只有当前任期且复制超过半数的日志才可以提交。</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/obnZm2Lhf_rKla2AxbrBlg">分布式一致性算法Raft</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zMnqOCUVvRLQuJUwvM3QRA">Raft 一致性算法论文中文译文</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/12/20211012-cqrs-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/12/20211012-cqrs-bi-ji/" itemprop="url">CQRS笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-12T18:37:20+08:00">
                2021-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/backend-development-cqrs/">后端开发实践系列——简单可用的CQRS编码实践</a></li>
<li></li>
</ul>
<h3 id="个人认为："><a href="#个人认为：" class="headerlink" title="个人认为："></a>个人认为：</h3><ol>
<li>清除消息业务：写时只记录一个”清除时间”，读时只读取”清除时间”之后的数据，这是一种CQRS (避免写时操作太多数据，QPS不高，但单个请求需要操作多条数据的情况)</li>
<li>消息通知业务：写时只写在redis，定时任务从redis批量获取数据逐步写入的数据库（QPS高，但单个请求却不多，可以批量操作的情况）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/12/20211012-fen-bu-shi-li-lun-xiang-guan-zheng-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/12/20211012-fen-bu-shi-li-lun-xiang-guan-zheng-li/" itemprop="url">分布式理论相关整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-12T17:46:33+08:00">
                2021-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>分布式存储系统通常通过维护多个副本来进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题：维护多个副本的一致性。</li>
<li>一致性（consensus）,它是构建具有容错性（fault-tolerant）的分布式系统的基础。 在一个具有一致性的性质的集群里面，同一时刻所有的结点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致。集群具有自动恢复的性质，当少数结点失效的时候不影响集群的正常工作，当大多数集群中的结点失效的时候，集群则会停止服务（不会返回一个错误的结果）。</li>
<li>一致性协议就是用来保证即使在部分(确切地说是小部分)副本宕机的情况下，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。</li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><ul>
<li>[分布式架构的套路](&lt;<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vJJWpIZ-bTzVl9E3wPLlEw">https://mp.weixin.qq.com/s/vJJWpIZ-bTzVl9E3wPLlEw</a>)<ul>
<li>1、纯负载均衡形式。<br>硬件层面的 F5、软件层面的 nginx</li>
<li>2、领导选举型<br>整个集群的消息都会转发到集群的领导这里，是一种 master-slavers，区别只是这个 master 是被临时选举出来的，一旦 master 宕机，集群会立刻选举出一个新的领导，继续对外提供服务。<br>ElasticSearch，zookeeper、Raft</li>
<li>3、区块链型<br>整个集群的每一个节点都可以进行记录，但是记录的内容要得到整个集群 N 个机器的认可才是合法的。典型的应用有 Bit Coin，以及 Hyperledger。</li>
<li>4、master-slaver型<br>整个集群以某台 master 为中枢，进行集群的调度。交互是这样，一般会把所有的管理类型的数据放到 master 上，而把具体的数据放到 slaver 上，实际进行调用的时候，client 先调用 master 获取数据所存放的 server 的 信息，再自行跟 slave 进行交互。典型的系统有 Hadoop。集群，HBase 集群，Redis 集群等。</li>
<li>5、规则型一致性Hash<br>这种架构类型一般出现在数据库分库分表的设计中。按照规则进行分库分表，在查询之前使用规则引擎进行库和表的确认，再对具体的应用进行访问。为什么要用一致性 Hash ？其实用什么都可以，只是对于这类应用来说一致性 Hash 比较常见而已。</li>
</ul>
</li>
</ul>
<h3 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a>副本一致性</h3><ol>
<li>强一致性(strong consistency)</li>
<li>单调一致性(monotonic consistency):任何时刻,任何用户一旦读到某个数据在某次更新后的值, 这个用户不会再读到比这个值更旧的值。</li>
<li>会话一致性(session consistency)：在同一个会话内，系统保证读己所写的一致性。</li>
<li>最终一致性(eventual consistency):如果没有更新，最终系统会返回最后更新的值。换句话说，如果系统在持续更新，则永远无法达到一致性。</li>
<li>弱一致性(week consistency)：系统并不保证后续读操作获得更新值的时间点;弱一致性系统 一般很难在实际中使用,使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li>
<li>因果一致性：和写进程具有因果关系的进程将会读取到更新的数据，写进程保证取代上次更更新。</li>
<li>读己所写一致性：进程永远读取自己上次更新写入的最新值，而不可能读取到任何历史数据。这是传统操作系统默认的一致性行为。</li>
</ol>
<h3 id="分布式系统中的一致性模型"><a href="#分布式系统中的一致性模型" class="headerlink" title="分布式系统中的一致性模型"></a>分布式系统中的一致性模型</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_yJqXUIQ7ka8f46j3VCbuQ">分布式系统中的一致性模型</a></li>
<li>一致性模型是所有被允许的操作记录的集合。当我们运行一个程序，经过一系列集合中允许的操作，特定的执行结果总是一致的。如果程序意外地执行了非集合中的操作，我们就称执行记录是非一致的。如果任意可能的执行操作都在这个被允许的操作集合内，那么系统就满足一致性模型。</li>
<li>现实往往没有那么理想化：在几乎每个实际的系统中，进程之间都有一定的距离。一个没有被缓存的值（指没有被CPU的local cache缓存），通常在距离CPU30厘米的DIMM内存条上。光需要整整一个纳秒来传播这么长的距离，实际的内存访问会比光速慢得多。位于不同数据中心某台计算机上的值可以相距几千公里——意味着需要几百毫秒的传播时间。我们没有更快传播数据的方法，否则就违反了物理定律。（物理定律都违反了，就更别谈什么现代计算机体系了。）</li>
<li>这意味着我们的操作不再是瞬时的。某些操作也许快到可以被近乎认为是瞬时的，但是通常来说，操作是耗时的。我们调用对一个变量的写操作；写操作传播到内存，或其他计算机，或月球；内存改变状态；一个确认信息回传；这样我们才知道这个操作真实的发生了。</li>
<li>在分布式系统中，操作的耗时被放大了，我们必须使一致性模型更宽松：允许这些有歧义的顺序发生。</li>
<li>我们该如何确定宽松的程度？我们必须允许所有可能的顺序吗？或许我们还是应该强加一些合理性约束？</li>
</ul>
<ol>
<li>线性一致性（Linearizability）<ul>
<li>线性一致性模型提供了这样的保证：1.对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进。2.所有的读总能返回最近的写操作的值。</li>
</ul>
</li>
<li>顺序一致性（Sequential consistency）<ul>
<li>如果我们允许进程在时间维度发生偏移，从而它们的操作可能会在调用之前或是完成之后生效，但仍然保证一个约束——任意进程中的操作必须按照进程中定义的顺序（即编程的定义的逻辑顺序）发生。这样我们就得到了一个稍弱的一致性模型：顺序一致性。</li>
<li>顺序一致性放松了对一致性的要求：1. 不要求操作按照真实的时间序发生。2. 不同进程间的操作执行先后顺序也没有强制要求，但必须是原子的。3. 单个进程内的操作顺序必须和编码时的顺序一致。</li>
<li>如果我在Twitter上写了一条推文，或是在Facebook发布了一篇帖子，都会耗费一定的时间渗透进一层层的缓存系统。不同的用户将在不同的时间看到我的信息，但每个用户都以同一个顺序看到我的操作。一旦看到，这篇帖子便不会消失。如果我写了多条评论，其他人也会按顺序的看见，而非乱序。</li>
</ul>
</li>
<li>因果一致性（Casual consistency）<ul>
<li>我们不必对一个进程中的每个操作都施加顺序约束。只有因果相关的操作必须按顺序发生。同样拿帖子举例子：一篇帖子下的所有评论必须以同样的顺序展示给所有人，并且只有帖子可见后，帖子下的回复才可见（也就是说帖子和帖子下的评论有因果关系）。如果我们将这些因果关系编码成类似“我依赖于操作X”的形式，作为每个操作明确的一部分，数据库就可以将这些操作延迟直到它们的依赖都就绪后才可见。</li>
<li>因果一致性比同一进程下对每个操作严格排序的一致性（即顺序一致性）来的更宽松——属于同一进程但不同因果关系链的操作能以相对的顺序执行（也就是说按因果关系隔离，无因果关系的操作可以并发执行），这能防止许多不直观的行为发生。</li>
</ul>
</li>
<li>串行一致性（Serializable consistency）<ul>
<li>如果我们说操作记录的发生等效于某些单一的原子序，但和调用时间与完成时间无关，那么我们就得到了名为串行一致性的一致性模型。这一模型比你想象的更强大同时也更脆弱。</li>
<li>因为串行一致性允许对操作顺序执行任意的重排（只要操作顺序是原子序的）， 它在实际的场景中并不是十分有用。大多数宣称提供了串行一致性的数据库实际上提供的是强串行一致性，它有着和线性一致性一样的时间边界。让事情更复杂的是，大多数SQL数据库宣称的串行一致性等级比实际的更弱，比如可重复读，游标稳定性，或是快照隔离性。</li>
<li>关于线性一致性和串行一致性，看似十分相似，其实不然。串行一致性是数据库领域的概念，是针对事务而言的，描述对一组事务的执行效果等同于某种串行的执行，没有ordering的概念，而线性一致性来自并行计算领域，描述了针对某种数据结构的操作所表现出的顺序特征。串行一致性是对多操作，多对象的保证，对总体的操作顺序无要求；线性一致性是对单操作，单对象的保证，所有操作遵循真实时间序</li>
</ul>
</li>
<li>FIFO 一致性（FIFO consistency, 又称 PRAM consistency, pipelined RAM consistency）。<ul>
<li>FIFO 一致性不会考虑多个进程之间的操作排序。对任意一个进程的写操作 1 与写操作 2，若写操作 1 先于写操作 2 完成，那么任何进程不可以先读到写操作 2 的值，再读到写操作 1 的值。</li>
</ul>
</li>
</ol>
<ul>
<li>强一致（strict consistency），通常是指线性一致性或顺序一致性。线性一致性与顺序一致性之间的区别，也可以被理解为系统模型的区别，即系统中是否存在绝对时间。弱于顺序一致性的一致性级别都可被称为弱一致，而最终一致性是弱一致性的一种形式。</li>
</ul>
<h3 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a>衡量分布式系统的指标</h3><ul>
<li>性能</li>
<li>可用性</li>
<li>可扩展性</li>
<li>一致性</li>
</ul>
<h3 id="基本副本协议"><a href="#基本副本协议" class="headerlink" title="基本副本协议"></a>基本副本协议</h3><ul>
<li>副本控制协议分为两大类:“中心化(centralized)副本控制协议”和“去中心化(decentralized) 副本控制协议”。</li>
</ul>
<ol>
<li>中心化副本控制协议<ul>
<li>primary-secondary 协议</li>
</ul>
</li>
<li>去中心化副本控制协议(去中心化协议没有因为中心化节点异常而带来的停服务等问题。)</li>
</ol>
<h3 id="NWR-机制"><a href="#NWR-机制" class="headerlink" title="NWR 机制"></a>NWR 机制</h3><ul>
<li>首先看看这三个字母在分布式系统中的含义：<ul>
<li>N：有多少份数据副本；</li>
<li>W：一次成功的写操作至少有w份数据写入成功；</li>
<li>R：一次成功的读操作至少有R份数据读取成功。</li>
</ul>
</li>
<li>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N的时候，读取操作和写入操作成功的数据一定会有交集，这样就可以保证一定能够读取到最新版本的更新数据，数据的强一致性得到了保证，如果R+W&lt;&#x3D;N，则无法保证数据的强一致性，因为成功写和成功读集合可能不存在交集，这样读操作无法读取到最新的更新数值，也就无法保证数据的强一致性。</li>
<li>版本的新旧需要版本控制算法来判别，比如向量时钟。</li>
<li>当然R或者W不能太大，因为越大需要操作的副本越多，耗时越长。</li>
</ul>
<h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a>Quorum 机制</h3><ul>
<li>Quorum机制其实就是NWR机制。</li>
</ul>
<ol>
<li>Write-all-read-one(简称 WARO).<ul>
<li>WARO 读服务的可用性较高,但更新服务的可用性不高,甚至虽然使用了 副本,但更新服务的可用性等效于没有副本。WARO 牺牲了更新服务的可用性,最大程度的增强读服务的可用性。</li>
</ul>
</li>
<li>Quorum 机制</li>
</ol>
<ul>
<li>将 WARO 的条件进行松弛,从而使得可以在读写服务可用性之间做折中,得出 Quorum 机制。</li>
<li>在 Quorum 机制下,当某次更新操作 wi 一旦在所有 N 个副本中的 W 个副本上都成功,则就称 该更新操作为“成功提交的更新操作”,称对应的数据为“成功提交的数据”。</li>
<li>仅仅依赖 quorum 机制是无法保证强一致性的。因为仅有 quorum 机制时无法确 定最新已成功提交的版本号,除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数 据集群管理,否则很难确定最新成功提交的版本号。</li>
<li>Quorum 机制的三个系统参数 N、W、R 控制了系统的可用性,也是系统对用户的服务承诺:数 据最多有 N 个副本,但数据更新成功 W 个副本即返回用户成功。对于一致性要求较高的 Quorum 系 统,系统还应该承诺任何时候不读取未成功提交的数据,即读取到的数据都是曾经在 W 个副本上成 功的数据。</li>
</ul>
<hr>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5626889.html">分布式系统理论之Quorum机制</a></p>
</li>
<li><p>在分布式系统中有个CAP理论，对于P（分区容忍性）而言，是实际存在 从而无法避免的。因为，分布系统中的处理不是在本机，而是网络中的许多机器相互通信，故网络分区、网络通信故障问题无法避免。<br>因此，只能尽量地在C 和 A 之间寻求平衡。对于数据存储而言，为了提高可用性（Availability），采用了副本备份，比如对于HDFS，默认每块数据存三份。某数据块所在的机器宕机了，就去该数据块副本所在的机器上读取（从这可以看出，数据分布方式是按“数据块”为单位分布的）</p>
</li>
<li><p>但是，问题来了，当需要修改数据时，就需要更新所有的副本数据，这样才能保证数据的一致性（Consistency）。因此，就需要在 C(Consistency) 和 A(Availability) 之间权衡。</p>
</li>
<li><p>Quorum机制，就是这样的一种权衡机制，一种将“读写转化”的模型。在介绍Quorum之前，先看一个极端的情况：WARO机制。<br>WARO(Write All Read one)是一种简单的副本控制协议，当Client请求向某副本写数据时(更新数据)，只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</p>
<ul>
<li>①写操作很脆弱，因为只要有一个副本更新失败，此次写操作就视为失败了。②读操作很简单，因为，所有的副本更新成功，才视为更新成功，从而保证所有的副本一致。<br>  这样，只需要读任何一个副本上的数据即可。假设有N个副本，N-1个都宕机了，剩下的那个副本仍能提供读服务；但是只要有一个副本宕机了，写服务就不会成功。</li>
<li>WARO牺牲了更新服务的可用性，最大程度地增强了读服务的可用性。而Quorum就是更新服务和读服务之间进行一个折衷。</li>
<li>Quorum机制是“抽屉原理”的一个应用。定义如下：假设有N个副本，更新操作wi 在W个副本中更新成功之后，才认为此次更新操作wi 成功。称成功提交的更新操作对应的数据为：“成功提交的数据”。对于读操作而言，至少需要读R个副本才能读到此次更新的数据。其中，W+R&gt;N ，即W和R有重叠。一般，W+R&#x3D;N+1</li>
<li>5(3+3,5+1);7(4+4,5+3,7+1);9(5+5,7+3,9+1)</li>
</ul>
</li>
<li><p>1）如何读取最新的数据？—在已经知道最近成功提交的数据版本号的前提下，最多读R个副本就可以读到最新的数据了。<br>2）如何确定 最高版本号 的数据是一个成功提交的数据？—继续读其他的副本，直到读到的 最高版本号副本 出现了W次。</p>
</li>
<li><p>一般一个Quorum的节点数目不大于9个，故无法简单地将一致性系统节点直接部署在多个地域，系统需要能持续地水平拓展，来满足服务、资源的拓展需求</p>
</li>
</ul>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><ul>
<li>Consistency (一致性):CAP 理论中的副本一致性特指强一致性(1.3.4 );</li>
<li>Availiablity(可用性):指系统在出现异常时已经可以提供服务;</li>
<li>Tolerance to the partition of network (分区容忍):指系统可以对网络分区(1.1.4.2 )这种异常情 况进行容错处理;</li>
<li>协议分析<br>1. Lease 机制牺牲了部分异常情况下的 A,从而获得了完全的 C 与很好的 P。<br>2. Quorum 机制,在 CAP 三大因素中都各做了折中,有一定的 C,有较好 的 A,也有较好的 P,是一种较为平衡的分布式协议。<br>3. 两阶段提交系统具有完全的 C,很糟糕的 A,很糟糕的 P。<br>4. Paxos 协议 ,在 CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的 C,较好的 A,较好的 P。Paxos 的 A 与 P 的属性与 Quorum 机制类似,因为 Paxos 的协议本 身就具有 Quorum 机制的因素。</li>
<li>CAP中的三个因素并不对等，P是基础，CA之间需要tradeoff。系统设计不是三选二的取舍。</li>
<li>延迟作为可用性的指标和体现，系统设计通常需要在C和延迟之间tradeoff。</li>
<li>总结：P是一个自然的事实，CA是强需求。三者并不对等。</li>
<li>在数据库领域，CAP也正是ACID和BASE长期博弈(tradeoff)的结果。</li>
<li>ACID伴随数据库的诞生定义了系统基本设计思路，所谓先入为主。2000年左右，随着互联网的发展，高可用的话题被摆上桌面，所以提出了BASE。从此C和A的取舍消长此起彼伏，其结晶就是CAP理论。</li>
<li>从ACID和BASE来说，ACID是为了保证一致性而诞生，因而侧重一致性；BASE是为了高可用系统的设计而诞生，因而侧重可用性。在分解C和A的情况时，肯定要涉及P，所以CAP理论统一了这一切。如果非要说酸碱，或者说酸碱平衡，那就是平衡于CAP理论。</li>
<li>CAP并不与ACID中的A（原子性）冲突，值得讨论的是ACID中的C（一致性）和I（隔离性）。ACID的C指的是事务不能破坏任何数据库规则，如键的唯一性。与之相比，CAP的C仅指单一副本这个意义上的一致性，因此只是ACID一致性约束的一个严格的子集。如果系统要求ACID中的I（隔离性），那么它在分区期间最多可以在分区一侧维持操作。事务的可串行性（serializability）要求全局的通信，因此在分区的情况下不能成立。</li>
<li>CA系统才是真正的难点。宣称是CA系统的，目前有两家：一家是Google的Spanner，一家是Alibaba的OceanBase。</li>
<li>对P的分解需要从网络开始。网络包含了基础设施，光速限制以及软件配置与升级等。Google通过建设自己广域网获得高可靠的基础设施支撑，对于Google Spanner的CA系统，CAP之父曾总结说网络才是根本。</li>
<li>CAP理论：一致性与性能之间的trade-off</li>
</ul>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/V1sJcSjff1wbAoQVpLgUMA">请不要再称数据库是CP或者AP</a></li>
<li>一致性（Consistency）在CAP中是可线性化的意思（linearizability）。而这个是非常特殊（而且非常强）的一致性。尤其是虽然ACID中的C也是一致性（Consistency），但是和这里的一致性没有任何关系。</li>
<li>Alice还有Bob，他们在同一个房间，都在看他们的手机查2014年世界杯的决赛结果。就在最终结果刚发布之后，Alice刷新了页面，看到了宣布冠军，而且很兴奋地告诉了Bob。Bob马上也重新加载了他手机上的页面，但是他的请求被送到了一个数据库的拷贝，还没有拿到最新的数据，结果他的手机上显示决赛还正在进行。</li>
<li>如果Alice和Bob同时刷新，拿到了不一样的结果，并不会太让人意外。因为他们不知道具体服务器到底是先处理了他们中哪一个请求。但是Bob知道他刷新页面是在Alice告诉了他最终结果_之后_的。所以他预期他查询的结果一定比Alice的更新。事实是，他却拿到了旧的结果。这就违反了可线性化。</li>
<li>ZooKeeper默认设置既不是一致的（CP）也不是可用的（AP），只是“P”。但是你有选择通过用sync命令来让它成为CP。并且在正确的设置下，读操作（不包括写）其实是CAP可用的。</li>
</ul>
<h3 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a>Lease 机制</h3><ul>
<li>Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出 lease,则无论接受方是否收到,也无论后续接收方处于何种状态,只要 lease 不过期,颁发者一 定严守承诺;另一方面,接收方在 lease 的有效期内可以使用颁发者的承诺,但一旦 lease 过期,接 收方一定不能继续使用颁发者的承诺。</li>
<li>Lease 机制依赖于有效期,这就要求颁发者和接收者的时钟是同步的。对于这种时钟不同步,实践中的通常做法是 将颁发者的有效期设置得比接收者的略大,只需大过时钟误差就可以避免对 lease 的有效性的影响。</li>
</ul>
<hr>
<ul>
<li>master给各个slave分配不同的数据，每个节点的数据都具有有效时间比如1小时，在lease时间内，客户端可以直接向slave请求数据，如果超过时间客户端就去master请求数据。一般而言，slave可以定时主动向master要求续租并更新数据，master在数据发生变化时也可以主动通知slave，不同方式的选择也在于可用性与一致性之间进行权衡。</li>
<li>租约机制也可以解决主备之间网络不通导致的双主脑裂问题，亦即：主备之间本来心跳连线的，但是突然之间网络不通或者暂停又恢复了或者太繁忙无法回复，这时备机开始接管服务，但是主机依然存活能对外服务，这是就发生争夺与分区，但是引入lease的话，老主机颁发给具体server的lease必然较旧，请求就失效了，老主机自动退出对外服务，备机完全接管服务。</li>
</ul>
<h3 id="Split-Brain"><a href="#Split-Brain" class="headerlink" title="Split Brain"></a>Split Brain</h3><ul>
<li>如何避免“Split Brain”(脑裂)问题？<ul>
<li>Split Brain 是指在同一时刻有两个认为自己处于 Active 状态的 NameNode。</li>
</ul>
</li>
<li>Raft是一种一致性算法， gossip是广播协议</li>
<li>为 Raft 引入 leader lease 机制解决集群脑裂时的 stale read 问题：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/072380e12657">https://www.jianshu.com/p/072380e12657</a><ul>
<li>这种方法牺牲了一定的可用性（在脑裂时部分客户端的可用性）换取了一致性的保证。</li>
<li>多数派的网络分区挂了，岂不是直接不可写？</li>
</ul>
</li>
</ul>
<h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><ul>
<li>拜占庭将军问题提供了对分布式共识问题的一种情景化描述，是分布式系统领域最复杂的模型。此外, 它也为我们理解和分类现有的众多分布式一致性协议和算法提供了框架。现有的分布式一致性协议和算法主要可分为两类：<br>  1. 一类是故障容错算法(Crash Fault Tolerance, CFT)， 即非拜占庭容错算法，解决的是分布式系统中存在故障，但不存在恶意攻击的场景下的共识问题。也就是说，在该场景下可能存在消息丢失，消息重复，但不存在消息被篡改或伪造的场景。一般用于局域网场景下的分布式系统，如分布式数据库。属于此类的常见算法有Paxos算法、Raft算法、ZAB协议等。<br>  2. 一类是拜占庭容错算法，可以解决分布式系统中既存在故障，又存在恶意攻击场景下的共识问题。一般用于互联网场景下的分布式系统，如在数字货币的区块链技术中。属于此类的常见算法有PBFT算法、PoW算法。</li>
</ul>
<h3 id="CAP软件分类"><a href="#CAP软件分类" class="headerlink" title="CAP软件分类"></a>CAP软件分类</h3><ul>
<li>CP: MongoDB、HBase、Zookeeper; (paxos、raft、zab、2PC协议)</li>
<li>AP: Eureka、Couch DB、Cassandra、Amazon Dynamo</li>
<li>Raft (etcd)、ZAB(Zookeeper)</li>
</ul>
<h3 id="故障处理如何做？有以下模型可以考虑"><a href="#故障处理如何做？有以下模型可以考虑" class="headerlink" title="故障处理如何做？有以下模型可以考虑"></a>故障处理如何做？有以下模型可以考虑</h3><ul>
<li><p>Fail-Fast：从字面含义看就是“快速失败”，尽可能的发现系统中的错误，使系统能够按照事先设定好的错误的流程执行，对应的方式是“fault-tolerant（容错）”。只发起一次调用，失败立即报错,通常用于非幂等性的写操作。 如果有机器正在重启，可能会出现调用失败 。</p>
</li>
<li><p>Fail-Over：含义为“失效转移”，是一种备份操作模式，当主要组件异常时，其功能转移到备份组件。其要点在于有主有备，且主故障时备可启用，并设置为主。如Mysql的双Master模式，当正在使用的Master出现故障时，可以拿备Master做主使用。阿里同学认为这里可以指失败自动切换。当出现失败，重试其它服务器，通常用于读操作（推荐使用）。 重试会带来更长延迟。</p>
</li>
<li><p>Fail-Safe：含义为“失效安全”，即使在故障的情况下也不会造成伤害或者尽量减少伤害。维基百科上一个形象的例子是红绿灯的“冲突监测模块”当监测到错误或者冲突的信号时会将十字路口的红绿灯变为闪烁错误模式，而不是全部显示为绿灯。有时候来指代“自动功能降级” (Auto-Degrade)。阿里的同学认为失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。调用信息丢失 可用于生产环境Monitor。</p>
</li>
<li><p>Fail-Back：Fail-over之后的自动恢复，在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复。阿里的同学认为失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作 不可靠，重启丢失。可用于生产环境 Registry。</p>
</li>
<li><p>Forking  并行调用多个服务器，只要一个成功即返回，通常用于实时性要求较高的读操作。 需要浪费更多服务资源 。</p>
</li>
<li><p>Broadcast广播调用，所有提供逐个调用，任意一台报错则报错。通常用于更新提供方本地状态速度慢，任意一台报错则报错。</p>
</li>
<li><p>上述故障模型是从系统设计的角度出发的，根据不同的需要设计不同故障处理方案。现在看来，系统的外延已经扩大。系统的容错性，或者分区容错能力，不能仅仅使用事先和事中的方案解决，系统的容错性还包括事后处理。</p>
</li>
<li><p>分布式系统(Distributed System)资料:<a target="_blank" rel="noopener" href="https://github.com/ty4z2008/Qix/blob/master/ds.md">https://github.com/ty4z2008/Qix/blob/master/ds.md</a></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html">学习笔记：The Log（我所读过的最好的一篇分布式技术文章）</a></li>
<li>《分布式系统原理介绍刘杰》</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5626889.html">分布式系统理论之Quorum机制</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650738983&idx=4&sn=6d59ee01f70f2bff3df373dd9381e31f&chksm=bea760f489d0e9e">一文读懂拜占庭将军问题</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UfbMFXxJqRhLDXUntKVE8A">详解分布式一致性机制</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/90RAmLZcTshlm-MBjTlP0A">CAP理论与分布式系统设计</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IbBC38rhhQ-mEfw3yf9AVA">深度介绍分布式系统原理与设计</a>!!</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/05-ko4KyeHOTkrAbl8dQwQ">跨地域场景下，如何解决分布式系统的一致性？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KbNNU246BAeJmLoWbKie6g">左耳朵耗子：分布式系统架构经典资料</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/L7Zjbbub2D6pWto0TZ2qug">如何系统性的学习分布式系统？</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/17/20210917-tong-guo-pan-duan-ding-dan-zhuang-tai-shi-fou-ke-yi-bi-mian-bing-fa-dao-zhi-de-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/17/20210917-tong-guo-pan-duan-ding-dan-zhuang-tai-shi-fou-ke-yi-bi-mian-bing-fa-dao-zhi-de-wen-ti/" itemprop="url">通过判断订单状态是否可以避免并发导致的问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-17T17:17:35+08:00">
                2021-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>首先重温一个问题：<a target="_blank" rel="noopener" href="https://kingson4wu.github.io/2020/07/05/20200705-RPC%E5%8F%AF%E4%BB%A5%E5%92%8C%E4%BA%8B%E5%8A%A1%E7%BB%91%E5%AE%9A%E5%90%97/">RPC可以和事务绑定吗？</a></p>
</li>
<li><p>有以下业务场景：</p>
<ul>
<li>用户扣钱成功之后，可以玩一局游戏；如果用户没成功玩游戏，需要将已扣的钱退回给用户。</li>
</ul>
</li>
<li><p>服务架构：服务A(游戏服务)，服务B(用户资产服务)。</p>
</li>
<li><p>游戏订单状态：1（初始状态）；2（扣费成功）；3（退费成功）；4（不存在）</p>
</li>
<li><p>实现基本流程如下：</p>
</li>
<li><p>流程1:</p>
<pre>
玩游戏请求----------> 服务A
           [无事务] 
           [1.插入游戏订单（订单状态：1）]
           [2.RPC进行扣费]------------------------------------------------>服务B
           [3.更新游戏订单状态（1-> 2）(DB操作)] 
           （订单状态为2的可以参与游戏）</pre></li>
</ul>
<p></p>
<ul>
<li>流程2 （针对扣费成功但超时返回的情况）:<pre>
定时任务补偿----------> 服务A
           [无事务] 
           [1.查询订单状态为1的订单]
           [2.RPC查询扣费订单是否存在]------------------------------->服务B
           [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
           [3_2.存在 -- RPC取消扣费] ---------------------------------------->服务B
           [4.更新游戏订单状态（1-> 3）(DB操作)]</pre></li>
</ul>
<p></p>
<ul>
<li>流程1 和 流程2 在并发执行的时候会存在 用户退费成功但仍然可以玩游戏的问题：<ul>
<li>执行流程1中步骤2</li>
<li>执行流程2中步骤3_2</li>
<li>执行流程1中步骤3</li>
</ul>
</li>
</ul>
<h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h3><ul>
<li>加入订单时间校验：超过n分钟后的订单才允许退款（可以很大避免以上问题的发生，因为一个请求基本不可能执行几分钟还没结束）</li>
</ul>
<pre>
定时任务补偿----------> 服务A
             [无事务] 
             [0.查询订单状态为1的订单]
    新增判断 -   [1.查询订单创建时间是否超过n分钟，不满足暂不退款，中断执行] 
             [2.RPC查询扣费订单是否存在]------------------------------->服务B
             [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
             [3_2.存在 -- RPC取消扣费] ---------------------------------------->服务B
             [4.更新游戏订单状态（1-> 3）(DB操作)]
</pre>

<ul>
<li>该方案的缺点<ul>
<li>如果设置的订单退款超时时间太长，会导致用户被误扣的钱长时间未退款，引起投诉</li>
<li>设置足够合理的超时时间就一定能避免这个问题的发生了吗？不会存在极端情况，请求执行时间过长？</li>
</ul>
</li>
</ul>
<h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h3><ul>
<li>回到本文的标题。</li>
<li>通过和RPC绑事务的方式，也可以解决这个问题（不用通过配置时间差），本质是通过数据库锁的方式来解决。</li>
</ul>
<pre>
定时任务补偿----------> 服务A
             [1.查询订单状态为1的订单]
             [2.RPC查询扣费订单是否存在]------------------------------->服务B
             [3_1.不存在 -- 更新游戏订单状态（1-> 4）(DB操作)] 
             [新建事务] 
             [3_2.存在 -- 更新订单状态（1-> 3）(DB操作)]
             [ if （row = UPDATE order SET status = 3 WHERE status = 1) > 0 ]
             [4. RPC取消扣费] ---------------------------------------->服务B
             [5_1. 调用成功 - 提交事务]
             [5_1. 调用失败 - 异常回滚事务]
</pre>

<ol>
<li>扣费的时候，update order set status &#x3D; ’成功‘ where status &#x3D; ’初始状态‘ ；update raw &#x3D;&#x3D; 1 时， 执行RPC 冻结， 否则抛异常回滚事务</li>
<li>定时任务补偿退款的时候，update order set status &#x3D; ’取消冻结成功‘ where status &#x3D; ’初始状态‘ ；update row &#x3D;&#x3D; 1 时， 执行RPC 取消冻结， 否则抛异常回滚事务<ul>
<li>实际情况会比描述的复杂，因为status的最终值设置是根据RPC的结果来的，而不是一开始就能确定的；解决方案<ol>
<li>新加字段，统一 update 未执行 到 已执行， 通过新字段来判断是否执行db成功</li>
</ol>
</li>
</ul>
<ol start="2">
<li>select for update， 查的时候锁住该行数据</li>
<li>其他？</li>
</ol>
</li>
</ol>
<h3 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h3><ul>
<li>方案1和方案2的结合</li>
</ul>
<ol>
<li>1分钟后才执行流程2退费</li>
<li>流程2中【3_1】 和【4】绑事务，【4】变成update order set status&#x3D;3 where status&#x3D;1</li>
<li>流程1中【3】，变成 update order set status&#x3D;2 where status&#x3D;1</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/17/20210917-duo-idc-xia-wei-fu-wu-shu-ju-ru-he-tong-bu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/17/20210917-duo-idc-xia-wei-fu-wu-shu-ju-ru-he-tong-bu/" itemprop="url">多IDC下微服务数据如何同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-17T14:51:20+08:00">
                2021-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>最近公司出现跨机房调用redis超时导致的故障，借此简单记录一下微服务依赖的相关组件使用规范。</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li>每个服务的每个IDC对应一套Redis集群，原则上：<ul>
<li>不同服务不共用一套redis：避免业务相互影响，key定义冲突等问题；</li>
<li>不跨机房读写redis：避免不必要的时延等</li>
</ul>
</li>
<li>同个服务不同IDC的redis数据怎么同步？<ul>
<li>通过消息队列异地通知</li>
<li>如果一定要双写，异地IDC的同步尽量异步</li>
<li>如果一定要跨IDC读Redis，要控制好超时时间和降级</li>
</ul>
</li>
</ol>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>看具体业务选择合适的部署方式</li>
<li>数据不要求强一致，可覆盖的业务（比如用户基础信息），可以采用双活架构，MySQL使用双主架构，通过otter 同步数据</li>
<li>要求强一致，不可覆盖的业务（比如用户资产），可以采用主备架构，MySQL跨IDC搭建主从。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/" itemprop="url">Java垃圾回收总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-17T13:57:00+08:00">
                2021-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/JVM_GC.png"></p>
<ul>
<li><p>Java中成熟的垃圾回收器有串行垃圾回收器、并行垃圾回收器、并发标记回收器（Concurrent Mark Sweep, CMS）、垃圾优先回收器（Garbage First，也称为G1）。在JDK 11中引入了一款新的垃圾回收器ZGC，在JDK 12中又引入了另一款新的垃圾回收器Shenandoah。虽然新的垃圾回收器不断地涌现，但是垃圾回收的基本算法变化并不大。简单来说，回收算法主要有复制、标记清除、标记压缩。JVM中不同的垃圾回收器都是基于这些基本算法实现的，不同的垃圾回收器区别在于：选择的算法不同，实现时后台线程采用的并行&#x2F;并发方式不同。</p>
</li>
<li><p>垃圾回收针对的是堆空间</p>
</li>
<li><p>目前垃圾回收算法主要有两类：</p>
<ul>
<li>引用计数法：在堆内存中分配对象时，会为对象分配一段额外的空间，这个空间用于维护一个计数器，如果对象增加了一个新的引用，则将增加计数器的值；如果一个引用关系失效，则减少计数器的值。当一个对象的计数器的值变为0，则说明该对象已经被废弃，处于不活跃状态，可以被回收。引用计数法需要解决循环依赖的问题</li>
<li>可达性分析法（也称为根引用分析法），基本思路就是通过根集合（root set）作为起始点，从这些节点出发，根据引用关系开始搜索，所经过的路径称为引用链，当一个对象没有被任何引用链访问到时，则证明此对象是不活跃的，可以被回收。在JVM中常见的根（root）有线程栈帧（thread frame，用于跟踪线程中活跃对象）、符号表（symbol dictionary）、字符串表（string table）、对象监视器（object synchronizer）、元数据对象（universe）等，这些根共同构成了根集合。</li>
</ul>
</li>
<li><p>JVM的垃圾回收采用了可达性分析法。垃圾回收算法也在不断地演化，按照不同的标准有不同的分类：</p>
<ul>
<li>从垃圾回收算法实现主要分为复制（copy）、标记清除（mark-sweep）和标记压缩（mark-compact）。</li>
<li>从回收方式上可以分为串行回收、并行回收、并发回收。</li>
<li>从内存管理上可以分为代管理和非代管理。</li>
</ul>
</li>
<li><p>JVM垃圾回收器基于分代管理和回收算法，结合回收的方式，实现了串行回收器、并行回收器、CMS、G1、ZGC和Shenandoah。</p>
</li>
<li><p>从程序执行方式的角度可以分为以下3类：</p>
<ul>
<li>串行执行：应用程序和垃圾回收器交替执行，垃圾回收器执行的时候应用程序暂停执行。串行执行指的是垃圾回收器有且仅有一个后台线程执行垃圾对象的识别和回收。</li>
<li>并行执行：应用程序和垃圾回收器交替执行，垃圾回收器执行的时候应用程序暂停执行。并行执行指的是垃圾回收器有多个后台线程执行垃圾对象的识别和回收，多个线程并行执行。</li>
<li>并发执行：应用程序和垃圾回收器同时运行，除了在某些必要的情况下垃圾回收器需要暂停应用程序的执行，其余的时候在应用程序运行的同时，垃圾回收器的后台线程也运行，如标识垃圾对象并回收垃圾对象所占的空间。<br><img src="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C.jpg"></li>
</ul>
</li>
<li><p>JKD7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</p>
</li>
<li><p>JKD8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</p>
</li>
<li><p>JKD9的默认垃圾回收器是G1</p>
</li>
<li><p>JDK15 正式删除CMS。JDK11就已经把CMS标记为过期。JDK9开始使用G1作为「默认」的垃圾回收器（JDK11中ZGC开始崭露头角）</p>
</li>
<li><p>Minor GC：又称新生代GC</p>
</li>
<li><p>Full GC：又称为Major GC或老年代GC</p>
</li>
</ul>
<p><img src="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8F%82%E8%80%83.png"></p>
<h3 id="垃圾收集器-种类"><a href="#垃圾收集器-种类" class="headerlink" title="垃圾收集器 种类"></a>垃圾收集器 种类</h3><ol>
<li>Serial 垃圾收集器（单线程、复制算法）[‘sɪriəl]</li>
<li>ParNew 垃圾收集器（Serial+多线程）【Serial收集器的多线程版本】</li>
<li>Parallel Scavenge 收集器（多线程复制算法、高效）[‘perə.lel] [‘skævəndʒ] 【“吞吐量优先”收集器】<br>自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个<br>重要区别。</li>
<li>Serial Old 收集器（单线程标记整理算法 ）【Serial收集器的老年代版本】</li>
<li>Parallel Old 收集器（多线程标记整理算法）【Parallel Scavenge收集器的老年代版本】</li>
<li>CMS 收集器（多线程标记清除算法） （Coucurrent Mark Sweep）【并发收集、低停顿】<br>最主要目标是获取最短垃圾回收停顿时间</li>
<li>G1 收集器 （Garbage-First）【面向服务端应用的垃圾收集器】</li>
</ol>
<ul>
<li><p>相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p>
<ul>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li>
</ul>
</li>
<li><p>CMS收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器更关注系统的吞吐量（Throughput）。</p>
</li>
<li><p>CMS</p>
<ul>
<li>多线程，使用标记清除算法。并发收集，垃圾回收停顿时间短。但对CPU资源较敏感，CPU核心较少时会导致并发标记、并发清除时吞吐量骤减；无法处理浮动垃圾，老年代空间不能完全使用,需要预留一部分空间；由于基于标记清除算法，会产生大量空间碎片，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</li>
</ul>
</li>
<li><p>G1</p>
<ul>
<li>多线程，从局部（两个Region之间）来看，是基于复制算法，从整体来看是基于标记整理算法，不会产生空间碎片，相比于CMS，可预测停顿时间。适合大堆，追求低停顿。</li>
</ul>
</li>
</ul>
<h3 id="JVM-GC参数"><a href="#JVM-GC参数" class="headerlink" title="JVM GC参数"></a>JVM GC参数</h3><ul>
<li>-XX:+UseSerialGC 开启此参数使用Serial &amp; Serial Old搜集器（client模式默认值）</li>
<li>-XX:+UseParNewGC 开启此参数使用ParNew &amp; Serial Old收集器</li>
<li>-XX:+UseParallelGC 开启此参数使用parallel scavenge &amp; Serial old收集器（server模式默认值）</li>
<li>-XX:+UseParallelOldGC 使用Parallel scavenge &amp; Parallel old收集器</li>
<li>-XX:+UseConcMarkSweepGC 使用ParNew &amp; CMS收集器 (使用ParNew + CMS + Serial Old的收集器组合进行垃圾回收，Serial Old作为CMS出现Concurrent Mode Failure失败后的后备收集器)</li>
<li>-XX:+UseG1GC</li>
</ul>
<h2 id="总结和适用场景"><a href="#总结和适用场景" class="headerlink" title="总结和适用场景"></a>总结和适用场景</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul>
<li>以获取最短回收停顿时间为目标的收集器。</li>
<li>CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</li>
<li>优点：并发收集、低停顿</li>
<li>CMS收集器之所以能够做到并发，根本原因在于采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解。</li>
<li>CMS是老年代的垃圾回收器，在老年代分配不下的时候，触发CMS。</li>
<li>CMS的最大问题：CMS会使内存碎片化，老年代产生了很多的碎片，然后从年轻代过来的对象无法找到空间，造成了promotion failed。这时候，CMS既没有机会进行垃圾回收，又放不下新来的对象，在这种情况下，CMS会调用SerialOld来进行垃圾回收。这是一件很恐怖的事情。</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul>
<li>致力于在多CPU和大内存服务器上对垃圾回收提供软实时目标（soft real-time goal）和高吞吐量（high throughput）</li>
<li>G1适合8&#x2F;16G以上的内存使用</li>
<li>整体采用标记-整理算法，局部是通过是通过复制算法，不会产生内存碎片</li>
<li>G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</li>
<li>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</li>
<li>可预测的停顿</li>
<li>G1在逻辑上分代，在物理上不分代。G1引入了分而治之的思想，把内存分为一个一个的小块(region)。每个region逻辑上属于下面四种分代中的一种。</li>
<li>四种分代：<br>  a. Old区：老对象<br>  b .Survivor区：存活对象<br>  c. Eden区：新生对象<br>  d. Humongous区：大对象，如果这个对象特别大，可能会跨两个region。</li>
</ul>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><ul>
<li>和G1类似，但ZGC的region的大小更加灵活和动态。zgc的region不会像G1那样在一开始就被划分为固定大小的region。</li>
<li>zgc的region核心亮点就是：动态。</li>
<li>停顿时间控制在10ms之内停顿时间不会因为堆变大而变长堆大小支持TB级。</li>
<li>ZGC在对象回收的吞吐量方面略逊于G1回收器（差距小于15%）</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BH7XAuSs4QsseIK-gMeD7A">Tencent Kona JDK11无暂停内存管理ZGC生产实践</a><ul>
<li>超大堆应用。超大堆（百 G 以上）下，CMS 或者 G1 如果发生 Full GC，停顿会在分钟级别，可能会造成业务的终端，强烈推荐使用 ZGC。</li>
<li>高 SLA 需求的应用。如对响应时间有 P999 时限要求的实时和软实时应用，此类应用无论堆大小，均推荐采用低停顿的 ZGC。</li>
</ul>
</li>
</ul>
<h3 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h3><ul>
<li>ZGC是Oracle JDK的。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<h3 id="新生代关系和组合关系"><a href="#新生代关系和组合关系" class="headerlink" title="新生代关系和组合关系"></a>新生代关系和组合关系</h3><ul>
<li>当 CMS回收失败时, 备选 Serial Old GC<br><img src="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/HotSpot_%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png"></li>
</ul>
<p><img src="/2021/08/17/20210817-java-la-ji-hui-shou-zong-jie/G1_ZGC_Shenandoah.jpg"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>新一代垃圾回收器ZGC设计与实现</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyy9902/article/details/111504800">十种常见的垃圾回收器简介</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021786789">Java 虚拟机系列三：垃圾收集器一网打尽，船新的 ZGC 和 Shenandoah 听说过吗</a></li>
<li>[JVM垃圾回收-垃圾回收的各种分类&amp; 垃圾收集器的组合关系(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qcl108/article/details/108875189">https://blog.csdn.net/qcl108/article/details/108875189</a>)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/13/20210813-xiao-gou-qian-qian-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/13/20210813-xiao-gou-qian-qian-bi-ji/" itemprop="url">《小狗钱钱》-笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-13T19:06:22+08:00">
                2021-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>财务自由是今天每个人都可能实现的目标，当然这需要我们拥有追求自己真正想要的生活的勇气。正如一句名言所说：“并非困难使我们放弃，而是因为我们放弃，才显得如此困难。</p>
</li>
<li><p>什么都无法阻挡你将金钱的规律铭记在心，你就会发现自己的财务状况在日益改善。没有任何东西能够阻挡一个顺应时势的想法。这一点也适用于每一个人的生活。什么都无法阻挡你享受自己与生俱来的权利——富裕。富有尊严、财务上游刃有余的生活符合我们的自然法则。只要你不放弃，那就没有任何东西可以阻碍你达到这个目标。就是现在，马上行动起来吧。我们的生活是一次旅行。如果我们掌握了金钱的规律，那么这次旅行就可以为我们开创机遇，并将我们引向那个自己从未想过的方向。</p>
</li>
</ul>
<h3 id="第一章-白色的拉布拉多犬"><a href="#第一章-白色的拉布拉多犬" class="headerlink" title="第一章 白色的拉布拉多犬"></a>第一章 白色的拉布拉多犬</h3><ul>
<li>中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细。</li>
</ul>
<h3 id="第二章-梦想储蓄罐和梦想相册"><a href="#第二章-梦想储蓄罐和梦想相册" class="headerlink" title="第二章 梦想储蓄罐和梦想相册"></a>第二章 梦想储蓄罐和梦想相册</h3><ul>
<li><p>学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</p>
</li>
<li><p>看看你的爸爸妈妈，他们拥有的钱比你零花钱的10倍还要多得多，也许是你的100倍。尽管如此，他们的情况也并不好。钱的数目并不是决定性因素，更重要的是我们怎么来使用它。我们首先必须学会量入为出，只有这样，我们才有能力获得更多的钱。</p>
</li>
</ul>
<h3 id="第三章-达瑞，一个很会挣钱的男孩"><a href="#第三章-达瑞，一个很会挣钱的男孩" class="headerlink" title="第三章 达瑞，一个很会挣钱的男孩"></a>第三章 达瑞，一个很会挣钱的男孩</h3><ul>
<li>第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。</li>
</ul>
<h3 id="第四章-堂兄的挣钱之道"><a href="#第四章-堂兄的挣钱之道" class="headerlink" title="第四章 堂兄的挣钱之道"></a>第四章 堂兄的挣钱之道</h3><ul>
<li><p>你最好想清楚你喜欢做什么，然后再考虑你怎么用它来挣钱。我就是这样想出派送面包这项服务的。</p>
</li>
<li><p>“但是，我想提醒你两件重要的事情。”我听见马塞尔说，“第一，无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。”</p>
</li>
<li><p>这些困难是你现在还难以预料的。到那时候就能看出来，你到底是一个洋娃娃似的胆小鬼呢，还是一个像我一样能挣很多钱的人。情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。”</p>
</li>
</ul>
<h3 id="第五章-钱钱以前的主人"><a href="#第五章-钱钱以前的主人" class="headerlink" title="第五章 钱钱以前的主人"></a>第五章 钱钱以前的主人</h3><ul>
<li>72小时规定！”“72小时规定？”我紧接着问钱钱。“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。</li>
</ul>
<h3 id="第六章-爸爸妈妈犯下的错误"><a href="#第六章-爸爸妈妈犯下的错误" class="headerlink" title="第六章 爸爸妈妈犯下的错误"></a>第六章 爸爸妈妈犯下的错误</h3><ul>
<li><p>“大多数人都认为工作肯定是一件艰苦而令人不愉快的事情，”他向我解释道，“其实只有做自己喜欢的事情的人，才能真正获得成功。”</p>
</li>
<li><p>钱钱接着说：“第二个忠告是，应当尽可能少地偿还贷款——也就是大人们说的分期付款。</p>
</li>
<li><p>如果每年偿还1%，虽然需要支付的利息逐年减少，但最后总共支付的利息数额仍会达到贷款数额的3倍左右。为了能快一点儿还清1万马克贷款，人们当然选择每年付较高的分期付款。许多人和银行约定的分期付款数额刚好在他们承受能力的上限，因此他们手里的钱一直很紧张。</p>
</li>
<li><p>第三个忠告是针对消费贷款的。消费贷款是与住房无关的贷款。假如人们为了购置新的汽车、家具、电视机或其他用于生活的商品而贷款，就是消费贷款。这时候贷款的人应当遵守的一个原则，就是将不用于生活的那部分钱的一半存起来，另一半用于偿还贷款。”“可是我奶奶常说，债务应当尽快还清，”我想起奶奶的话，“所以应该把所有不用于生活的钱都用来还债。”“当你还清了债务的时候，又达到了什么目标呢？”钱钱问我。“爸爸妈妈总是说，那时候他们肩上的一个重担就可以卸下来了。”我试着给钱钱解释。“他们是这么以为的。”钱钱赞同地点点头，“可是事实上，当他们还清了债务的时候，他们拥有的财产为零，也就是一无所有。一无所有可不是目标呀。”我吃了一惊，问道：“那么目标该是什么呢？”“去美国旅行，买笔记本电脑——这些才是目标，”钱钱耐心地解释给我听，“或者把不花的钱都积攒起来。”</p>
</li>
<li><p>所有的消费贷款都是不明智的。聪明的做法是只把以前积攒起来的财富用于支出。</p>
</li>
<li><p>将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。</p>
</li>
</ul>
<h3 id="第七章-在金先生家"><a href="#第七章-在金先生家" class="headerlink" title="第七章 在金先生家"></a>第七章 在金先生家</h3><ul>
<li><p>你当然也应该得到一点儿什么……让我想想。你照顾钱钱很长一段时间了，确切地说，是一年多。如果我一天付你10马克，你觉得怎么样？”我一点儿都不高兴。我气呼呼地说：“我愿意照顾钱钱是因为我一见到它就喜欢上了它，而不是为了挣什么钱。”金先生笑了，但我并不觉得他是在嘲笑我——这两者之间还是有一点儿细微差别的。他向我解释道：“吉娅，大多数人都是这么想的，我曾经也这么想。可是请你告诉我，你为什么不能因为做了一件自己喜欢的事情而挣到钱呢？”类似的话我已经听过许多次了。的确如此，马塞尔对我说过，汉内坎普先生也说过。尽管如此，我还是觉得心里有些不安。“我要告诉你一件事，”金先生接着说，“恰恰是因为你喜欢我的钱钱，我才要每天付你10马克，因为由此我知道，它在你身边过得很舒服，你也会继续好好地照顾它。正是你的真情实意才让你的劳动显得那样珍贵。”</p>
</li>
<li><p>“鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”我不敢肯定自己是不是真的懂了。金先生接着说：“大多数人生来并没有‘鹅’。这就是说，他们的钱不足以让他们依靠利息来生活。”“可是要靠利息生活的话，这个人肯定得有很多很多的钱才行，是这样吗？”我不解地打断了金先生的话。“你需要的钱其实比你想象的要少得多。”金先生答道，“如果你有2.5万马克，能得到12%的利息的话，那每年就有3000马克。”</p>
</li>
<li><p>那么2.5万马克就是你的‘鹅’，而你是不会‘杀’它的。</p>
</li>
<li><p>“你必须作出选择！”金先生点点头，“你可以马上拿出你的钱，用在任何一个地方——比如一旦你有了3000马克，你可以马上飞往加利福尼亚——可是那样的话，你也就‘杀死’了你的‘鹅’；你也可以选择将一部分钱存起来，那样过了一段时间之后，仅靠每年的利息，你就可以飞往加利福尼亚了。”</p>
</li>
<li><p>我已经想好该怎么分配我的钱了，我也要把50%的收入变成我的‘鹅’，40%放入我的梦想储蓄罐，剩下的10%用来花。”金先生看着我，眼光中充满了赞许。</p>
</li>
<li><p>越是把注意力放在疼痛上，我就越会觉得疼。谈论疼痛就像给植物施肥一样。所以我很多年以前就改掉了抱怨的习惯。</p>
</li>
</ul>
<h3 id="第十一章-爸爸妈妈不明白"><a href="#第十一章-爸爸妈妈不明白" class="headerlink" title="第十一章 爸爸妈妈不明白"></a>第十一章 爸爸妈妈不明白</h3><ul>
<li><p>幸运其实只是充分准备加上努力工作的结果。</p>
</li>
<li><p>你干的活最多只值报酬的一半，另一半报酬源于你的想法和实施这个想法的勇气。</p>
</li>
</ul>
<h3 id="第十二章-陶穆太太归来"><a href="#第十二章-陶穆太太归来" class="headerlink" title="第十二章 陶穆太太归来"></a>第十二章 陶穆太太归来</h3><ul>
<li><p>要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。</p>
</li>
<li><p>“我妈妈总说，金钱会使人的本性变坏。”我反驳道。“金钱会暴露一个人的本性，”陶穆太太解释说，“金钱就像一个放大镜，它帮你更充分地展现出你本来的样子。好人可以用钱做很多好事。而如果你是盗贼，那你很可能会把钱挥霍在一些蠢事上。”</p>
</li>
</ul>
<h3 id="第十三章-巨大的危机"><a href="#第十三章-巨大的危机" class="headerlink" title="第十三章 巨大的危机"></a>第十三章 巨大的危机</h3><ul>
<li>“我想，你刚刚又找到了一个做有钱人的很好的理由。”钱钱提示我。我疑惑地望着它。“你可以做一个有能力帮助别人的人，而别人也会相信你，愿意接受你的帮助。”钱钱解释说。</li>
</ul>
<h3 id="第十四章-投资俱乐部"><a href="#第十四章-投资俱乐部" class="headerlink" title="第十四章 投资俱乐部"></a>第十四章 投资俱乐部</h3><p>1．确定自己希望获得财务上的成功。<br>2．自信，有想法，做自己喜欢做的事。<br>3．把钱分成日常开销、梦想目标和金鹅账户三部分。<br>4．进行明智的投资。<br>5．享受生活。</p>
<h3 id="第十五章-演讲"><a href="#第十五章-演讲" class="headerlink" title="第十五章 演讲"></a>第十五章 演讲</h3><ul>
<li>如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记。</li>
</ul>
<h3 id="第十六章-俱乐部的投资行动"><a href="#第十六章-俱乐部的投资行动" class="headerlink" title="第十六章 俱乐部的投资行动"></a>第十六章 俱乐部的投资行动</h3><ul>
<li><p>基金就像一口大锅，许多没有时间、没有相关的知识或者没有兴趣亲自去买股票的投资人都会把钱投进这口锅里，这些钱由金融界的专家——也就是所谓的基金经理人——去投资买股票。国家对此进行严格的监督，基金经理人必须遵守一定的规定。比如，他们至少必须购买20种不同的股票。</p>
</li>
<li><p>如果我们打算投资买基金，就要准备把自己的钱在里面放上5～10年。对于那些能等这么长时间的人来说，基金几乎是一种零风险的投资。”</p>
</li>
<li><p>挑选基金时的注意事项：1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</p>
</li>
<li><p>“有一个相当简单的公式，如果你们运用这个公式的话，可以不用去看那些又复杂又麻烦的表格。它的名字叫72公式。”老太太讲解说，“你们直接用72除以你们投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数。”“啊？”莫尼卡嘟哝了一声。“72除以12是多少？”陶穆太太问。“6。”马塞尔飞快地算了出来。“对！这就是说，如果你们每年能得到12%的利润，6年以后你们的钱就会翻一倍。”马塞尔一边思考，一边说：“要想知道15%的时候会怎么样，那我就必须用72除以15，等于4.8年。”</p>
</li>
<li><p>“简单地说，如果你们投资的收益率是15%，差不多5年以后，钱就会翻一倍。</p>
</li>
<li><p>”陶穆太太说道，“也就是说，如果将来我们也能得到15%，那5年以后我们的2万马克就会涨到4万马克，10年以后就会是8万，15年后是16万，而20年后是32万。”</p>
</li>
</ul>
<h3 id="第十七章-爷爷奶奶害怕风险"><a href="#第十七章-爷爷奶奶害怕风险" class="headerlink" title="第十七章 爷爷奶奶害怕风险"></a>第十七章 爷爷奶奶害怕风险</h3><ul>
<li><p>只有当我们把它卖出的时候，才会有亏损。可是我们并没有这么做。</p>
</li>
<li><p>现在我们可以用比实际价值低的价钱购买股票和基金。不久以后，又有人会愿意付出相当于它们实际价值的钱，把它们买进。这样我们就会大赚一笔。</p>
</li>
<li><p>银行存折肯定不是保存钱的最合适的地方，金先生总是把银行存折叫作“吞钱机器”。</p>
</li>
<li><p>你要理解你的爷爷奶奶，他们是为你好。他们只是想让你免受损失，想尽他们所知来帮助你。</p>
</li>
<li><p>到了他们这个年纪，很可能有过几次吃亏的经历。现在他们想保护自己，也保护你。这是可以理解的。不过说真的，你应该多谢你的爷爷奶奶，因为他们可能帮你避免了一个错误。”“避免了什么错误？”“我觉得，你们现在用2万马克再次买进基金不是一个好主意。我认为最多1万马克就够了。”</p>
</li>
<li><p>可是如果行情继续下跌怎么办呢？所以你最好不要投入太多的钱。而且如果行情真的继续下跌，那时要是你手头还有钱用来再一次买进的话，不是更好吗？”“但我们并不知道，行情是不是真的还会继续下跌。”“没错，我们是不知道。没有人能知道，所有试图预测未来走势的专家总是计算失误，意想不到的情况很多。正因为如此，你应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。”</p>
</li>
<li><p>我怎么知道通货膨胀率有多高，会吃掉我多少钱呢？”“目前是3%左右。如果你现在想计算具体的数目，我可以告诉你一个相当简单的公式，就是72公式。这个公式很实用，我们可以通过它计算出自己的钱翻一倍需要多少年，也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。按72除以3%的通货膨胀率计算，得到24，就是说24年以后，你的钱只值现在的一半。”</p>
</li>
<li><p>没错！所以我把存折叫作‘吞钱机器’。因为你从这里得到的利息连通货膨胀带来的损失都抵消不了</p>
</li>
<li><p>但是我们几乎没有别的选择。你总不能把你所有的钱都投资买股票。就算你还很年轻，也该留一些现金做储备。只有这样才能达到分散风险的最佳效果。”</p>
</li>
<li><p>当然也有一些储蓄种类的利率比较高，可是你必须把钱放在银行里存很长一段时间。这种方式的坏处是，碰上再次买进的合适时机，你不能马上采取行动。”“那么，我该拿百分之几的钱投资日拆呢？”“这要根据你的具体情况而定。你还小，20%就够了。”</p>
</li>
<li><p>我决定向金钱魔法师们建议，每人只拿出2500马克用来再次买进基金，剩下840马克，可以投资在日拆上。</p>
</li>
</ul>
<h3 id="第十八章-大冒险的结局"><a href="#第十八章-大冒险的结局" class="headerlink" title="第十八章 大冒险的结局"></a>第十八章 大冒险的结局</h3><ul>
<li><p>而自从他买了一辆新车之后，甚至比往常提早一个小时就起床了。当一个人不需要再为钱的问题烦心之后，竟然会发生如此巨大的变化，真令人难以置信。</p>
</li>
<li><p>我们买的第一只基金的行情虽然持续下跌了7个月，但我们并没有卖出，所以没有亏损。这以后行情开始爬升，如果我们卖出的话，可以获取不少利润。不过我们没有理由这样做，我们想要的是让我们的鹅不断地长大。马塞尔曾经想过卖出手里的基金，他说这叫提取利润。陶穆太太却问他准备怎样处置这笔钱，怎样让它继续增长。我们得出的结论是：再次选择同样的基金进行投资。于是马塞尔立即意识到现在卖出基金毫无意义。</p>
</li>
<li><p>我想起了金先生对我说过的一句话：不要为失去的东西而忧伤，而要对拥有它的时光心存感激。对我来说，这句话的意思是：从现在开始，我再也得不到钱钱的建议了，但我还是必须应对各种情况。</p>
</li>
</ul>
<h3 id="自力更生——写给成年人的后记"><a href="#自力更生——写给成年人的后记" class="headerlink" title="自力更生——写给成年人的后记"></a>自力更生——写给成年人的后记</h3><ul>
<li><p>钱钱拆除了偏见的围墙，让人眼前豁然开朗，它告诉我们：经营活动并不是童工劳动，而是一种能激发人的热情的游戏；赚钱并不枯燥，相反会带来激动人心的时刻，释放人的发明创造的才能。</p>
</li>
<li><p>我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，</p>
</li>
<li><p>表达感情或者从事艺术性和创造性的活动。</p>
</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li>股票是一家公司的股权证明——你可以购买这家公司的一份或若干份股权。每一份股权就是一张股票。如果公司赢利（赚钱），你就可以根据自己所拥有的股份数量，从公司的利润中分得一部分。你的股份越少，分到的利润就越少；股份越多，分到的利润就越多。如果公司亏损，那么你所持有的股票就会贬值。在这种情况下，你不应该急于卖出股票，而应该等待公司重新赢利。在第十六章中，陶穆太太对此有详细说明。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>并非困难使我们放弃，而是因为我们放弃，才显得如此困难。</li>
<li>无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。</li>
<li>72小时规定</li>
<li>尽可能少地偿还贷款</li>
<li>消费贷款是不明智的</li>
<li>基金</li>
</ul>
<hr>
<ul>
<li>评论：转：聪明理财五大定律<br>4321定律：家庭资产合理配置比例是家庭收入的40%用于供房及其他方面投资，30%用于家庭生活开支，20%用于银行存款以备应急之需，10%用于保险。<br>72定律：不拿回利息利滚利存款，本金增值一倍所需要的时间等于72除以年收益率。比如，如果在银行存10万元，年利率是2%，每年利滚利，多少年能变20万元？答案是36年。<br>80定律：股票占总资产的合理比重等于80减去年龄的得数添上一个百分号(%)。比如，30岁时股票可占总资产50%，50岁时则占30%为宜。<br>家庭保险双十定律：家庭保险设定的恰当额度应为家庭年收入的10倍，保费支出的恰当比重应为家庭年收入的10%。</li>
<li>评论：转<br>吞钱机器：储蓄利息永远跑不赢通货膨胀。把钱存在银行，你的存款金额看起来是在增加，然而它的实际购买力是在不断降低的。所以，真正富有的人，钱都不会存在银行，而是通过理财投资，跑赢通货膨胀。</li>
<li>评论：投短线叫投机，投长线才叫投资。价格终会回归价值，长期投资价值，才有相对稳定的收益。</li>
<li>评论：转：<ul>
<li>关于基金的三原则：<ol>
<li>基金就像一口大锅，许多没有时间、没有相关的知识或者没有兴趣亲自去买股票的投资人都会把钱投进这口锅里，这些钱由金融界的专家——也就是所谓的基金经理人——去投资买股票。国家对此进行严格的监督，基金经理人必须遵守一定的规定。比如，他们至少必须购买20种不同的股票。</li>
<li>基金符合投资的一切要求。由于它的这些特点，它也非常适合儿童和青少年。如果能够在5～10年内不动用这些钱，基金投资是很保险的，它会带来丰厚的利润……</li>
<li>基金也符合第三条原则，它很容易操作，几乎就像在银行开一个普通的账户一样简单。</li>
</ol>
</li>
<li>挑选基金时的注意事项：<br>  1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。<br>  2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。<br>  3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</li>
</ul>
<p>	</p>
</li>
<li>评论：比特币不跌50%以上不入手，入手拿5年！等第5年比特币牛市，比特币不赚10倍不出货！</li>
</ul>
<p>		</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/13/20210813-shen-du-gong-zuo-ru-he-you-xiao-shi-yong-mei-yi-dian-nao-li-bi-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉巴力的纸皮箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/13/20210813-shen-du-gong-zuo-ru-he-you-xiao-shi-yong-mei-yi-dian-nao-li-bi-ji/" itemprop="url">《深度工作：如何有效使用每一点脑力》-笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-13T11:08:23+08:00">
                2021-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>深度工作（Deep Work）：在无干扰的状态下专注进行职业活动，使个人的认知能力达到极限。这种努力能够创造新价值，提升技能，而且难以复制。</p>
</li>
<li><p>浮浅工作（Shallow Work）：对认知要求不高的事务性任务，往往在受到干扰的情况下开展。此类工作通常不会为世界创造太多新价值，且容易复制。</p>
</li>
<li><p>深度工作假设（The Deep Work Hypothesis）：深度工作的能力日益稀少，而几乎同时，其在社会经济中的价值也日益提升。因此，能够培养这项技能，并将其内化为工作生活之核心的人，将会取得成功。</p>
</li>
</ul>
<h3 id="如何在新经济形势下成为赢家"><a href="#如何在新经济形势下成为赢家" class="headerlink" title="如何在新经济形势下成为赢家"></a>如何在新经济形势下成为赢家</h3><ul>
<li><p>我发现有两类人注定会成功，而且我认为可以推广借鉴：一种是能够利用智能机器进行创造性工作的，一种是自己所在领域的个中翘楚。在数字鸿沟不断扩大的当下，有什么窍门能够为进入此类有利领域提供助力？我认为如下两种核心能力是关键。</p>
<ul>
<li>·迅速掌握复杂工具的能力</li>
<li>·在工作质量和速度方面都达到精英层次的能力</li>
</ul>
</li>
<li><p>智能机器的复杂性是难以掌握的。因此，要想较好地运用这些机器，你就要培养出掌握复杂事物的能力。而且由于这些科技变化很快，掌握复杂事物的过程便永远不会结束：你必须能够快速完成，一次又一次。当然，这种迅速掌握复杂事物的能力并不仅仅是能熟练运用智能机器所必需的；基本上也是想要成为任何领域的超级明星的关键因素，即便是与科技关联性很小的领域。</p>
</li>
<li><p>如果你无法学习，就无法成功。</p>
</li>
<li><p>由此我们总结出想要加入当前经济形势下赢家群体的另一项要点：如果你不产出，就不会成功，不管你的技艺多么纯熟，天资多么聪颖。</p>
</li>
<li><p>上文阐述的两种核心能力依赖于你进行深度工作的能力。如果你没有掌握这项基本能力，想要学习艰涩的知识或达到精英水平就会很挣扎。这些能力对于深度工作的依赖性并非即时显现的，这要求我们更深入地探究与学习、专注和生产力相关的科学</p>
</li>
</ul>
<h3 id="深度工作帮助你迅速掌握困难的事物"><a href="#深度工作帮助你迅速掌握困难的事物" class="headerlink" title="深度工作帮助你迅速掌握困难的事物"></a>深度工作帮助你迅速掌握困难的事物</h3><ul>
<li><p>（1）你的注意力全情投入到某个你希望提升的技能或想要掌握的理念上；</p>
</li>
<li><p>（2）你能得到反馈意见，这样你就可以调整自己的方法，保持注意力的投入有最佳产出。</p>
</li>
<li><p>刻意练习不能在有干扰的情况下进行，要求在无干扰状态下保持专注。</p>
</li>
</ul>
<h3 id="深度工作有助于精英级产出的实现"><a href="#深度工作有助于精英级产出的实现" class="headerlink" title="深度工作有助于精英级产出的实现"></a>深度工作有助于精英级产出的实现</h3><ul>
<li><p>高质量工作产出&#x3D;时间×专注度</p>
</li>
<li><p>工作时专注度达到最高，单位时间里的工作产出也将实现最大化。</p>
</li>
<li><p>当你从某项任务A转移到任务B时，你的注意力并没有即时转移，你的注意力残留仍然在思考原始任务。如果在转移工作之前，你对任务A缺乏控制且关注度较低，残留会尤其浓厚，但即使你在转移工作之前已经完成了任务A，你的注意力还是会有一段分散的时间。</p>
</li>
<li><p>注意力残留的概念有助于解释专注度公式的真实性，因此也有助于解释格兰特的高效产出。格兰特长时间不转移注意力，完成单一困难任务，使注意力残留负面影响降到最低，从而使他在当前任务上的表现成果最优化。换言之，当格兰特与世隔绝数日完成一篇论文时，其效率水平远高于奉行多任务策略的一般教授，这些教授的工作反复受到残留量极大的干扰。</p>
</li>
<li><p>要达到个人巅峰的产出效率，你需要长时间、无干扰地高度专注于单一任务。换一种说法，使你的表现最优化的做法是深度工作。如果你无法做到长时间深度工作，就很难使你的表现达到质量和数量的巅峰，而这种巅峰状态对于你的职业成功越来越重要。除非你的才能和技能全面压制对手，否则对手中的深度工作者定将超越你的表现。</p>
</li>
</ul>
<h3 id="杰克·多西是怎么回事？"><a href="#杰克·多西是怎么回事？" class="headerlink" title="杰克·多西是怎么回事？"></a>杰克·多西是怎么回事？</h3><ul>
<li><p>杰克·多西没有深度工作而取得成功，在其所处的精英管理层中是很常见的。</p>
</li>
<li><p>明确了这一事实之后，我们必须退后一步提醒自己，这种现象并不会破坏深度工作的普遍价值。为什么？因为这些高管工作中分心的必然性是在其特定工作中特有的现象。从根本上讲，一名优秀的首席执行官就是一部难以自动化的决策引擎，与《危险边缘》游戏中IBM的“沃森”机器人没有太大区别。他们努力积累起丰富的经验库，打磨并证明了自己在市场中的灵敏嗅觉。而后他们全天都必须处理和解决电子邮件、会议、现场考察等纷至沓来的工作。要求一名首席执行官花上4个小时的时间深度思考单一问题浪费了他们的价值所在。最好是聘用三个聪明的副手，深度思考这些问题，然后将解决方案呈递给高管做决策。这种特殊案例很重要，因为这种状况告诉我们，如果你是一家大型公司的高管，或许就不需要听取下述章节中的意见。另一方面，它也告诉我们不能将这些高管的工作方法外推至其他工作中。多西鼓励外界打扰，克里·特雷纳不断查阅电子邮件，虽然有这些案例，但并不意味着你学着他们的做法也能成功：他们的行为是公司领导者这个特定角色所特有的。</p>
</li>
<li><p>我们必须时刻记住，在社会经济的某些角落，深度工作并没有价值。除了高管之外，还有部分类型的销售人员和说客，对他们而言持续联系是其最大价值所在。甚至还有一些人身处深度工作有所助益的领域，却在备受干扰中经过艰苦努力取得成功。</p>
</li>
<li><p>深度工作并非是我们的经济中唯一有价值的技能，不培养这种能力也有可能做得很好，但是不需要深度工作的职业会越来越少。</p>
</li>
</ul>
<h2 id="第2章-深度工作是少见的"><a href="#第2章-深度工作是少见的" class="headerlink" title="第2章 深度工作是少见的"></a>第2章 深度工作是少见的</h2><ul>
<li>发现即使很短暂的干扰也会显著延长完成一项任务所需要的时间。</li>
</ul>
<h3 id="度量的黑洞"><a href="#度量的黑洞" class="headerlink" title="度量的黑洞"></a>度量的黑洞</h3><ul>
<li><p>大致说来，由于知识工作者的工作复杂性比体力劳动者高，所以也更难衡量个体努力所带来的价值。</p>
</li>
<li><p>我们不应期望破坏深度工作的行为对底线的影响很容易被察觉。恰如汤姆·考克兰的发现，此类度量属于不透明区，难以轻松衡量。我将这个区域称作度量黑洞。当然，难以衡量深度工作相关的度量，并不意味着我们在商业中就应忽略其作用。</p>
</li>
</ul>
<h3 id="最小阻力原则"><a href="#最小阻力原则" class="headerlink" title="最小阻力原则"></a>最小阻力原则</h3><ul>
<li><p>谈及工作场所中普通存在的干扰行为，我们必须为占主导地位的联结文化留个位置，这种文化期望人们能够迅速阅读和回复电邮（及相关交流）。</p>
</li>
<li><p>最小阻力原则（The Principle of Least Resistance）：在工作环境下，若各种行为对于底线的影响没有得到明确的反馈意见，我们倾向于采用当下最简单易行的行为。</p>
</li>
<li><p>最小阻力原则受到度量黑洞的保护，少有人对其加以审视，在这种原则支配下的工作文化，免去了我们短期内对保持专注和做计划的忧虑，却牺牲了长期的满足感和真实价值的产出。这样一来，最小阻力原则就驱使我们在深度工作愈发受到青睐的经济形势下流于浮浅工作。</p>
</li>
</ul>
<h3 id="忙碌代表生产能力"><a href="#忙碌代表生产能力" class="headerlink" title="忙碌代表生产能力"></a>忙碌代表生产能力</h3><ul>
<li><p>经理栖居于一片迷茫的精神领地，受冥冥中难以捉摸但必须应答的命令驱使而焦躁不安。</p>
</li>
<li><p>我认为知识工作者越来越多地表现为可视的忙碌，是因为他们没有更好的方法证明自身价值。我们来给这种倾向性起一个名字。</p>
</li>
<li><p>忙碌代表生产能力（Busyness as Proxy for Productivity）：在工作中，对于生产能力和价值没有明确的指标时，很多知识工作者都会采用工业时代关于生产能力的指标，以可视的方式完成很多事情。</p>
</li>
<li><p>这种思维方式为很多有损深度的行为之盛行提供了又一种解释。如果你随时都在收发电子邮件，如果你不断安排、参加会议，如果有人在Hall之类的即时通讯系统中发布一个新问题，让你在几秒钟内就参与其中，又或者你在开放式办公室中漫步，随时向遇到的人道出自己的想法——所有这些行为都可以使你在公众眼里看似很忙碌。如果你将忙碌看作生产能力，那么想要自己和他人信服你的工作做得很好，这些行为就至关重要。</p>
</li>
</ul>
<h3 id="对互联网的顶礼膜拜"><a href="#对互联网的顶礼膜拜" class="headerlink" title="对互联网的顶礼膜拜"></a>对互联网的顶礼膜拜</h3><ul>
<li><p>已故传播学理论学者、纽约大学教授尼尔·波兹曼（Neil Postman）提出的一个警告中找到基础。20世纪90年代初期，个人电脑革命首次进入快车道，波兹曼在文章中辩称我们的社会与科技的关系愈发令人不安。他写道，我们不再权衡新科技的利弊，不再平衡新增效益和新引入的问题之间的关系。我们开始自以为是地认定，只要是高科技就是好的，而不用再做探讨。他将这种文化称作技术垄断（Technopoly），在提出警醒时也没有拐弯抹角：“技术垄断阻断了其他选择，</p>
</li>
<li><p>在技术垄断的时代，深度工作有很大的劣势，因为它所创建的品质、匠心和通达等价值都是传统的，与技术垄断无关的。更糟糕的是支持深度工作往往要抵制新的高科技。</p>
</li>
</ul>
<h3 id="对生意来讲是坏事，对个人来讲是好事"><a href="#对生意来讲是坏事，对个人来讲是好事" class="headerlink" title="对生意来讲是坏事，对个人来讲是好事"></a>对生意来讲是坏事，对个人来讲是好事</h3><ul>
<li><p>包括深度工作很难，浮浅工作更简单；当工作中没有明确目标时，围绕浮浅工作的表面忙碌会成为一种本能；还有在我们的文化中已经形成了一种信念，认为与“网络”相关的行为都是好的，不论其对我们创造有价值事物之能力有何影响。由于深度工作价值以及忽略深度工作所造成的损失很难直接衡量，这些潮流才会大行其道。</p>
</li>
<li><p>本书的终极目标：系统地培养个人进行深度工作的能力，并由此获得丰富的成果</p>
</li>
</ul>
<h3 id="从神经学角度论证深度"><a href="#从神经学角度论证深度" class="headerlink" title="从神经学角度论证深度"></a>从神经学角度论证深度</h3><ul>
<li><p>你的为人、你的思考、你的感受和所做之事，以及你的喜好，恰是你所关注事物的概括。”</p>
</li>
<li><p>从神经学角度来看，靠浮浅事务度过的一天很可能会是枯燥、令人沮丧的一天，即使抓住你注意力的浮浅事务看似无害甚至有趣。</p>
</li>
</ul>
<h3 id="从心理学角度论证深度"><a href="#从心理学角度论证深度" class="headerlink" title="从心理学角度论证深度"></a>从心理学角度论证深度</h3><ul>
<li><p>一个人的身体或头脑在自觉努力完成某项艰难且有价值的工作过程中达到极限时，往往是最优体验发生的时候。</p>
</li>
<li><p>具有讽刺意味的是，工作其实比休闲时光更容易带来享受，因为工作类似于心流活动，有其内在目标、反馈规则和挑战，所有这些都鼓励个人积极参与到工作中，专注其中，全身心投入到工作里。休闲时光则组织松散，需要很大的努力才能创造出值得享受的事情。</p>
</li>
</ul>
<h3 id="深度智人"><a href="#深度智人" class="headerlink" title="深度智人"></a>深度智人</h3><ul>
<li>“我将活出专注的人生，因为这是最好的选择。”</li>
</ul>
<h2 id="第二部分-准则"><a href="#第二部分-准则" class="headerlink" title="第二部分 准则"></a>第二部分 准则</h2><ul>
<li><p>你的意志力是有限的，它在使用的过程中会被不断消耗。换言之，你的意志力并非性格的展现，可以无限制地使用；相反，它恰如肌肉一般，会疲劳。</p>
</li>
<li><p>培养深度工作的习惯，关键在于越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序，使得进入并保持高度专注状态消耗的意志力最小化。</p>
</li>
</ul>
<h3 id="选定你的深度哲学"><a href="#选定你的深度哲学" class="headerlink" title="选定你的深度哲学"></a>选定你的深度哲学</h3><ol>
<li>禁欲主义哲学的深度工作</li>
<li>双峰哲学的深度工作</li>
<li>节奏哲学（更符合人类的真实天性、适合常规办公室工作）</li>
<li>记者哲学</li>
</ol>
<ul>
<li><p>克努特采用的是我所谓的禁欲主义哲学的深度工作日程安排。这种哲学通过摒弃或最小化浮浅职责，从而实现深度工作的最大化。禁欲主义哲学的实践者往往有明确且价值极高的职业目标追求，而且他们在职业上取得的大部分成就都是由于工作表现特别突出。</p>
</li>
<li><p>适用禁欲主义哲学的个人是有限的。如果你不属于这个群体，也大可不必太过嫉妒。如果你属于这个群体——对世界的贡献是实在的、清晰的、可以个体化的[插图]，那么你就应该认真考虑一下这种哲学，因为这种哲学或许会成为决定性因素，决定你完成的是一个庸庸碌碌还是能为后人所铭记的职业生涯。</p>
</li>
<li><p>我将荣格这种方式称作双峰哲学的深度工作。这种哲学要求你将个人时间分成两块，将某一段明确的时间用于深度追求，余下的时间做其他所有事情。在深度时间里，双峰工作者会像禁欲主义者一般工作——追求高强度、无干扰的专注。在浮浅时间里，专注并非首要目标。这种划分深度和开放时间的做法可以在多个时间层级上实现。</p>
</li>
<li><p>节奏哲学。这种哲学认为轻松启动深度工作的最好方法就是将其转化成一种简单的常规习惯。换言之，其目标是创造一种工作节奏，让你不需要你投入精力便可以决定是否需要以及何时需要进入深度状态。链条法是节奏哲学深度工作日程安排的典型例子，因为这种方法结合了一种简单的启发式调度（每天都要做这项工作）和一种提醒你做这项工作的简单方法：日历上的大红X。</p>
</li>
<li><p>实施节奏哲学的另外一种常见方式是拿掉链条法中的视觉辅助工具，转而设定一个启动时间，每天在这个时间开始深度工作。</p>
</li>
<li><p>节奏哲学与双峰哲学形成了一种有趣的对比。节奏哲学下或许难以达到双峰哲学追随者喜好的最高强度深度思考。然而，这种方法的好处在于更符合人类的真实天性。节奏日程安排者通过雷打不动的惯例支持深度工作，确保能够定期完成一定的工作，在一年的时间里往往能够累积更多的深度工作时长。</p>
</li>
<li><p>对于很多人来说，并非因为自控原因才倾向于选择节奏哲学，而是由于现实中某些工作的确不允许你在需要深入的时候一连消失几天。</p>
</li>
<li><p>常规办公室工作的深度工作者最常选择节奏哲学的原因吧。</p>
</li>
<li><p>我将这种在日程安排中随时可插入深度工作的方法称作记者哲学</p>
</li>
<li><p>我个人也偏爱记者哲学的深度工作，因为这也是我将各项工作安排到日程中所采用的主要方法。换言之，我在深度工作中不是禁欲主义（尽管偶尔我也会嫉妒同行计算机科学家唐纳德·克努特完全与世隔绝但却不用心怀歉意），我也不会像双峰主义者一样接连安排多天的深度工作时间，此外，尽管我很有兴趣采用节奏哲学，但是我的日程安排已经很满，没办法压缩出时间施行这种习惯。我更多的时候如艾萨克森一样，面对每周的工作，竭尽可能压缩出更多的深度工作时间。比如，写作本书的过程中，我会充分利用任何一小段空闲时间。如果我的孩子睡着了，我就会拿出笔记本，把自己锁到书房里。如果妻子在周末要去附近的安纳波利斯拜访她的父母，我就会抓住有额外的人照看孩子的机会，躲到他们房子的一个安静角落去写作。如果工作中有一次会议取消了，或是下午没有安排，我就会来到学校里最喜欢的一间图书馆里，写上几百个词。诸如此类。</p>
</li>
</ul>
<h3 id="习惯化"><a href="#习惯化" class="headerlink" title="习惯化"></a>习惯化</h3><ul>
<li>伟大的创造性头脑如艺术家般思考，却如会计般工作。”</li>
</ul>
<h3 id="不要独自工作"><a href="#不要独自工作" class="headerlink" title="不要独自工作"></a>不要独自工作</h3><ul>
<li><p>深度工作与协作之间的关系非常微妙。然而，这种关系值得我们花时间去解开，因为恰当展开协作可以提升你在职业生活中深度工作的质量。</p>
</li>
<li><p>“我们鼓励员工到开阔区域工作，因为我们相信意外发现——员工互相协作会产生新想法。”</p>
</li>
<li><p>在提倡专注还是意外发现之间做出选择，暗示了深度工作（个体努力）无法与创造性洞见（协作努力）相容。然而这个结论是有缺陷的。我认为这个结论的基础是对偶然创造力理论的片面理解。</p>
</li>
<li><p>偶然创造理论似乎非常符合这些历史记录。我们可以颇有信心地争辩道，晶体管的发明或许需要贝尔实验室的支持，将固态物理学家、量子论理论学家和世界一流的实验物理学者汇聚一堂，互相学习各自的专长，得到偶然的意外发现。这项发明不太可能由某位容身卡尔·荣格那石塔一样的学术处所深度思考的科学家完成。</p>
</li>
<li><p>这种隔音办公室与宽阔公共空间的组合，形成了中心辐射型的创新建筑结构，在这里偶遇的意外发现和与世隔绝的深度思考都能实现。这种设置囊括了两个极端，一方面我们能找到独立的思考者，没有外界激发灵感，但也少了外来的干扰，另一方面我们能看到在开放式办公室里互相协作的思考者，灵感不断，却也缺乏将其付诸实践的深度思考。</p>
</li>
<li><p>如果将注意力转回到20号楼和贝尔实验室上，我们就能发现，二者的建筑设计也有同样的特点。二者都不同于现代的开放式办公室布局，而是利用标准的私人办公室结合共享走廊的方式。</p>
</li>
<li><p>他们的创造性魔力更多的是由于这些办公室共享少量的长联通空间——迫使研究人员在不同地点来往时互相交流。换言之，这些宽大走廊提供了高效中枢。</p>
</li>
<li><p>因此，我们可以抛弃摧毁深度工作的开放式办公室概念，但是可以保留激发偶然创造力的创新产出理论。关键在于保持一种中心辐射型的布局：时常来到中枢区域与他人交流想法，同时也保留独立的辐射区域，可以在其中完成深度工作，处理偶遇的想法。</p>
</li>
<li><p>总结一些关于深度工作中协作之作用的实用结论。20号楼和贝尔实验室的成功证明与世隔绝并非有效深度工作所必需的条件。事实上，这两个例子表明，对于很多类型的工作而言——特别是追寻创新的——协作深度工作可以产出更好的效果。因此，这种策略要求你思考这种选择，考虑如何更好地将深度融入你的职业生活中。</p>
</li>
<li><p>在深度工作时，恰当的时机可以采用协作的方式，因为这样可以推动你的成果提升到一个新档次。与此同时，也不要过分追求交流和积极的偶遇，以免破坏了专注的状态，因为我们最终还是靠专注从包围在我们周围的各种想法的漩涡中提取有用之物。</p>
</li>
</ul>
<h3 id="像经商一样执行"><a href="#像经商一样执行" class="headerlink" title="像经商一样执行"></a>像经商一样执行</h3><ul>
<li><p>据克里斯坦森回忆，格鲁夫在一次会间休息时问他：“我该如何去做这件事？”克里斯坦森就与他探讨了商业策略，向格鲁夫解释说他可以成立一个新的公司业务单元之类的。格鲁夫生硬地打断了他：“你真是个天真的学院派啊。我问你如何做，你却告诉我应该做什么。我知道自己该做什么。我只是不知道如何做而已。”</p>
</li>
<li><p>克里斯坦森后来解释说，这种什么与如何的区别非常重要，但在职业世界中往往容易被忽略。找出实现某个目标的战略往往很简单，但是真正引领公司上行的反而是确定了战略之后该如何实施战略。</p>
</li>
<li><p>4DX框架下的4种原则，针对每一种原则我都会介绍自己是如何将其加以改进，以应对深度工作习惯培养中的特定问题。</p>
<ul>
<li>原则1：关注点放到极端重要的事情上正如《高效能人士的执行4原则》的作者所说的：“你想做的事情越多，完成的事情反而越少。”这句话阐述的意思是，执行需要专注于少量“极端重要的目标”。这样简化选择，有助于组织和集中足够的精力来达成实在的成果。</li>
<li>原则2：抓住引领性指标确定了极端重要的目标之后，你需要衡量自己的成功程度。在4DX框架下，有两种衡量指标：滞后性指标和引领性指标。滞后性指标用于描述你最终尝试改善的方面<ul>
<li>引领性指标则“衡量了实现滞后性指标的新行为”</li>
<li>引领性指标引导你将注意力转移到提升你在短期内可以直接控制的行为上，并会对你的长期目标带来积极的影响。</li>
<li>对于专注于深度工作的个人而言，确定相应的引领性指标非常容易：专注于极度重要目标上的深度工作状态时间</li>
</ul>
</li>
<li>原则3：准备一个醒目的计分板“计分的时候，人们的表现很不同。”4DX的作者解释道。当驱使你的团队专注于所在组织的极度重要目标时，在一个公开的地方记录、跟踪他们的引领性指标非常重要。这个计分板可以制造一种竞争氛围，驱使他们专注于这些指标，即使其他诉求吸引他们注意力的时候也不例外。此外计分板还可以强化动机。一旦团队注意到他们在引领性指标上的成功，他们就会很投入地保持这种状态。</li>
<li>在前述的一项原则中，我提出要想一个个体专注于深度工作，用于深度工作的时间应该作为引领性指标。因此这个人的计分板应该是工作场所的人工制品，显示这个人当前的深度工作时间。在我早期的4DX实验中，我设定了一种简单但有效的计分方式。[插图]我拿出一张卡片纸，将其剪成条，每一条记录当前学期的一个周。而后我在每一条卡片上记下了每周的日期，将其贴在电脑显示器旁边的墙上（在这里我无法忽略它的存在）。每一周我都在当周的卡片上简单地做个标记，记录当周的深度工作时间。为了使这个计分板带来的动力最大化，每当我的学术论文取得重要进展时（比如解决了一项关键论证），我就会在实现这个成果的那个小时标记上画一个圈。这么做有两个目的。首先，这样可以使我从本能层面将累积的深度工作时长与实在的结果相联系。第二，这样有助于我校准个人对于完成每项成果所需深度工作时间的期望。这种做法（比我最初想象的要更有效）激励我每周都挤出更多的深度工作时间。</li>
<li>原则4：定期问责4DX的作者详细阐释了保持专注于引领性指标的最后一步是要“保持节律性地与同享极度重要目标的团队会面”</li>
<li>对于专注于深度工作的个人而言，很可能没有任何团队去会面，但是这并不意味着你就可以免去定期问责的过程。贯穿本书，我都在探讨、推荐每周回顾的习惯，在每周回顾的过程中你可以指定下一周的工作计划（参见准则4）。在实验4DX的过程中，我每周回顾自己的计分板，庆贺表现好的一周，理清是什么导致了表现糟糕的一周，而且最重要的是找出能够确保未来几天得到好分数的方法。此举使我不断调整日程计划，以满足引领性指标的要求，大幅增加深度工作时间。</li>
</ul>
</li>
<li><p>在整个4DX的实验过程中，目标的明晰性，辅以引领性指标计分板提供的简单但却难以回避的反馈，促使我达到了此前从未实现的深度状态。现在回想起来，这并不是因为我的深度工作强度提升了，而是因为它变得更规律了。以前我常常将深度思考的过程放到论文截稿期前，而4DX习惯能帮助我的头脑全年都保持专注。我必须承认，那一年令我筋疲力尽（特别是我还在同时写作本书）。但是那一年的经历也同样是对4DX的有力认可：到2014年夏天，我有9篇论文被接收，比此前任何一年的成果都要多上一倍</p>
</li>
</ul>
<h3 id="图安逸"><a href="#图安逸" class="headerlink" title="图安逸"></a>图安逸</h3><ul>
<li><p>大多数情况下，你在浮浅工作上投入越多的时间，就能完成越多的工作。但是作为一名作家和艺术家，克莱德尔关注的是深度工作——能够创造出对世界有价值的苦功夫。他坚信完成这样的工作需要定期放松大脑。</p>
</li>
<li><p>一种更实际但也同样有很好启发性的方法：工作日结束的时候，在第二天早晨到来之前，屏蔽掉对工作问题的担忧——晚饭后不要查电子邮件，不要回顾白天的对话，也不要筹划如何处理即将到来的挑战；彻底屏蔽与工作相关的思考。如果需要更多的时间完成工作，就加一下班，但是一旦屏蔽工作之后，大脑就必须放松，如克莱德尔享受金凤花、椿象和星星一样</p>
</li>
<li><p>安逸时光之价值背后的科学道理。仔细研究文献，发现下面三种原因或许可以解释这种价值。</p>
<ul>
<li>原因1：安逸时光有助于提升洞察力<ul>
<li>积极刻意地去思考这些决定结果反而会更糟糕，不如在了解相关信息之后转移到其他事情上，让潜意识去考虑这些事。</li>
<li>无意识思维理论（Unconscious Thought Theory, UTT）——理解有意识和无意识思考在决策中所起作用的一种尝试。从更高层的角度上，这个理论提出在需要严格规则应用的决策中，必须要采用有意识思维。比如，如果你需要做数学计算，只有有意识思维才能严格按照数学运算法则得出正确结果。另一方面，对于涉及大量信息和多项模糊不清之处，甚至存在矛盾和约束条件的决策，无意识思维或许更适合。</li>
<li>UTT推测这种现象是由于大脑的这些区域有更多的神经频宽，可以处理更多的信息，相比有意识思考中心能够筛取更多的潜在解决方法。在这种理论下，你的有意识思维就好似家庭电脑一样，可以通过某种事先编写好的程序，得出有限数量问题的正确答案；而你的无意识思维就好像谷歌庞大的数据中心，通过数据算法在兆兆字节无结构可循的信息中筛选，为困难问题找出出乎人们意料的解决方案。这项研究的结果显示，给有意识的头脑休息的时间可以激活无意识头脑，从而理清最复杂的职业挑战。因此，屏蔽工作的习惯并不一定会降低你高效工作的时间，反而会使你开展的工作类型多样化。</li>
</ul>
</li>
<li>原因2：安逸时光有利于补充深度工作所需的能量<ul>
<li>对于本书的目的真正重要的是认识到ART不仅限于从自然中获得的益处。这个理论的核心机理在于，自主性引导注意力的能力可以得到复原，只要你能停下相应的活动一段时间。在自然中行走可以得到这样的精神放松，因此任何放松行为都可以有同样的效果，只要能够提供类似的“天然引人入胜的刺激”，能够暂时放下自主性专注状态。与朋友轻松地交谈，做晚饭的同时听听音乐，和孩子玩玩游戏，跑跑步——在你屏蔽工作的晚上可以填满时间的各种活动——与在自然中行走都有同样的注意力复原作用。另一方面，如果你整个晚上不停地查看、回复电子邮件，或是晚饭后又安排几个小时赶上即将到期的进度，你就剥夺了自主性注意力复原所必需的无干扰休息。即使中间做的这些工作只用去了很少的时间，也会使你无法达到注意力复原所需的深度放松。只有彻底放下，直到第二天开始之前不再工作，才能说服你的大脑充分放松，开始补充能量，为接下来的一天做好准备。换一种说法，晚间挤出一点时间工作可能会降低你第二天的工作效率，以致最后完成的工作比屏蔽工作还要少。</li>
<li>你每天处于深度工作状态的时间是有限的。如果你的日程安排足够合理（比如，利用准则4中介绍的一些策略），工作时间应该就已经达到了每日深度工作的极限。因此，进一步说来，到夜里你已经没有足够的精力做到有效的深度工作了。任何可以在夜里做的工作都不会是高价值产出的活动，不会对你的事业精进带来真正的益处；你此时的努力应该局限到低价值的浮浅任务上（以一种缓慢、低能耗的节奏进行）。换言之，推后了夜间的工作，你不会有什么重要的损失。</li>
<li>首先必须接受这种承诺，一旦工作日终了，就不能让任何职业相关的事情侵扰你的注意力，再小的也不可以。这其中尤其包括查看电子邮箱，以及浏览与工作相关的网站。上述两种情况下，即使短暂的工作侵扰也会形成一种自我强化的干扰流，持续长时间阻碍前文描述的屏蔽优势</li>
</ul>
</li>
</ul>
</li>
<li><p>定期休息大脑可以提升深度工作的质量。工作时，努力工作。完成时，就放松下来。</p>
</li>
<li><p>不要不断分心，而要不断专注</p>
</li>
<li><p>使用令人分心的网络工具这件事本身，并不能减损你大脑专注的能力。实际上减损这种能力的行为是，稍有无聊或遭遇一点点认知上的挑战，就从低刺激、高价值的活动转向高刺激、低价值的活动，这使得你的大脑不能容忍没有新奇性的东西。</p>
</li>
</ul>
<h3 id="像罗斯福一样工作"><a href="#像罗斯福一样工作" class="headerlink" title="像罗斯福一样工作"></a>像罗斯福一样工作</h3><ul>
<li><p>有一点需要提醒的是，一定要给自己设定一个几乎不可能的时间期限。你应该总是可以赶在最后期限前完成任务（至少是接近），但是这期间需要你用上吃奶的力气。</p>
</li>
<li><p>这个策略的主要意图很明显。深度工作需要专注的强度远远超出了大部分知识工作者的舒适区。</p>
</li>
<li><p>从某种意义上说，罗斯福冲锋配以截止期限，为大脑控制注意力的部分提供了反复的训练，可以系统性地提升你平时的成就水平。另一个益处就是这些冲锋不与分心兼容（在分心的情况下，你是不可能赶在截止期限前完成任务的）。因此，每一次的冲锋都是一个抵抗新奇刺激的过程：你心底里感到无聊，并且真的想寻求更多的新奇刺激，但是你得抵抗。正如我们在前边所讨论的，你抵抗这种冲动的实践越多，你的抵抗力就越强。</p>
</li>
<li><p>在应用这个策略几个月之后，随着前所未有的高强度体验，你对于专注的理解也会改变。如果你像年轻的罗斯福一样，就可以把由此节省出来的时间投入到生活中的赏心乐事中，比如说试着打动那些眼光老辣的纳塔尔鸟类学俱乐部成员。</p>
</li>
</ul>
<h3 id="有成果的冥想"><a href="#有成果的冥想" class="headerlink" title="有成果的冥想"></a>有成果的冥想</h3><ul>
<li><p>有成果的冥想的目标是：在身体劳作而心智空闲的时候（比如走路、慢跑、开车、淋浴），将注意力集中到一件定义明确的专业难题上。因个人专业不同，这个难题可能是为一篇文章列提纲，写一篇讲话稿，推演一个证明，或者是打磨一个商业策略。如同佛教的打坐，你的注意力可能会涣散或停滞，但你必须不断的把它重新集中到当前的问题上。</p>
</li>
<li><p>住在波士顿时，在每天上下班的过河旅途中，我至少做一次有成果的冥想。随着这方面能力的提高，我的成绩也有了提升。比如说，在步行的路上，我想好了上一本书的大部分章节的提纲，也在攻克学术研究方面的棘手问题上取得了进展。我建议你在生活中采用有成果的冥想。你并不需要每天进行严格的练习，一周进行至少两到三次即可。幸运的是，为这个策略找时间是简单的，因为这只需要你利用本可能被浪费掉的时间（比如说遛狗和通勤）。如果一切顺利，这种做法可以提升你在专业上的产出，却不需要占用你的工作时间。实际上，为了用有成果的冥想来解决你当前最紧急的问题，你甚至可以考虑在工作时间安排一次散步。</p>
</li>
<li><p>然而，我在这推荐有成果的冥想并不仅仅是因为它能提高生产效率（这当然已经很好了），而是因为它可以迅速提高你深度思考的能力。按照我的经验，有成果的冥想可以帮助你实现在本准则引言中介绍的两个关键理念。它通过迫使你抵抗分心，不断地把自己的注意力集中到一个定义明确的问题上，来增强你抵抗分心的心智。通过迫使你在一个问题上不断深入研究，助力专注能力的提升。为了更好地利用有成果的冥想，有一点必须要注意，那就是和其他的冥想一样，这种能力需要实践来磨炼。</p>
</li>
</ul>
<h3 id="准则3-远离社交媒体"><a href="#准则3-远离社交媒体" class="headerlink" title="准则3 远离社交媒体"></a>准则3 远离社交媒体</h3><ul>
<li><p>我们越来越深刻地意识到这些工具把我们的时间碎片化，削弱了我们集中注意力的能力。这一点现在几成定论。</p>
</li>
<li><p>在训练自己的同时沉迷于手机应用和网页浏览中，那么你的努力就可能会事倍功半。一个人的意志力是有限的，你的工具对你越有吸引力，你就越难在重要的事情上集中注意力。因此，要掌握深度工作的艺术，你必须摆脱各种各样的诱惑，重新掌控自己的时间和注意力。</p>
</li>
<li><p>当前知识分子讨论网络工具和注意力的问题时表现出来的无能。明明知道这些工具在压榨自己的时间，瑟斯顿却不知所措，他感觉自己唯一的选择就是（暂时的）完全戒掉网络。这种认为应对社交媒体和娱乐信息节目分散注意力问题的唯一方法就是选择激进的“网络假期”[插图]的想法，正逐渐占据我们文化讨论的主流。这种二元论的处理问题方法存在的缺点就是这两种选择都太残忍，因此不可能有用。很显然，认为可以戒掉网络的观点属于冠冕堂皇地偷换概念，对大多数人来说是不可行的（除非你是一名正在尝试写一篇关于分散注意力事物的记者）。没人会真的效仿巴拉唐德·瑟斯顿的做法——这个事实也证明了另一个选择的正确性：认识到我们目前注意力被分散的状态是不可避免的并接受现实。</p>
</li>
<li><p>认识到这些工具并不完全是邪恶的，有些甚至对你的成功和幸福是十分重要的；然而与此同时，也意识到应该对那些能够经常占用你时间和注意力（更不要说个人信息）的网站设立一个严格的限制标准，大部分人应该更少地使用此类工具。换言之，我不会要求你像2013年的巴拉唐德·瑟斯顿那样完全戒掉网络25天，但是我会要求你避免那种促使他开展激进实验的状态——注意力分散并且超高度依存于网络。网络的使用存在着一个中庸状态。如果你对深度工作的习惯感兴趣，你必须努力争取达到这个中庸状态。</p>
</li>
<li><p>选择网络工具的“任何益处法”：一旦发现使用一款网络工具有任何可能的益处，或者是不使用就可能错过某些事，你就觉得有足够理由使用这款网络工具。 很显然，该方法的缺点就是忽视了伴随这款网络工具而来的各种弊端。这些网络工具具有致瘾性——从那些对实现职业和个人目标有更直接帮助的活动中（比如说深度工作）抢走时间和注意力。如果过度使用这些工具，你将陷入精疲力竭、注意力散乱的网络依赖状态，就是这种状态使巴拉唐德·瑟斯顿和像他一样数以百万计的人们饱受煎熬。这就是任何益处思维定式带来的不容易察觉的危害。使用网络工具也是可以带来害处的。如果你不努力权衡利弊，一看到可能的益处就决定不加限制地使用某种工具，那么你就可能在不知不觉中失掉了在知识工作世界里取得成功的能力。客观来讲，这个结论并不令人惊奇。在网络工具的背景下，我们已经习惯了任何益处的思维定式，但是如果我们放宽视界，在熟练劳动[插图]的维度下思考这种思维定式，我们就会发现这是一种诡异的、目光短浅的工具选择方法论。</p>
</li>
<li><p>工具选择的手艺人方法：明确在你的职业和个人生活中决定成功与幸福的核心因素。只有一种工具对这些因素的实际益处大于实际害处时才选择这种工具。</p>
</li>
<li><p>请注意，此手艺人方法与任何益处方法恰好相对立。任何益处思维定式认为任何潜在的益处都可以成为使用此工具的借口，手艺人方法要求这些益处能够影响到核心因素，并且益处大于害处。</p>
</li>
</ul>
<h3 id="在你的网络使用习惯中采用关键少数法则"><a href="#在你的网络使用习惯中采用关键少数法则" class="headerlink" title="在你的网络使用习惯中采用关键少数法则"></a>在你的网络使用习惯中采用关键少数法则</h3><ul>
<li><p>问题不是推特是否带来了益处，而是它带来的益处是否足够抵消它所消耗的你的时间和注意力</p>
</li>
<li><p>关键少数法则在许多情境中，80%的已知效果源自20%的可能原因。</p>
</li>
<li><p>有一个正式的数学原理能够说明这一现象（一个80&#x2F;20的分布大概符合幂律分布，这种分布在现实世界进行测量时会经常遇到），并可以来创造性地提醒大家，在许多情况中，一个结果成因中的诸因素并不是地位平等的。</p>
</li>
<li><p>再进一步，假设这一法则对我们生命中的重要目标也是成立的。</p>
</li>
<li><p>如果公司80%的利润来自20%的顾客，那么公司可以通过从带来低利润的顾客身上节省更多的精力，用于更好地服务少数带来高利润的顾客——花在后者身上每一小时的产出都高于花在前者身上的。这个道理也适用于你的职业和私人生活。把花在低影响力活动上的时间（比如在脸谱网上找老朋友）转投到高影响力的活动上（比如和一位好朋友共进午餐），这样你就能取得目标的更大成功。因此，放弃使用一款网络工具的逻辑是放弃它所能带来的小益处，转而致力于你已经知道的可能带来更大益处的活动。</p>
</li>
</ul>
<h3 id="戒掉社交媒体"><a href="#戒掉社交媒体" class="headerlink" title="戒掉社交媒体"></a>戒掉社交媒体</h3><ul>
<li>我认为社交媒体大行其道的一个原因，就是它打破了努力创作有实际价值的作品和吸引到人们注意力之间的正相关关系。相反的，它用浅薄的集体主义式交换取代了永恒的资本主义交换：如果你注意我说了什么，我就会注意你说了什么，不管这话语有无价值。</li>
</ul>
<h3 id="不要用网络来消遣"><a href="#不要用网络来消遣" class="headerlink" title="不要用网络来消遣"></a>不要用网络来消遣</h3><ul>
<li><p>一旦你阅读了其中某一网站的一篇文章，页面旁边或底部的链接会吸引你接着点击，持续点击。人类心理学中任何一个可使用的把戏都用于其中，从把标题列为“流行”或“趋势”到使用醒目的图片，目的就是吸引住你。比如，就在此时此刻，BuzzFeed上最受欢迎的文章包括：“17个倒过来拼写就会意思完全不同的单词”和“33只赢得一切的狗”。一周的工作结束时，如果你有些空闲时间，这些文章就成为你主要的娱乐，在这种情况下，这些网站尤其有害。当你在排队，或者等待电视节目中的情节有所进展，或者是等待吃饭的时候，这些文章可以成为你打发时间的工具。</p>
</li>
<li><p>然而，如我在准则2中所说，这些行为是有害的，因为它们损害你抵抗分心事物的能力，使你在试图深度工作的时候更难集中注意力。更可怕的是，这些网络工具不需要你登录，因此在生活中更难戒掉（这使得之前的两个策略失效）。它们总是触手可得，只需要随手点几下。幸运的是，阿诺德·本内特在一百多年前就发现了解决之道：在你的娱乐时间做更多的思考。换言之，这个策略就是指在个人娱乐的时候，不要被任一随意的事物吸引，相反应该主动思考我如何度过“一天中的一天”。我们之前提到的这些致瘾性网站在真空中才能活跃：如果你没有在某一个特定时段给自己安排任务，这些网站总是一种有诱惑力的选择。如果你在自由时间有高质量的事情去做，这些网站对你的注意力的控制就会减弱。</p>
</li>
<li><p>因此，在晚上或周末到来之前就确定要做的事情是十分重要的。一些安排好的爱好为这些时间提供了充足的养料。为了特定的目标完成特定的活动，这将填满你的时间。根据本内特所言，每个晚上都有序地阅读自己挑选好的一系列书，也是一个很好的选择。同样的活动还有锻炼，与益友（面对面）交往。</p>
</li>
<li><p>消遣做得这么有条理会有损消遣的目的，因为许多人相信消遣就是要没有任何计划，没有责任。安排得一板一眼的晚上是否会让你在第二天工作的时候感到困乏，无法焕然一新？感谢本内特，他已经预料到了这样的担忧。他解释称，此等担忧源自对真正令人类恢复精力的事物的误解： 什么？你认为在那16个小时投入全部的精力会削弱工作8小时的价值？不是的。恰恰相反，它必定会增加工作8小时的价值。人们都要懂得一个重要的道理，人的智力系统可以进行长时间的高强度活动：它不像人的手脚一样会疲倦。除睡觉以外，它只需要变化，而不是停止。</p>
</li>
<li><p>按照我的经验，这个分析完全正确。如果在你全部的清醒时间，都能给自己的大脑找到有意义的事情去做，而不是放任自己在迷糊的状态下漫无目的地浏览几个小时网页，那么在一天结束时，你会觉得更加充实，第二天开始时更加轻松。总结一下，如果你想抵御娱乐网站对你时间和精力的诱惑，那么就给大脑找一些高质量的替代活动。这样不仅可以使我们避免分心，保持专注的能力，同时还有可能实现本内特的宏伟目标：体验到何为生活，而不仅仅是生存。</p>
</li>
</ul>
<h3 id="准则4-摒弃浮浅"><a href="#准则4-摒弃浮浅" class="headerlink" title="准则4 摒弃浮浅"></a>准则4 摒弃浮浅</h3><ul>
<li><p>2007年夏天，软件公司37signals（现在叫basecamp）做了一个实验：将每周5天工作制缩短成4天。尽管工作日少了一天，但是员工似乎还可以完成相同的工作量，于是他们的这项改革变成了永久政策：每年5～10月，37signals的员工只需从周一工作到周四（售后服务除外，他们一周7天都要工作）。公司发起人之一贾森·弗里德（Jason Fried）在博文里风趣地说道：“在夏季，人们应该享受美好的天气。”</p>
</li>
<li><p>4天完成40小时的工作对于员工来说是十分有压力的。但是他解释道，这不是他所建议的工作方式。“一周4天工作制的意义在于做更少的工作。”他写道，“不是一天10小时的工作……是正常的一天8小时。</p>
</li>
<li><p>很少有人能做到一天工作8个小时。在充斥着各种会议、干扰、网页浏览、办公室政治和私人事务的一个普通工作日里，能够专心工作几个小时就已经很幸运了。更少的正式工作时间有助于挤压出更高的效率。如果每个人都只有更少的时间完成任务，他们就会更加尊重时间。人会变得珍惜时间，而这是一件很好的事情。他们不会把时间花在无关紧要的事情上。如果拥有的时间变少，你就会更聪明地利用时间。</p>
</li>
<li><p>换句话说，37signals工作时间的减少主要是集中在浮浅工作而不是深度工作。因为深度工作几乎没有减少，所以重要的事情仍能完成。结果证明那些原来看似十分紧急的浮浅工作其实是无关紧要的。</p>
</li>
<li><p>虽然深度工作的价值远远超过了浮浅工作，但这并不意味着你必须像堂吉诃德一样试图把你所有的时间都投入到深度工作中。其中一个方面是，一定量的浮浅工作在大多数知识工作中是必要的。你应该可以避免每10分钟检查一次自己的电子邮件，但是不可能永远不回复重要的信息。从这个意义讲，我们应该明白该准则的目标是减少浮浅工作在我们日程中的分量，而不是将其消除。</p>
</li>
<li><p>在给定的一天时间内，一个人可以保持多长时间的深度工作。</p>
</li>
<li><p>一天一小时是一个合理的上限。对于熟悉此类活动严酷性的人来说，上限可以达到4个小时，但是很少能持续更久。</p>
</li>
<li><p>这意味着一旦你在一天中达到了深度工作的上限后，继续试图增加深度工作效果就会下降。因此，浮浅工作并不可怕，只有其比例增加太多影响到你当天的深度工作上限时才需要注意。乍一看，这个警示或许没有那么可怕。通常一个工作日8个小时。这8小时内，没有一个熟练的深度工作者可以保持超过4个小时的深度状态。这样的结果就是一天中你可以有半天做浮浅工作，而且不会有害处。可是你可能没有意识到这些时间其实很容易被占用，尤其要考虑那些会议、预约、电话和其他计划内事务。在很多工作中，这些时间终结者将导致你每天只有很少的时间可以单独工作。</p>
</li>
<li><p>总而言之，希望你能用怀疑的眼光对待浮浅工作，因为其害处经常被低估，而作用却经常被高估。这种工作不可避免，但是你必须对其加以限制，使其不影响你充分深度工作的能力，因为深度工作决定着你的最终工作成效。接下来的策略将助力你的实践活动。</p>
</li>
</ul>
<h3 id="一天的每一分钟都要做好计划"><a href="#一天的每一分钟都要做好计划" class="headerlink" title="一天的每一分钟都要做好计划"></a>一天的每一分钟都要做好计划</h3><ul>
<li><p>我们一天中的大多数时间是在浑浑噩噩中度过的，对于应该如何安排时间并没有考虑太多。这是一个问题。如果不果敢地调整深度工作与浮浅工作的关系，不在行动前暂停一下问问自己“现在去做什么是最有意义的”，你将很难避免被烦琐杂事占满日程。接下来的几个段落将会介绍一些促使你这样做的策略。这些观点乍一看显得极端，但是很快你就会发现要充分享用深度工作的好处，就需要一天中的每一分钟都要做好计划。</p>
</li>
<li><p>我建议：为本策略专门准备一个笔记本，在每个工作日开始的时候翻开新的一页。在页面的左侧，每隔一行写下这一天的每一个小时，包括普通工作日的全部时间。接下来是最重要的一个环节：将工作日的每一天划成方格，把活动放在这些空格中。</p>
</li>
<li><p>完成一天的工作计划之后，每一分钟都应该在某个方格里有所体现。实际上，你已经为这一天的每一分钟安排了时间。此时，请你使用这个工作计划来引导一天的工作。可以预见的是，大部分人从这一步开始就遇到了麻烦。随着一天工作的展开，关于该工作计划，有两个方面容易（并且也极为可能）出岔子。第一，你的计划可能不符合实际。例如你为写新闻通讯稿预留了两小时，但是实际上你花掉了两个半小时。第二，你可能会被打断，新的工作任务会出现到你的日程里。这些事情也会打乱你的日程。这些都没有问题。如果你的日程被打断，在紧接下来的空闲时间，就应该花几分钟修改一天余下时间的计划。你可以翻到新的一页，也可以擦掉原有的重新编写，还可以像我一样：划掉原有的方格，在其右方为今天剩余的时间画出新的方格（我画的格子很瘦，所以有足够的空间修改几次）。有些日子里，你可能一天要修改十多次计划。如果出现了这种情况，不要气馁。你的目标并不是竭尽全力维持既定的计划，而是在时间的推进中掌握工作的主动权，即使是在一天中，我们的决定也会一变再变。如果你觉得计划改变的频率高得难以接受，这里有一些可以增加稳定性的诀窍。首先，你应该承认，你对大多数事情所需要的时间是预备不足的。刚开始尝试这个习惯时，很可能会一厢情愿地制定计划——完美一天的样板。经过一段时间的练习，你应该尝试准确地（甚至有些保守地）预估完成任务所需要的时间。</p>
</li>
<li><p>第二个诀窍就是使用备用方格。如果你不确定一个既定任务需要多长时间，先初步预估需要的时间，然后在下面再多安排一个方格，这个方格可以有多重作用。如果这个既定任务需要更多时间才能完成，那么就占用下边这个备用方格。但是如果你在预定的时间内完成了任务，那么就把备用的方格安排做其他的活动（比如说一些非紧急事务）。这样就可以保证在不改变日程的情况下，容许不可预知的事情发生。</p>
</li>
<li><p>在我的日常安排原则里，除了经常会为探索性思考和探讨预留大块的时间格之外，还时刻保持着一项准则，即一旦有灵光乍现，有了突破性的洞见，一天的其他日程安排就都可以暂时抛到一边（当然，实在抛不到一边的也没有办法）。之后我会坚持探究这种新的洞见，直到理清其中的头绪。这之后我会抽身出来，重新安排一天余下的时间。换言之，我不仅允许日程中有突发性改变，甚至会主动寻求这种改变。约瑟夫的批评是源于他对日程表的误解，他认为日程表就是强迫一个人严格按计划行事。然而我所说的日程计划的核心目的不是限制，而是强调谋划周到。在一天里时常拿出一点时间来询问自己“在今天剩下的时间里，我做什么最有道理”，是一个很简单的习惯。这是一个让你思考如何产出最大化的习惯，而不是让你对自己的答案保持不折不挠的忠贞。我甚至要说，一个同时具有综合计划能力和修正自己计划的意愿的人，相比那些采用传统“自发性”方法、一天没有任何计划的人，将享有更多的创造性洞见。没有计划，你的时间很可能被浮浅事务占用——电子邮件、社交媒体、浏览网页。这些浮浅事务虽然在短时间内会令人愉悦，但是并不有助于培养创造力。借助计划，你可以确保经常性的安排时间来处理新主意，或者在有挑战性的领域进行深度工作，或者在一个固定时间内进行头脑风暴——这些活动更容易带来创新（例如回想一下在准则1中，很多著名的创意思考者所遵循的一些习惯）。因为当创新性想法出现时，你也愿意放弃原本的日程安排，所以在灵感涌现的时候，你也可以像那些纷扰中搞创新的人一样跟进。</p>
</li>
<li><p>总而言之，该策略的目的在于帮助你认识到，深度工作要求你尊重自己的时间。要做到真正尊重时间，下面这一条建议是个很不错的开端：提前决定你一天的每一分钟要做什么工作。因为一个人的日程都是由内在驱动和外在要求这两股力量决定的，所以开始的时候你对这个主意有所抵触也是自然的。但是如果你想发掘自己的潜力，成为一个有所成就的人，那就必须打破这种疑虑。</p>
</li>
</ul>
<h3 id="定量分析每一项活动的深度"><a href="#定量分析每一项活动的深度" class="headerlink" title="定量分析每一项活动的深度"></a>定量分析每一项活动的深度</h3><ul>
<li><p>浮浅工作：对认知要求不高的事务性任务，通常在受到干扰的情况下开展。此类工作通常不会为世界创造太多新价值，且容易复制。</p>
</li>
<li><p>为你提供一个明确而且稳定的计量表，以衡量一项给定任务的深浅度。如使用这个策略，你需要先问自己一个简单（但是很有启发性的）问题来评估这些任务： 要让一个刚毕业还没有在该领域接受特别训练的大学生完成这项工作需要多久（几个月）？</p>
</li>
</ul>
<h3 id="向老板申请浮浅工作预算"><a href="#向老板申请浮浅工作预算" class="headerlink" title="向老板申请浮浅工作预算"></a>向老板申请浮浅工作预算</h3><ul>
<li><p>有一个很重要的问题很少被问及：你的时间应该有几成被投入到浮浅工作中？这个策略建议你问一下这个问题。也就是说，如果你有老板的话，应该和他谈谈这个问题（或许你应该先向他们介绍“深度工作”和“浮浅工作”的定义）。如果你是自己当老板，问自己这个问题。两种情况下，都力争得到一个答案。然后——这是重要的一环，试着控制在这个预算范围内。</p>
</li>
<li><p>你可以自信地对老板说：“这正是我上周在浮浅工作上的时间占比，”然后迫使他或她明确同意你给出的比例。在数据及其阐释的经济现实面前（比如说，让一位受过高等训练的专业人士回复电子邮件、一周参加30个小时的会议，是不可思议的浪费），老板自然会得出这样的结论：你需要拒绝一些事情，简化一些事情，即使这会使得你老板或同事的生活舒适度降低。因为一项生意的最终目的还是产出价值，而不是确保员工的生活尽可能简单。如果你自己做老板，这项练习将使你正视现实：你“繁忙”的日程中只有很少一部分时间是真正产出价值的。这些残酷的数据将激发你的信心，减少那些偷走时间的浮浅活动。没有这些数据，一位企业家将很难拒绝任何可能产生某种积极回报的机会。</p>
</li>
<li><p>“我要上推特！”“我要保持在脸谱网上的活跃度！”“我得优化博客上的小工具栏！”因为独处的时候，拒绝这些活动可能会显得你很懒。通过学习并坚持这种深浅度的分配比例，你可以摆脱因羞耻感而带来的无条件接受，转而坚持更健康的习惯，把本来留给浮浅工作的时间节省下来以发挥其最大效用（这样你仍然面临很多机遇），把浮浅工作占用的时间和精力限制得足够小，从保证你的深度工作推动事业进步。</p>
</li>
<li><p>一份不需要深度工作的工作不可能使你在当前的知识经济时代取得成功。在这种情况下，你应该感谢老板的反馈，然后迅速谋划如何转型到一个重视深度的新岗位。</p>
</li>
</ul>
<h3 id="5点半之前结束工作"><a href="#5点半之前结束工作" class="headerlink" title="5点半之前结束工作"></a>5点半之前结束工作</h3><ul>
<li><p>5点半之前结束工作在我写这段话前的连续7天，我进行了65个不同的电子邮件对话。在这65组对话中，我在5点半后只发送了5封电子邮件。上例中的这些数据直接说明了一个事实：除极个别例外，我不在5点半后发电子邮件。总体来说，电子邮件和我们的工作是紧密相连的，所以这个事例告诉我们一个更令人吃惊的现实：我不在5点半后工作。</p>
</li>
<li><p>我把这种坚持叫作固定日程生产力。因为我确定了一个坚定的目标，在某个固定时间后不再工作，然后在工作中寻找提高产出的策略以达成目标。</p>
</li>
<li><p>减少浮浅工作为实现深度工作节省了更多的精力，使我们的产出比采用密集日程安排时更高。其二，我们的时间有限，因而会更谨慎地思考个人的组织习惯，这也使得我们产出的价值能够高于采用长时间但混乱的日程安排的人。</p>
</li>
</ul>
<h3 id="变得不容易联系到"><a href="#变得不容易联系到" class="headerlink" title="变得不容易联系到"></a>变得不容易联系到</h3><ul>
<li>森特诺认为用私人一对一的对话来一遍又一遍地回答相同的问题是十分不经济的。如果你过了这一步，他会让你点击几个复选框来做出以下三种承诺：√我不是在问安东尼奥一个使用谷歌搜索10分钟就可以得到答案的问题。√我不是复制粘贴了常见请求给安东尼奥发垃圾邮件，以推销我个人的不相关生意的。√如果安东尼奥在23个小时内答复我，我将为某位陌生人做一件善事。当你点击同意了所有三个承诺之后，联系页面才会出现一个信息框供你输入信息。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>深度的生活并不是适合所有人。你需要为此付出艰苦的努力，从根本上改变你的习惯。对于很多人来说，快速地收发电子邮件和在社交媒体上发消息所带来的繁忙假象会给他们带来慰藉，深度的生活却是要你摆脱这些东西。在你尽个人全力去创造一件美好的事物时，会有一种不安牵扰着你，因为这迫使你面对自己最好的成果（暂且）还没有那么好的可能。与涉足政坛，期望做出一番事业相比，夸夸其谈地品论我们的文化会显得更安全。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果你无法学习，就无法成功</li>
<li>无干扰状态下保持专注</li>
<li>高质量工作产出&#x3D;时间×专注度</li>
<li>转移工作、注意力残留 -&gt; 专注、深度工作</li>
<li>深度工作并非是我们的经济中唯一有价值的技能，不培养这种能力也有可能做得很好，但是不需要深度工作的职业会越来越少。</li>
<li>最小阻力原则</li>
<li>忙碌代表生产能力（Busyness as Proxy for Productivity）：在工作中，对于生产能力和价值没有明确的指标时，很多知识工作者都会采用工业时代关于生产能力的指标，以可视的方式完成很多事情。</li>
<li>支持深度工作往往要抵制新的高科技</li>
<li>当工作中没有明确目标时，围绕浮浅工作的表面忙碌会成为一种本能</li>
<li>工作其实比休闲时光更容易带来享受？</li>
<li>意志力是有限的</li>
<li>培养深度工作的习惯，关键在于越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序，使得进入并保持高度专注状态消耗的意志力最小化。！！！！！</li>
<li>选定你的深度哲学（节奏哲学）、并习惯化</li>
<li>恰当展开协作可以提升你在职业生活中深度工作的质量</li>
<li>这种隔音办公室与宽阔公共空间的组合，形成了中心辐射型的创新建筑结构，在这里偶遇的意外发现和与世隔绝的深度思考都能实现。</li>
<li>专注于少量“极端重要的目标”</li>
<li>引领性指标</li>
<li>专注于极度重要目标上的深度工作状态时间</li>
<li>4DX框架下的4种原则 ！！！</li>
<li>在整个4DX的实验过程中，目标的明晰性，辅以引领性指标计分板提供的简单但却难以回避的反馈，促使我达到了此前从未实现的深度状态。</li>
<li>定期放松大脑！！工作日结束的时候，在第二天早晨到来之前，屏蔽掉对工作问题的担忧。</li>
<li>定期休息大脑可以提升深度工作的质量。工作时，努力工作。完成时，就放松下来。</li>
<li>不要不断分心，而要不断专注</li>
<li>设定一个几乎不可能的时间期限；深度工作需要专注的强度远远超出了大部分知识工作者的舒适区。</li>
<li>有成果的冥想</li>
<li>远离社交媒体</li>
<li>在晚上或周末到来之前就确定要做的事情是十分重要的。（避免陷入其他无效的诱惑）</li>
<li>人的智力系统可以进行长时间的高强度活动：它不像人的手脚一样会疲倦。除睡觉以外，它只需要变化，而不是停止。！！！</li>
<li>如果你想抵御娱乐网站对你时间和精力的诱惑，那么就给大脑找一些高质量的替代活动。这样不仅可以使我们避免分心，保持专注的能力，同时还有可能实现本内特的宏伟目标：体验到何为生活，而不仅仅是生存。</li>
<li>减少浮浅工作在我们日程中的分量，而不是将其消除</li>
<li>一天的每一分钟都要做好计划（笔记本）</li>
<li>深度工作要求你尊重自己的时间。要做到真正尊重时间，下面这一条建议是个很不错的开端：提前决定你一天的每一分钟要做什么工作。</li>
<li>5点半之前结束工作。固定日程生产力。</li>
<li>变得不容易联系到；文档化</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/10/">&gt;</a>
  </nav>





          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
<a href="/archives/">                
<!--<a href="/archives/%7C%7C%20archive">-->
              
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">162</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingson Wu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
