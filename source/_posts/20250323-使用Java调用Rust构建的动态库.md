---
title: 使用Java调用Rust构建的动态库
date: 2025-03-23 14:41:37
tags: [Rust, Java, JNI]
---

>> 近期帮朋友做一个需求，需要将某个Rust项目的一部分功能移植到Java中，使Java应用能使用

## 方案1: 直接将Rust翻译成Java代码
>> 前置准备：将Rust项目跑通，方便通过debug对照执行细节，从而一步步翻译成Java代码
>> 希望借助AI的力量帮忙完成

+ 借助AI的方案如下：
    - 首先，我已经跑通了需要抽取的功能的相关测试用例
    - 然后，让AI帮忙将涉及这些功能相关的代码抽取成单独的Rust项目（结果还是很乱七八糟）
    - 大概是因为上下文内容太多的关系，AI执行任务的效果很差
    - 没办法，于是自己拆分代码，让AI软件帮忙根据代码块逐个进行转化，结果效果是好了很多，能帮助不少，不过这样效率太低，而且AI有时候也经常出错，需要自己慢慢调整
    - 看来AI目前在一次性的转化大量代码的效率和准确性还是不够
    - 本次程序员该懒就懒的宗旨，我决定另辟蹊径，采用方案2

## 方案2: 直接将相关功能的Rust功能编译成动态库，由Java直接调用
>> 省去翻译代码的重复工作
>> 需要构建不同平台的动态库
>> Java代码在加载前需要判断环境加载相应的动态库
>> 使用Github Action来构建各种平台的动态库
>> Java端充分测试，Java8应用测试，Java9以上模块化系统是否可用测试，Windows等其他平台测试

---

>> 以下由AI（ChatGPT）帮我完成的文章

# 使用Java调用Rust构建的动态库

## 引言

在最近的一个项目中，我需要将一个Rust项目中的部分功能迁移到Java应用中，供Java系统调用。为了简化过程，我决定绕过将Rust代码完全转化为Java的复杂任务，而是直接通过Rust构建动态库，再通过Java来调用。这种方法不仅减少了代码转换的工作量，还利用了Rust的高性能特点，提高了Java应用的效率。

## 方案1: 直接将Rust翻译成Java代码

### 前置准备

为了开始这个过程，我首先确保了Rust项目能够成功运行，并且通过调试工具逐步分析每个功能的执行细节。这是为了确保我可以一步步将Rust的实现逻辑转化为Java代码。

### 使用AI进行代码转换

最初，我尝试借助AI工具自动化地将Rust代码转换为Java代码。以下是我使用AI进行代码转换的过程：

- 我首先跑通了相关的测试用例，确保所有需要移植的功能都能正常工作。
- 然后，我让AI帮助抽取与这些功能相关的Rust代码，并转化成单独的Rust项目。但由于上下文过多，AI的效果并不理想，生成的代码混乱且不完整。
- 之后，我将代码拆分成更小的部分，让AI逐一处理，虽然效果有所改善，但这种方式依旧效率低下，且AI经常会出错，导致我不得不花大量时间修正。

这一过程中，我意识到AI在一次性大规模转化代码时的准确性和效率仍然有待提升。最终，我决定放弃这条路，转而尝试另一种更直接的方案——方案2。

## 方案2: 直接将Rust功能编译成动态库，由Java调用

### 思路与优势

与其将Rust代码翻译成Java代码，我决定直接将Rust的功能编译成动态库（.dll 或 .so），然后在Java中通过JNI（Java Native Interface）调用这些动态库。这样可以避免代码翻译过程中的麻烦，并且能够充分利用Rust在性能上的优势。

### 构建Rust动态库

在实现这一方案时，我需要做以下几个步骤：

1. **编译Rust代码为动态库**：通过Rust的`cargo`工具，将Rust代码编译成适用于不同平台的动态库。这需要为每个平台生成相应的二进制文件，如Windows下的`.dll`，Linux下的`.so`，以及MacOS下的`.dylib`。
   
2. **使用Github Actions自动化构建**：为了支持多平台的动态库构建，我使用了Github Actions来自动化构建过程。这样，无论是Windows、Linux还是MacOS，都会根据需要自动生成对应的动态库，极大地简化了跨平台的构建工作。

3. **Java端加载动态库**：Java通过JNI加载Rust编译出的动态库，并调用其中的函数。在加载时，Java代码会先检测当前运行环境，根据操作系统加载相应的库文件。

4. **平台兼容性测试**：为了确保Java能够顺利调用Rust动态库，我在多个平台上进行了充分的测试。这包括：
   - 在Java 8环境下进行功能测试。
   - 验证在Java 9及以上版本的模块化系统下，Java与Rust动态库的兼容性。
   - 测试在Windows、Linux和MacOS等不同平台下的表现。

### 方案优势

- **减少工作量**：不需要将Rust代码完全翻译为Java代码，避免了翻译过程中的复杂性和错误。
- **高效的性能**：Rust的性能优势得以保留，Java通过调用Rust动态库，可以在性能上得到显著提升。
- **跨平台支持**：通过自动化构建不同平台的动态库，Java应用能够轻松支持Windows、Linux、MacOS等多种操作系统。

## 总结

通过将Rust功能编译成动态库并在Java中调用，我成功地绕过了将Rust代码完全转化为Java的复杂过程，同时还能够充分利用Rust的性能优势。虽然在构建过程中涉及到平台适配和自动化构建，但这一方案的灵活性和高效性使其成为解决问题的最佳选择。对于有类似需求的开发者来说，这无疑是一个值得尝试的方案。