---
title: 刷leetcode总结的算法基础和套路
date: 2025-07-09 15:20:22
tags: [算法, algorithm, leetcode]
---

>> 最近重新刷leetcode，对一些算法基础和套路做下总结，以做备忘


---

# 简要分类总结

- 数据结构
    - 堆
- 遍历算法
    - 深度优先搜索（DFS）
        - 回溯 （= DFS + 剪枝 + 状态恢复（回退））
    - 广度优先搜索（BFS）    

---

# 典型问题

## TopK
- 不要求有序：使用快排； 当然也可以使用堆
- 要求有序：使用堆：最大堆（前k个最大），最小堆（前k个最小）

## 快慢指针
+ 19.删除链表的倒数第 N 个节点 （快指针多走N步，到最后节点时则慢指针到达该删除的节点）
+ 141.环形链表 （快慢指针，快的每次两步；有环则最终会相遇）
+ 142.环形链表 II（快慢指针相遇之后，快指针从head开始重新走，slow继续走，再次相遇的点即入环点）
+ 234.回文链表（快慢指针找中点，同时慢指针构造逆转列表【逆转列表可以原地反转，不用额外的数组空间】
从中点开始和逆转列表对比）
+ 287.寻找重复数（Floyd 判圈算法，第一次相遇之后，把其中一个指针置为起始点，第二次相遇时就是环的入口）

## 双指针
+ 160.相交链表（双指针同时走，到空了之后分别指向对方的头指针继续走（这样两边的长度就一样了）；相等时则为相交节点（如果都为空则不相交））


---

# 经典题目

## 缓存
+ 146.LRU 缓存 （hashmap + 双向链表）
    ```go
    type LRUCache struct {
        data     map[int]*LinkedNode
        head     *LinkedNode
        tail     *LinkedNode
        count    int
        capacity int
    }

    type LinkedNode struct {
        key  int
        val  int
        pre  *LinkedNode
        next *LinkedNode
    }`    
    ```
    - hashmap保存key和val（node指针）
    - 双向链表，队头为最近访问（或新节点），队尾用于后续淘汰

+ 460.LFU 缓存 (双哈希 + 双向链表)
    ```go
    type LFUCache struct {
        keyToValFreq   map[int]*LFUNode
        freqToKeysHead map[int]*LFUNode
        freqToKeysTail map[int]*LFUNode
        minFreq        int
        capacity       int
        size           int
    }

    type LFUNode struct {
        key  int
        val  int
        freq int
        pre  *LFUNode
        next *LFUNode
    }
    ```
    - keyToValFreq: map[key] => (value, freq)
    - freqToKeys: map[freq] => keys 双向链表(按 LRU 顺序存 key)
    - minFreq: 当前所有 key 中的最小 freq
    - capacity: 缓存容量
    - Put:若 key 已存在：- 更新 value !!!

## 打家劫舍
+ 198.打家劫舍（相邻不能偷）
    - 动态规划
    - d[i] 是 表示前 i 间房屋能偷窃到的最高总金额；
    - dp[i]=max(dp[i−2]+nums[i],dp[i−1])
+ 213.打家劫舍 II（围成一圈）
    - 分别取 (start,end)=(0,n−2) 和 (start,end)=(1,n−1) 进行计算，取两个 dp[end] 中的最大值
+ 2560.打家劫舍 IV （小偷总能窃取至少 k 间房屋。返回小偷的 最小 窃取能力【最大单间金额】）   
    - 二分答案 + 贪心判断
    - lower= min(nums), upper=max(nums)，令 middle=(lower+upper)/2
    - 试试只偷不超过 middle 元的房子，能不能选出 k 间、且不相邻？（贪心判断）
    - 不断缩小这个 x，找最小可行值（二分查找）
+ 337.打家劫舍 III [二叉树]    
    - 递归函数，传root，返回偷和不偷当前节点的最大值

## 课程表    
+ 207.课程表
    - 有向图检查是否有环
    - 拓扑排序(Kahn 算法） 卡恩算法)，最后检查len(ans) == len(inDegree)

## 会议室
+ 253.会议室 II（计算至少需要多少间会议室）
    - 排序 + 优先队列（最小堆）
    - 会议开始时间升序排序，然后用一个最小堆（min heap）来保存当前所有正在进行的会议的结束时间。
    - 最小堆代表了所有正在占用的会议室的结束时间。堆顶元素就是最早结束的会议时间
    - 按时间线模拟整个会议的进行， 最后优先队列剩余的就是最少的会议室数
+ 2402.会议室 III（举办最多次会议的房间编号【优先编号最小的，不够会议室延期，优先最早开始的】）
    - 所有会议先按开始时间排序
    - 以结束时间最小(结束时间一样，按id最小)构建n大的最小堆（n个会议室）（将第一个会议的开始时间作为全部会议室的结束时间）
    - 每次pop之后，当endTime < 将进行会议的 startTime， 则 endTime = startTime，重新push进去；重新pop，知道 endTime >= 将进行会议的 startTime（全部会议室都按此操作一遍）
    - 那么新的endTime = endTime + (会议endTime - 会议startTime)， 重新push
    - 遍历过程中计算count最大对应的最小的id

## 买卖股票
+ 309.最佳买卖股票时机含冷冻期
    -  f[i] 表示第 i 天结束之后的「累计最大收益」
        + 我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；
        + 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；
        + 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。
    - 状态转移方程
        + f[i][0]=max(f[i−1][0],f[i−1][2]−prices[i])
        + f[i][1]=f[i−1][0]+prices[i]
        + f[i][2]=max(f[i−1][1],f[i−1][2])
    - 最终答案：max(f[n−1][1],f[n−1][2])        

---

## 二分查找

1. `for lower <= upper` 闭区间版本 `[lower, upper]`

   * `mid = (lower + upper) / 2`（向下取整）

     * 如果 `mid` 满足条件（要往左找更小或更左的）：`upper = mid - 1`
     * 如果不满足条件（要往右找）：`lower = mid + 1`
   * 是否跳过了 mid？

     * 表面上看，`upper = mid - 1` 似乎跳过了 `mid`
     * 实际上，`mid` 已经被判断过，`lower` 没变，下一轮 `lower == mid`
     * 循环仍会继续执行，直到 `lower > upper` 时退出
   * 示例分析：

     * 假设我们在数组 [3, 4, 5] 中查找“第一个大于等于 4 的数”
     * 初始区间 `[3, 5]`，`mid = 4`
     * 假设 `mid = 4` 满足条件 → `upper = 3`
     * 下一轮区间 `[3, 3]`，`mid = 3`
     * 假设 `mid = 3` 不满足条件 → `lower = 4`
     * 区间变为 `[4, 3]`，循环结束
     * 返回 `lower = 4`，即最小满足条件的值

2. `for lower < upper` 半开区间版本 `[lower, upper)`

   * 如果 `mid` 满足条件（往左找）：`upper = mid`
   * 如果不满足条件：`lower = mid + 1`
   * 循环结束时 `lower == upper`，即最小满足条件的位置


---

# 排序

## 冒泡排序
+ 相邻元素两两比较交换，双重循环；
+ 单次遍历没有交换的，提前结束全部遍历
+ 代码示例
```go
func bubbleSort(arr []int) {
    n := len(arr)

    if n <= 1 {
        return
    }

    for i := 0; i < n; i++ {
        unChange := true
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                unChange = false
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
        if unChange {
            break
        }
    }

}
```

## 快速排序
* 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

* 分区逻辑说明（高低下标的值交替被替换，最后得到中间下标，把参照值设置回去）：

  * `for low < high`，每次 `v[low] = v[high], v[high] = v[low]`，最后 `v[low] = temp`
  * 记得：`high--` 和 `low++` 的条件是与 `temp` 比较！
  * **每一步都要判断 `low < high`，不要忘了！**

* TopK 剪枝优化（适用于结果无需完全有序）：

  * 若 `mid > k`，处理左边部分
  * 若 `mid < k`，处理右边部分

* 分区函数定义示例：

  ```go
  func partition(arr []int, low, high int) int {
      // 先和 high 比较，循环 high--，退出后赋值；赋值前的 low < high 判断 不要漏
      // 再和 low 比较，同样套路
  }
  ```

* 快速排序递归定义：

  ```go
  var quick func(arr []int, start, end int)
  quick = func(arr []int, start, end int) {
      // ...
  }
  ```

+ 代码示例
```go
// 升序
func quickSort(arr []int) {

    var quick func(arr []int, start, end int)
    quick = func(arr []int, start, end int) {
        if start >= end {
            return
        }
        mid := partition(arr, start, end)
        quick(arr, start, mid)
        quick(arr, mid+1, end)
    }
    quick(arr, 0, len(arr)-1)
}

// low < high 的判断每一步都要，不要忘了！！
func partition(arr []int, low, high int) int {

    temp := arr[low]
    for low < high {
        for low < high && arr[high] >= temp {
            high--
        }
        if low < high {
            arr[low] = arr[high]
        }

        for low < high && arr[low] < temp {
            low++
        }
        if low < high {
            arr[high] = arr[low]
        }
    }
    arr[low] = temp
    return low
}

// 前K个最小的
func quickSortTopK(arr []int, k int) {

    var quick func(arr []int, start, end, k int)
    quick = func(arr []int, start, end, k int) {
        if start >= end {
            return
        }
        mid := partition(arr, start, end)
        if mid > k {
            //说明左边的超过k个，还需要继续排一下，而且因为左边的都小于mid的
            quick(arr, start, mid, k)
        } else if mid < k {
            //右边已经不可能出现比左边小的了，只需继续排右边的，
            quick(arr, mid+1, end, k)
        }
    }
    quick(arr, 0, len(arr)-1, k)
}
```  


## 堆排序

1. 是一个**完全二叉树**
2. 父节点 ≥ 子节点（最大堆）或 父节点 ≤ 子节点（最小堆）

* **如何实现**：

  1. 实现一个**调整堆**的方法

     * 参数为：`nums []int, parent int, length int`
     * 即指定根节点 `parent`，**从上到下调整**，根节点和左右子节点中较大的一个交换，直到没有子节点或无需交换。
  2. **初始化堆**：

     * 从最下层的根节点到最上层的根节点遍历：从 `length/2` 到 `0`
     * 每个根节点调用一次调整堆的方法
  3. **堆排序过程**：

     * 将堆顶元素（索引 0）与最后一个元素交换
     * 然后对 `[0, length-1]` 的部分重新调整堆
     * 遍历范围为 `length-1` 到 `0`，不断交换并调整堆

* **最大堆调整**（自上而下）
  `func adjust(nums []int, root int, length int)`

* **完整示例**：

```go
func heapSort(nums []int) {
    // 初始化堆：从底部非叶子节点开始，向上构建堆
    for i := len(nums) / 2; i >= 0; i-- {
        adjust(nums, i, len(nums))
    }

    // 排序过程
    for i := len(nums) - 1; i > 0; i-- {
        // 交换堆顶与末尾元素（最大值移到末尾）
        nums[i], nums[0] = nums[0], nums[i]

        // 调整堆，长度为 i，排除已经排序的部分
        adjust(nums, 0, i)
    }
}
```

> ⚠️注意：
>
> * 初始化时是 **自底向上遍历节点**，但每个节点的调整仍是 **自上向下**；
> * 排序时记得交换堆顶和尾部，再对新的堆顶进行调整；
> * `adjust` 函数内部应处理边界并选择较大的子节点进行交换。

+ 代码示例
```go
// 最大堆调整 （自上往下）
func adjust(nums []int, root, len int) {

    //left
    child := root*2 + 1

    // 左右子节点，找个最大的跟根节点交换！！
    for child < len {
        if child+1 < len && nums[child+1] > nums[child] {
            //right
            child++
        }

        //这步别忘了 ！！！
	// 它的作用是：
    //在“最大堆”的结构调整过程中，判断当前根节点是否已经大于等于它的子节点，如果是，就说明已经满足最大堆的性质，可以提前终止调整
        if nums[child] <= nums[root] {
            break
        }

        nums[child], nums[root] = nums[root], nums[child]

        root = child
        //left
        child = root*2 + 1
    }
}

func heapSort(nums []int) {

    //init （自底向上）
    //即从length/2 到0，每个根节点使用上述调整堆的方法
    for i := len(nums) / 2; i >= 0; i-- {
        adjust(nums, i, len(nums))
    }

    //sort
    for i := len(nums) - 1; i > 0; i-- {
        //这里是交换！！！！
        nums[i], nums[0] = nums[0], nums[i]

        //这里的调整要指定长度，因为最后的几位已经排序了，不应该继续被堆调整影响
        //这里是i，因为是调整交换过前面的，第一次，i刚好是len(nums) - 1， 即最后一位不调整
        adjust(nums, 0, i)
    }

}

/** 最大堆， TopK， 取前K个最大值， 且有序 */
func heapSortTopK(nums []int, k int) []int {

    //init
    for i := len(nums) / 2; i >= 0; i-- {
        adjust(nums, i, len(nums))
    }

    //sort
    for i := len(nums) - 1; i > len(nums)-1-k; i-- {
        nums[i], nums[0] = nums[0], nums[i]
        adjust(nums, 0, i)
    }

    return nums[len(nums)-k:]
}
```

---

# 链表
+ 链表而不是数组，构建子链不增加空间复杂度。勇敢地构造子链即可，无需考虑节点交换。不用总想想原地交换。
+ 哨兵节点的技巧，避免处理头指针等特殊情况，在代码处理中会比较方便
    - 链表内指定区间反转：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
    ```go
    func reverseBetween(head *ListNode, m int, n int) *ListNode {
        if m == n || head == nil {
            return head
        }

        //哨兵节点， 避免处理头指针特殊情况
        dummy := &ListNode{Next: head}
        pre := dummy

        // 1. 找到第 m-1 个节点
        for i := 1; i < m; i++ {
            pre = pre.Next
        }

        // 2. 反转 m 到 n 之间的节点，头插法
        start := pre.Next      // 第 m 个节点
        then := start.Next     // 第 m+1 个节点

        for i := 0; i < n-m; i++ {
            start.Next = then.Next
            then.Next = pre.Next
            pre.Next = then
            then = start.Next
        }

        return dummy.Next
    }    
    ```

# 二叉树
+ 二叉树遍历(先序、中序、后序)
    - 先序（中左右），中序（左中右），后序（左右中）
    - 递归遍历和非递归遍历
+ 二叉查找树(搜索树)（ Binary Search Tree）
    - 保证左子树上所有节点的值都小于根节点的值，而右子树上所有节点的值都大于根节点的值（注意不能等于）(按中序遍历有序)    
+ 完全二叉树--若二叉树的深度为 h，除第 h 层外，其它各层的节点数都达到最大个数，第 h 层所有的叶子节点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）
    + 堆的结构可以分为大顶堆和小顶堆，是一个完全二叉树
+ 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

## 二叉树遍历
+ 树的遍历主要有两种方式：
    - 广度优先遍历（BFS）：也称层序遍历，使用队列实现。
    - 深度优先遍历（DFS）：包括先序、中序和后序三种形式，通常使用栈实现。
        - 递归
        - 栈
+ 深度优先搜索（DFS）
    - 使用递归实现 DFS 时，虽然代码中没有显式使用栈，但实际依赖的是系统的**调用栈（Call Stack）**来完成函数的递归调用和回溯。


### 先序（前序）
+ 栈实现
    1. `root!=nil || len(stack)>0`
    2. root!=nil 处理逻辑，入栈，左子树赋值
    3. else 出栈，右子树赋值

```go
func (root *TreeNode) preorder() []int {
	res := []int{}
	if root == nil {
		return res
	}
	stack := []*TreeNode{}
	for root != nil || len(stack) > 0 {
		if root != nil {
			res = append(res, root.data)      // 访问当前节点
			stack = append(stack, root)       // 入栈
			root = root.Lchild                // 向左子树移动
		} else {
			root = stack[len(stack)-1]        // 出栈
			stack = stack[:len(stack)-1]
			root = root.Rchild                // 转向右子树
		}
	}
	return res
}
```

### 中序
+ 栈实现
    1. `root!=nil || len(stack)>0`
    2. root!=nil 左子树循环入栈
    3. 出栈，处理逻辑
    4. `root=root.Right` 右子树赋值

```go
func (root *TreeNode) inorder() []int {
	res := []int{}
	if root == nil {
		return res
	}
	stack := []*TreeNode{}
	for root != nil || len(stack) > 0 {
		if root != nil {
			stack = append(stack, root)       // 入栈，等待回溯
			root = root.Lchild                // 向左走
		} else {
			root = stack[len(stack)-1]        // 出栈
			stack = stack[:len(stack)-1]
			res = append(res, root.data)      // 访问节点
			root = root.Rchild                // 转向右子树
		}
	}
	return res
}
```

+ 示例题目
    - 判断一颗二叉树是否为二叉查询树
    ```go
    func isValidBST(root *TreeNode) bool {
        stack := []*TreeNode{}
        inorder := math.MinInt64
        for len(stack) > 0 || root != nil {
            for root != nil {
                stack = append(stack, root)
                root = root.Left
            }
            root = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if root.Val <= inorder {
                return false
            }
            inorder = root.Val
            root = root.Right
        }
        return true
    }
    ```

### 后序
```go
func (root *TreeNode) Postorder() []int {
	res := []int{}
	if root == nil {
		return res
	}
	stack := []*TreeNode{}
	var pre *TreeNode = nil
	stack = append(stack, root)

	for len(stack) > 0 {
		cur := stack[len(stack)-1]
		// 如果是叶子，或子节点刚处理完，访问当前节点
		if (cur.Lchild == nil && cur.Rchild == nil) || (pre != nil && (pre == cur.Lchild || pre == cur.Rchild)) {
			res = append(res, cur.data)
			stack = stack[:len(stack)-1]
			pre = cur // 标记已访问
		} else {
			if cur.Rchild != nil {
				stack = append(stack, cur.Rchild)
			}
			if cur.Lchild != nil {
				stack = append(stack, cur.Lchild)
			}
		}
	}
	return res
}
```

##  删除二叉搜索树中的节点
+ 删除节点的四种情况：
    1. 叶子节点（无子节点）
        - 直接删除，返回 nil。
    2. 只有左子树
        - 用左子节点替代当前节点，返回 root.Left。
    3. 只有右子树
        - 用右子节点替代当前节点，返回 root.Right。
    4. 左右子树都有
        - 找右子树中最小的节点（即后继 successor），
        - 用 successor 的值替代当前节点，
        - 然后递归删除 successor 节点。
+ 第四种情况
    - **右子树的最小节点（即 successor）**不一定是叶子节点
    - 一定不会有左子节点， 可能有右子节点
```
      10                        11        
     /  \                      /  \
    5    15                   5   15
        /                         /  
       11       -->             13
         \                     /  \  
         13                   12  14
        /  \
       12   14
```    
+ 什么是“递归删除 successor 节点”？
    - 当我们在删除一个节点（设为 root）时，若它有左右子树，我们选择右子树中最小的节点作为它的替代（即 successor），用 successor.Val 来替换 root.Val。
    - 但此时右子树中还有一个原本的 successor 节点，所以我们还要在 右子树中递归地删除掉那个 successor 节点，这样整棵树才仍然满足二叉搜索树（BST）性质。

+ 实现示例
```go
func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}

	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
	} else if key > root.Val {
		root.Right = deleteNode(root.Right, key)
	} else {
		// 找到了要删除的节点
		if root.Left == nil {
			return root.Right
		}
		if root.Right == nil {
			return root.Left
		}
		
		// 情况4：左右子树都有
		successor := findMin(root.Right)
		root.Val = successor.Val // 用 successor 的值替换 root
		root.Right = deleteNode(root.Right, successor.Val) // 递归删除 successor
	}

	return root
}

// 找最小值节点（最左节点）
func findMin(node *TreeNode) *TreeNode {
	for node.Left != nil {
		node = node.Left
	}
	return node
}
```
+ 这里“递归删除 successor”的处理方式是保留当前节点 root，用 successor.Val 赋值替换掉 root.Val，然后再去右子树里“真正”删除掉那个 successor 节点对象。
+ 从指针角度讲，被删掉的是 successor 节点本身，root 这个节点没有被删除，只是“变身”了
+ “值替换 + 递归删除”策略 的好处是：
    1. 不需要处理太复杂的指针引用或父节点更新
    2. 删除 successor 时只涉及一边的子树（右子树），逻辑简单
    3. 最终结果符合 BST 的有序性

+ “直接指针替换”
```go
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}

	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
		return root
	} else if key > root.Val {
		root.Right = deleteNode(root.Right, key)
		return root
	}

	// 找到了要删除的节点
	if root.Left == nil {
		return root.Right
	}
	if root.Right == nil {
		return root.Left
	}

	// 情况4：左右子树都有，结构替换法
	successor := root.Right
	parent := root

	// 找 successor，并记录其父节点
	for successor.Left != nil {
		parent = successor
		successor = successor.Left
	}

	// 删除 successor 节点
	if parent != root {
        //successor 肯定没有左孩子，但可能有右孩子，所以删除 successor 时，要让它的父节点接管其右子树。parent.Left 原来指向root
		parent.Left = successor.Right
        //删除了root由successor替代，自然由successor接管root的右子树
		successor.Right = root.Right
	}
    //如果 successor 就是 root.Right（parent == root ），本身就是右子树的根，那么不需要动 parent，只需把它的 Left 指向 root.Left 即可。
	successor.Left = root.Left

	// 释放原 root，返回 successor 替代它
	return successor
}
```

---


# 堆
### 基本性质与操作（以最大堆为例）
1. 最大堆的性质
    - 最大堆是一种**完全二叉树**，满足每个父节点的值都**大于或等于**其左右子节点的值。
    - 逻辑结构为树，通常用数组实现。
2. 元素的插入与删除方式
- **插入新节点**：将元素追加到数组最后，然后**向上调整（Sift-Up）**，直到堆序恢复。
- **删除任意节点**：将要删除的节点与**数组最后一位交换**，然后删除最后一位：
    - 若新值**比父节点大** → **向上调整**
    - 若新值**比子节点小** → **向下调整**
3. 特殊操作：删除堆顶（最大值）
    - 删除堆顶（即数组第一个元素）时，将最后一个元素替换到根位置，再进行**向下调整（Sift-Down）**，恢复堆序。
4. 时间复杂度分析
    - **插入、删除操作**中最多调整一条从根到叶或叶到根的路径，时间复杂度均为：
    > ✅ **O(log n)**
5. 与二分查找的比较
    - **二分查找**与最大堆插入/删除操作一样，其时间复杂度也是：
    > ✅ **O(log n)**
    > 不过它基于**有序数组**，而堆则是**局部有序结构**，两者原理与使用场景不同。


# 图

## 无向图
+ 由两个部分组成：
    - 顶点（Vertices）：图中的节点。
    - 边（Edges）：连接两个顶点的线段。

+ 边用集合表示：一条边连接两个顶点，用 {A, B} 表示；而不是有向图中的 (A, B)。
  度（Degree）：一个顶点的度是连接它的边的数量（不区分方向）。

+ 无向图可以表示为：
  - 顶点：`{A, B, C}`
  - 边：`{{A, B}, {B, C}}`
+ 图形大致如下：
  - `A —— B —— C`

+ 无向图的深度优先搜索
  - 起始于某个顶点；
  - 标记为“已访问”；
  - 遍历它的邻居；
  - 对于每一个未访问过的邻居，递归执行 DFS；
  - 遇到死胡同（没有未访问的邻居）就回退。

+ 递归实现 DFS：
```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    print(start)  # 访问当前节点
    visited.add(start)

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# 调用
dfs(graph, 'A')
```
+ 非递归实现（使用栈）
```python
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            print(node)
            visited.add(node)
            # 为了保持顺序，反转邻居顺序
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

dfs_iterative(graph, 'A')
```
+ 无向图 DFS 的注意事项
    - 防止死循环：一定要用 visited 集合记录已访问节点，因为无向图的边是双向的，否则可能在 A-B-A-B 之间反复访问。
    - 图不连通时，只 DFS 一个起点可能无法遍历整个图；可以对所有节点进行一次 DFS

```python
def dfs_all(graph):
    visited = set()
    for node in graph:
        if node not in visited:
            dfs(graph, node, visited)
```

##  有向图

###  有向图的拓扑排序

+ 有向图的拓扑排序（Topological Sorting of a Directed Graph）是一种将**有向无环图（DAG，Directed Acyclic Graph）**中的所有顶点排成线性序列的方法，使得对于每一条有向边 u → v，顶点 u 都排在 v 的前面。

+ 拓扑排序就是给有依赖关系的事情排一个顺序。例如：
    - 学习顺序：先学 A，再学 B，最后学 C。
    - 项目任务：某个任务必须在另一个任务完成后才能进行。
    - 如果我们把每个任务看作图的一个节点，每个“先做 A 才能做 B”的关系看作一条从 A 指向 B 的有向边，整个问题就变成了对一个 DAG 做拓扑排序。

+ 适用范围
  - 必须是有向无环图（DAG）。
  - 如果图中存在环，则无法拓扑排序。

+ 拓扑排序的常用算法：
  - 方法一：入度表 + 队列（Kahn 算法） 卡恩算法
    + 统计每个顶点的入度（有多少边指向它）。
    + 将所有入度为 0 的点加入队列。
    + 从队列中取出一个顶点 u，加入结果序列。
    + 删除所有从 u 出发的边（即相邻顶点 v 的入度减 1）。
    + 如果 v 的入度变为 0，把它加入队列。
    + 重复直到队列为空。
    + 如果结果序列中包含了所有节点，说明拓扑排序成功；否则图中有环。
  - 方法二：DFS（深度优先搜索）法
    + 从一个未访问的节点开始 DFS。
    + 每访问一个节点，递归访问它所有的后继节点。
    + 后继节点都访问完后，把当前节点加入栈。
    + 所有节点访问完成后，从栈顶到栈底就是拓扑序列。
  - 应用场景
    + 编译器：代码编译顺序（模块依赖）
    + 项目管理：任务调度（任务依赖）
    + 数据管道：处理步骤排序
    + 课程表安排（如 Leetcode 207, 210）

### Kahn 算法
```go
// 拓扑排序（Kahn 算法）
func topologicalSort(graph map[string][]string) ([]string, bool) {
  inDegree := make(map[string]int)
  var result []string

  // 初始化入度表
  for u := range graph {
    if _, ok := inDegree[u]; !ok {
      inDegree[u] = 0
    }
    for _, v := range graph[u] {
      inDegree[v]++
    }
  }

  // 入度为0的节点入队
  var queue []string
  for node, deg := range inDegree {
    if deg == 0 {
      queue = append(queue, node)
    }
  }

  // 拓扑排序
  for len(queue) > 0 {
    // 出队一个元素
    node := queue[0]
    queue = queue[1:]
    result = append(result, node)

    // 遍历它的邻接点
    for _, neighbor := range graph[node] {
      inDegree[neighbor]--
      if inDegree[neighbor] == 0 {
        queue = append(queue, neighbor)
      }
    }
  }

  // 判断是否是 DAG（拓扑排序成功）
  if len(result) != len(inDegree) {
    return nil, false // 有环
  }
  return result, true
}

func main() {
  // 示例图（没有B→C）
  graph := map[string][]string{
    "A": {"B", "C"},
    "B": {"D"},
    "C": {"D"},
    "D": {},
  }

  order, ok := topologicalSort(graph)
  if !ok {
    fmt.Println("图中存在环，无法拓扑排序")
  } else {
    fmt.Println("拓扑排序结果：", order)
  }
}

```

+ Kahn 算法之所以可以完成拓扑排序，关键在于它 逐步移除入度为 0 的节点，并确保所有依赖顺序都被满足。
+ Kahn 算法的关键逻辑：
  - 每次只处理 入度为 0 的节点，说明这个节点没有任何前驱（没有依赖）。
  - 它可以排在最前面，因为没人依赖它，它也不依赖别人。
  - 处理完一个节点（加入结果），就“删除”它对别人的依赖（让它指向的节点入度减 1）。
  - 只有在所有前驱都处理完之后，一个节点才能变为入度 0 → 再被处理。
  - 这个过程正好保证了拓扑排序中“先处理前驱，再处理后继”的要求。
+ 为什么只适用于有向无环图（DAG）？
    - 如果图中有 环，那么某个节点永远不会变成入度为 0（因为它始终有一个前驱在环里）。
    - 这样队列就会耗尽，剩下的节点都还有入度 ≠ 0，导致结果节点数量 < 图中节点数。
✅  - 因此：可以用这个算法顺便检测是否有环（如果排序结果节点数 < 图节点数，说明有环）

+ Kahn 算法之所以成立，是因为它始终只处理“没有依赖的节点”，每次处理都维护了拓扑顺序的合法性。只要图是 DAG，就一定能处理完所有节点，得到一个正确的拓扑排序。

+ **Kahn 算法本质上是一种基于入度的拓扑排序算法，它的遍历过程就是广度优先搜索（BFS）**。

+ ✅ Kahn 算法 和 广度优先搜索（BFS）的关系：

| 项目   | Kahn 算法         | 广度优先搜索          |
| ---- | --------------- | --------------- |
| 遍历方式 | 一层一层（按入度为0的点）   | 一层一层（按邻居节点）     |
| 使用结构 | 队列（Queue）       | 队列（Queue）       |
| 访问顺序 | 所有入度为0的点先访问     | 所有与当前点直接相连的点先访问 |
| 主要用途 | 拓扑排序（检测有向图是否有环） | 遍历图中所有可达节点      |

+ 总结一句话：

> **Kahn 算法就是 BFS 应用于拓扑排序的版本**，只不过它关心的是“入度为 0 的点”而不是“当前节点的邻居”。
**它就是一种基于 BFS 思想的拓扑排序方法。**

---

# 动态规划

* **动态规划的本质是**：**穷举**所有可能的解。
+ 穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」
* 但动态规划问题往往存在大量**重叠子问题**，**暴力穷举效率极低**，因此需要使用：
  * **备忘录（记忆化递归）** 或 **DP table（递推数组）** 来**优化穷举过程，避免重复计算**；
  * 其中，**DP table 是自底向上求解**，**递归解法是自顶向下求解**。
* **动态规划 = 穷举 + 剪枝**。
* 动态规划的解题步骤：
  1. 找到“状态”和“选择”；
  2. 明确 dp 数组 / 函数的定义；
  3. 建立状态转移关系。
* 动态规划还可以通过**状态压缩**优化空间复杂度，例如将 O(N²) 优化为 O(N)。




---

# 回溯
+ 排列、组合、子集

### 通用回溯模板总结
| 题型          | 递归参数 | 关键点               | 重复处理策略                 | 代码模板示例（Go 伪码简化）   |
| ----------- | ---- | ----------------- | ---------------------- | ----------------- |
| **排列**      | 无需起点 | 需要标记已用元素 `used[]` | 排序 + `used` + 跳过相邻重复元素 | 见排列 II 模板         |
| **组合 / 子集** | 需要起点 | 控制遍历起点，防止重复使用前面元素 | 排序 + 跳过同层相邻重复元素        | 见组合 II / 子集 II 模板 |


## 1. 排列（Permutation）

### 1.1 无重复元素 — 基础排列（46）
+ [46. 全排列](https://leetcode.cn/problems/permutations/description/)

```go
func permute(nums []int) [][]int {
    var res [][]int
    var path []int
    used := make([]bool, len(nums))

    var dfs func()
    dfs = func() {
        if len(path) == len(nums) {
            res = append(res, append([]int(nil), path...))
            return
        }
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            used[i] = true
            path = append(path, nums[i])
            dfs()
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs()
    return res
}
```

### 1.2 有重复元素 — 排列 II（47）
+ 相比46，增加
    - 排序
    - 重复判断剪枝

```go
func permuteUnique(nums []int) [][]int {
    sort.Ints(nums)
    var res [][]int
    var path []int
    used := make([]bool, len(nums))

    var dfs func()
    dfs = func() {
        if len(path) == len(nums) {
            res = append(res, append([]int(nil), path...))
            return
        }
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
		    //只能先用同一组重复数字的“第一个”，不能先用后面的。（前面的没选，后面相同的也不选）
		    //如果现在选择了后一个重复元素，就会导致重复排列。
            //加入前面标记为1，后面为2，就会出现12， 21，如果两个字符一样，那么就重复，只能让12存在即可
                continue
            }
            used[i] = true
            path = append(path, nums[i])
            dfs()
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs()
    return res
}
```

## 2. 组合 / 子集（Combination / Subset）

> 组合和子集本质相似，区别通常在题目描述和是否需要用所有元素。

### 2.1 无重复元素 — 组合 / 子集 I（如 78）

```go
func subsets(nums []int) [][]int {
    var res [][]int
    var path []int

    var dfs func(start int)
    dfs = func(start int) {
        res = append(res, append([]int(nil), path...))
        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            dfs(i + 1)
            path = path[:len(path)-1]
        }
    }
    dfs(0)
    return res
}
```

### 2.2 有重复元素 — 组合 / 子集 II（如 90）

```go
func subsetsWithDup(nums []int) [][]int {
    sort.Ints(nums)
    var res [][]int
    var path []int

    var dfs func(start int)
    dfs = func(start int) {
        res = append(res, append([]int(nil), path...))
        for i := start; i < len(nums); i++ {
            if i > start && nums[i] == nums[i-1] {
                continue
            }
            path = append(path, nums[i])
            dfs(i + 1)
            path = path[:len(path)-1]
        }
    }
    dfs(0)
    return res
}
```

+ 子集/组合，也可以有不使用for的版本，比如子集（78）
```go
func subsetsDfs(nums []int) (ans [][]int) {

	var set []int
	var dfs func(int)
	dfs = func(cur int) {
		if cur == len(nums) {
			ans = append(ans, append([]int(nil), set...))
			return
		}
		set = append(set, nums[cur])//选
		dfs(cur + 1)
		set = set[:len(set)-1]//不选
		dfs(cur + 1)
	}
	dfs(0)
	return
}
```

## 总结要点

| 特征         | 排列（Permutation）       | 组合 / 子集（Combination / Subset） |
| ---------- | --------------------- | ----------------------------- |
| 是否用 `used` | 是                     | 否（一般）                         |
| 是否排序       | 重复元素时必须排序             | 重复元素时必须排序                     |
| 是否有起点参数    | 可无（used法），有时用 `cur`   | 必须有起点参数 `cur`                 |
| 去重判断       | 有重复元素时判断 `!used[i-1]` | 有重复元素时跳过同层相同元素                |
| 递归参数       | 可无或固定（`dfs()`）        | 必须带起点（`dfs(cur int)`）         |

## 扩展
+ 在回溯问题中，定义全局变量 和 作为参数传入 dfs 函数 通常效果一样，但有以下差异：
    - 全局变量更方便：
        - 写法更简洁，不需要层层传参。
        - 多个函数共享变量时更自然
    - 参数传入更清晰：
        - 函数更纯粹，逻辑封装性好。
        - 每层递归状态独立，减少副作用。 

+ for版本只能做“选”的操作，“不选”是通过 i++ 自然进行的，不要在循环体中再手动写“跳过”逻辑。否则就是重复遍历和乱序回溯，结果就错了或多了。
    - 比如题：[39. 组合总和](https://leetcode.cn/problems/combination-sum/)： 给定一个无重复的正整数数组 candidates，要求找出所有可以重复使用元素，使其组合之和等于 target 的方案。每种组合中元素顺序不限，只要选的数字个数或顺序不同就视为不同组合。题目要求输出所有可能组合，且每个数字可无限次使用。
    - 写法一：for 循环只做“选”的操作（推荐）
    ```go
    func combinationSum(candidates []int, target int) [][]int {
        var ans [][]int
        var path []int

        var dfs func(start, target int)
        dfs = func(start, target int) {
            if target == 0 {
                temp := make([]int, len(path))
                copy(temp, path)
                ans = append(ans, temp)
                return
            }
            for i := start; i < len(candidates); i++ {
                if target >= candidates[i] {
                    path = append(path, candidates[i])
                    dfs(i, target-candidates[i]) // 可重复选 i，所以还是 i
                    path = path[:len(path)-1]
                }
            }
        }
        dfs(0, target)
        return ans
    }
    ```
    - 写法二：不用 for，用显式“选 or 不选”的逻辑
    ```go
    func combinationSum(candidates []int, target int) [][]int {
        var ans [][]int
        var path []int

        var dfs func(index, target int)
        dfs = func(index, target int) {
            if target == 0 {
                temp := make([]int, len(path))
                copy(temp, path)
                ans = append(ans, temp)
                return
            }
            if index == len(candidates) || target < 0 {
                return
            }
            // 选当前
            path = append(path, candidates[index])
            dfs(index, target - candidates[index])
            path = path[:len(path)-1]

            // 不选当前
            dfs(index + 1, target)
        }
        dfs(0, target)
        return ans
    }
    ```



##  DFS 模板的两种核心模式

+ 模式一：组合型问题 → 需要 for 循环
    - 例如：子集、组合、排列等
    ```go
    for i := start; i < len(nums); i++ {
        // 做选择
        path = append(path, nums[i])
        dfs(i + 1) // 往下递归
        path = path[:len(path)-1] // 撤销选择
    }
    ```
 - 每一步你可以选择“要”或“不要”当前数，所以从 start 到 len(nums) 都是备选项，因此你要遍历

+ 模式二：构造型问题 → 不需要 for 循环
    - 电话号码字母组合、走迷宫、树的路径
    ```go
    //这里不是枚举位置，而是枚举当前一个位置的合法字符选项。
    for _, ch := range phoneMap[digits[index]] {
        dfs(index + 1, path + ch)
    }
    ```
    - 每一层只能处理一个位置的选项，只做一位，而不是在当前层挑选后面的数。
    - 题目：[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)：列出数字字符串对应的所有可能的字母组合，组合规则基于电话按键的映射关系。
    ```go
    func letterCombinations(digits string) []string {

        if len(digits) == 0 {
            return []string{}
        }

        var phoneMap = map[rune]string{
            '2': "abc",
            '3': "def",
            '4': "ghi",
            '5': "jkl",
            '6': "mno",
            '7': "pqrs",
            '8': "tuv",
            '9': "wxyz",
        }

        var results []string
        var dfs func(start int, str string)
        dfs = func(start int, str string) {
            if start == len(digits) {
                results = append(results, str)
                return
            }
            //这里不是枚举位置，而是枚举当前一个位置的合法字符选项。
            for _, ch := range phoneMap[rune(digits[start])] {
                dfs(start+1, str+string(ch))
            }
        }
        dfs(0, "")
        return results
    }    
    ```

```
回溯问题
├── 排列类（顺序重要）
├── 组合类（顺序不重要，元素不可复用）
├── 子集类（选或不选，全部组合）
└── 构造类（位置填值，无选或不选）- 都要选！
```
+ 只要每层递归不存在“多个备选选项”的情况，也就是没有“选或不选”(位置上)的分支，DFS 就不需要** for 循环。**
+ 需要 for 的场景：有“选或不选”或“选哪个”的问题 （for是指枚举位置）
    - 子集 → 每个元素选或不选
    - 组合 → 从多个位置中选哪些
    - 排列 → 多个未使用元素中选一个




---




---

# 后记
+ 然而熟练，何尝不是另一种形式的“背”呢